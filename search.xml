<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MarkDown</title>
    <url>/2018/05/08/MarkDown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default">
</script>

<h1 id="段落元素"><a href="#段落元素" class="headerlink" title="段落元素"></a>段落元素</h1><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;br/&gt;</span><br></pre></td></tr></table></figure>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">...</span><br><span class="line">###### 这是六级标题</span><br></pre></td></tr></table></figure>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 这是外层的引用</span><br><span class="line">&gt; &gt; 这是内层的引用</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是外层的引用</p>
<blockquote>
<p>这是内层的引用</p>
</blockquote>
</blockquote>
<h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>无序列表使用 -、 + 或 * 来作为标记。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 第一项</span><br><span class="line">- 第二项</span><br><span class="line">- 第三项</span><br></pre></td></tr></table></figure></p>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>有序列表使用数字和紧挨着的点号表示。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 第一项</span><br><span class="line">2. 第二项</span><br><span class="line">3. 第三项</span><br></pre></td></tr></table></figure></p>
<ol>
<li>第一项</li>
<li>阿斯蒂芬</li>
<li>第二项</li>
<li>第三项</li>
</ol>
<h2 id="代码区域"><a href="#代码区域" class="headerlink" title="代码区域"></a>代码区域</h2><p>缩进 4 个空格或者用三个’来包裹。</p>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>使用三个及以上的 *、 - 或 _来表示一个分割线。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">***</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| Table | Col1 | Col2 |</span><br><span class="line">| ----- |:----:| ----:|</span><br><span class="line">| Row1  | 1-1  | 1-2  |</span><br><span class="line">| Row2  | 2-1  | 2-2  |</span><br><span class="line">| Row3  | 3-1  | 3-2  |</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>Table</th>
<th style="text-align:center">Col1</th>
<th style="text-align:right">Col2</th>
</tr>
</thead>
<tbody>
<tr>
<td>Row1</td>
<td style="text-align:center">1-1</td>
<td style="text-align:right">1-2</td>
</tr>
<tr>
<td>Row2</td>
<td style="text-align:center">2-1</td>
<td style="text-align:right">2-2</td>
</tr>
<tr>
<td>Row3</td>
<td style="text-align:center">3-1</td>
<td style="text-align:right">3-2</td>
</tr>
</tbody>
</table>
<p>上面第二行中的点代表对齐方式，分别是默认（居右）、居中、居左。</p>
<h1 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h1><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//方式 1</span><br><span class="line">[百度](http://www.baidu.com)</span><br><span class="line"></span><br><span class="line">//方式 2</span><br><span class="line">[百度][Baidu-url]</span><br><span class="line">[Baidu-url]: http://www.baidu.com</span><br><span class="line"></span><br><span class="line">//方式 3</span><br><span class="line">&lt;http://www.baidu.com&gt;</span><br></pre></td></tr></table></figure>
<p><a href="http://www.baidu.com" target="_blank" rel="noopener">百度</a></p>
<h2 id="斜体或者加粗"><a href="#斜体或者加粗" class="headerlink" title="斜体或者加粗"></a>斜体或者加粗</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**这是加粗文字**</span><br><span class="line">__这也是加粗文字__</span><br><span class="line"></span><br><span class="line">//斜体</span><br><span class="line">*这是斜体文字*</span><br><span class="line">_这也是斜体文字_</span><br></pre></td></tr></table></figure>
<p><strong>这是加粗文字</strong><br><br><em>这是斜体文字</em><br></p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>图片的插入方式跟超链接前两种插入方式类似。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//方式 1</span><br><span class="line">![如果图片不能显示，就显示这段文字](图片 url)</span><br><span class="line"></span><br><span class="line">//方式 2</span><br><span class="line">![如果图片不能显示，就显示这段文字][Image-url]</span><br><span class="line">[Image-url]: 图片url &quot;这是提示文字&quot;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>我们经常需要在文章中插入一些特殊符号，而这些符号恰好是前面所讲的标识符号，可以在特殊符号前插入 \ 来直接显示符号，而不让 Markdown 来将其解释为标识符号。</p>
</blockquote>
<h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><p>其实，市场上有很多的 Markdown 解释器，它们大都能支持上面所讲的语法，但呈现出的样式往往不一。另外，不同的解释器还能支持其他自己定义的语法，比如 Github 还能支持 emoji。下面再着重介绍 Github 支持的几个 Markdown 语法。不过需要注意的是，有些语法只能在 issue 或者 pull request 上使用，这个在后面讲每个语法时会标记（约定：“通用”表示在 Github 任何地方可以使用的语法，“特殊”表示只能在 issue 或者 pull request 上使用）。</p>
<h2 id="语法高亮-通用"><a href="#语法高亮-通用" class="headerlink" title="语法高亮(通用)"></a>语法高亮(通用)</h2><p>上面说过，有的解释器是能够显示语法高亮的，Github 就可以。</p>
<h2 id="任务列表（通用）"><a href="#任务列表（通用）" class="headerlink" title="任务列表（通用）"></a>任务列表（通用）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- [ ] task one</span><br><span class="line">- [x] task two</span><br></pre></td></tr></table></figure>
<ul>
<li style="list-style: none"><input type="checkbox"> task one</li>
<li style="list-style: none"><input type="checkbox" checked> task two</li>
</ul>
<h2 id="表格（通用）"><a href="#表格（通用）" class="headerlink" title="表格（通用）"></a>表格（通用）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">First Header | Second Header</span><br><span class="line">------------ | -------------</span><br><span class="line">Content from cell 1 | Content from cell 2</span><br><span class="line">Content in the first column | Content in the second column</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>First Header</th>
<th>Second Header</th>
</tr>
</thead>
<tbody>
<tr>
<td>Content from cell 1</td>
<td>Content from cell 2</td>
</tr>
<tr>
<td>Content in the first column</td>
<td>Content in the second column</td>
</tr>
</tbody>
</table>
<h2 id="SHA-引用（特殊）"><a href="#SHA-引用（特殊）" class="headerlink" title="SHA 引用（特殊）"></a>SHA 引用（特殊）</h2><p>每一次 commit 都会产生一个 id，用 @id 的方式可以链接到某个项目的特定的 commit。比如用 jquery/jquery@1b9575b9d14399e9426b9eacdd92b3717846c3f2 就能链接到 jquery 的一次 commit 记录上。</p>
<h2 id="issue-引用（特殊）"><a href="#issue-引用（特殊）" class="headerlink" title="issue 引用（特殊）"></a>issue 引用（特殊）</h2><p>用 #1 来引用当前 repo 的第一个 issue，<br>也可以用 jquery/jquery#1 引用 jquery 的第一次 issue。</p>
<h2 id="（特殊）"><a href="#（特殊）" class="headerlink" title="@（特殊）"></a>@（特殊）</h2><p>用 @ 来提醒目标用户。比如 @CompileYouth 可以 @ 到我。</p>
<h2 id="删除符号（通用）"><a href="#删除符号（通用）" class="headerlink" title="删除符号（通用）"></a>删除符号（通用）</h2><p>用连续两个 ~ 包围的词会被加上删除符。比如 <del>This is removed</del>。</p>
<p>Emoji（通用）<br>Github 比较有意思的是可以支持 emoji。比如 :smile: 表示笑脸等等。</p>
<h2 id="插入公式"><a href="#插入公式" class="headerlink" title="插入公式"></a>插入公式</h2><h3 id="方法一：使用Google-Chart的服务器"><a href="#方法一：使用Google-Chart的服务器" class="headerlink" title="方法一：使用Google Chart的服务器"></a>方法一：使用Google Chart的服务器</h3><p>公式:<br><code>&lt;img src=&quot;http://chart.googleapis.com/chart?cht=tx&amp;chl= 在此插入Latex公式&quot; style=&quot;border:none;&quot;&gt;</code></p>
<p>例子：<br><code>&lt;img src=&quot;http://chart.googleapis.com/chart?cht=tx&amp;chl=\Large x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}&quot; style=&quot;border:none;&quot;&gt;</code></p>
<p>结果：<br><img src="http://chart.googleapis.com/chart?cht=tx&chl=\Large x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}" style="border:none;"></p>
<h3 id="方法二：使用forkosh服务器"><a href="#方法二：使用forkosh服务器" class="headerlink" title="方法二：使用forkosh服务器"></a>方法二：使用forkosh服务器</h3><p>公式:<br><code>&lt;img src=&quot;http://www.forkosh.com/mathtex.cgi? 在此处插入Latex公式&quot;&gt;</code></p>
<p>例子：<br><code>&lt;img src=&quot;http://www.forkosh.com/mathtex.cgi? \Large x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}&quot;&gt;</code></p>
<p>结果：<br><img src="http://www.forkosh.com/mathtex.cgi? \Large x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}"></p>
<blockquote>
<p>其中方法一和方法二基本可以认为是一种方法，其基本思路是将公式传到公式解析服务器，生成图片，然后将图片插入到文档中。</p>
</blockquote>
<h3 id="方法三：使用MathJax引擎"><a href="#方法三：使用MathJax引擎" class="headerlink" title="方法三：使用MathJax引擎"></a>方法三：使用MathJax引擎</h3><p>插入：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>使用tex写公式。<br>输入如下代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$x=\frac&#123;-b\pm\sqrt&#123;b^2-4ac&#125;&#125;&#123;2a&#125;$$</span><br><span class="line">\\(x=\frac&#123;-b\pm\sqrt&#123;b^2-4ac&#125;&#125;&#123;2a&#125;\\)</span><br></pre></td></tr></table></figure></p>
<p>分别显示结果（行间公式）：$$x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}$$<br>行内公式：\(x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}\)</p>
]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/2018/12/17/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>使用继承可以实现代码的复用，比如提取子类中共同的行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ducker</span></span>&#123;</span><br><span class="line">  fly();</span><br><span class="line">  bark();</span><br><span class="line">  swim();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MallardDuck</span> <span class="keyword">extends</span> <span class="title">Ducker</span></span>&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedheadDuck</span> <span class="keyword">extends</span> <span class="title">Ducker</span></span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>有一个问题是，fly的行为可能因“类”而异。譬如唐老鸭就不会飞。<strong>怎么解决？</strong></p>
<blockquote>
<p>设计原则：把易变的部分抽取出来，与不变的部分独立开。</p>
</blockquote>
<p>使用接口来抽象易变的代码怎么样？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span>()</span>&#123;</span><br><span class="line">  fly();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MallardDuck</span> <span class="keyword">extends</span> <span class="title">Ducker</span> <span class="keyword">implements</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">  fly(..);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedheadDuck</span> <span class="keyword">extends</span> <span class="title">Ducker</span> <span class="keyword">implements</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">  fly(..);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样处理的问题是，每一个子类都要实现接口，无法复用！<strong>怎么解决？</strong></p>
<p>给飞行的行为提供具体的实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyWithWings</span> <span class="keyword">implements</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">  fly(..);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyNoWay</span> <span class="keyword">implements</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">  fly(..);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让鸭子的子类自己去选择飞行的方式(委托给行为类)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ducker</span></span>&#123;</span><br><span class="line">  Flyable flyable;</span><br><span class="line"></span><br><span class="line">  fly()&#123; flyable.fly; &#125;;</span><br><span class="line">  bark();</span><br><span class="line">  swim();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MallardDuck</span> <span class="keyword">extends</span> <span class="title">Ducker</span></span>&#123;</span><br><span class="line">  MallardDuck()&#123;</span><br><span class="line">    flyable = <span class="keyword">new</span> FlyWithWings();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedheadDuck</span> <span class="keyword">extends</span> <span class="title">Ducker</span></span>&#123;</span><br><span class="line">  RedheadDuck()&#123;</span><br><span class="line">    flyable = <span class="keyword">new</span> FlyNoWay();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以发现，使用组合来实现复用的。<br>组合是一个“has-a”的关系。<br>继承是一个“is-a”的关系。</p>
<blockquote>
<p>设计原则：多用组合，少用继承。</p>
</blockquote>
<blockquote>
<p>行为可以理解成不同的算法，把算法提取出来，与让对象自由的选择。这就是策略模式。</p>
</blockquote>
<blockquote>
<p>设计原则：面向接口编程</p>
</blockquote>
<p>设计模式是一种思想，让代码看起来更加清晰，维护起来更加容易。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>HeadFirst设计模式</tag>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title>UML类图和时序图</title>
    <url>/2018/12/19/Design%20Patterns/UML/</url>
    <content><![CDATA[<h1 id="UML类图和时序图"><a href="#UML类图和时序图" class="headerlink" title="UML类图和时序图"></a>UML类图和时序图</h1><h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p>表明类（对象）之前关系的一种方式。</p>
<ol>
<li>泛型关系：</li>
</ol>
<p>代码里就是继承关系。</p>
<p><img src="/2018/12/19/Design Patterns/UML/1.png" alt="泛型关系"></p>
<ol start="2">
<li>实现关系：</li>
</ol>
<p><img src="/2018/12/19/Design Patterns/UML/2.png" alt="继承关系"></p>
<ol start="3">
<li>依赖关系</li>
</ol>
<p>只要两个类之间有关系，就可以叫做有依赖关系</p>
<p><img src="/2018/12/19/Design Patterns/UML/5.png" alt="依赖关系"></p>
<p>依赖关系可以是成员变量，可以是参数。</p>
<p>作为参数存在的时候只有当方法被调用的时候才会用到另一个类。</p>
<ol start="4">
<li>关联关系</li>
</ol>
<p><img src="/2018/12/19/Design Patterns/UML/6.png" alt="关联关系"></p>
<p>强依赖关系，体现为成员变量。</p>
<p>关联关系根据两个对象的生命周期又可以分成聚合关系和组合关系。</p>
<ol start="5">
<li>聚合关系：</li>
</ol>
<p>B由A组成。<br>表示整体由部分构成的语义，与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；</p>
<p><img src="/2018/12/19/Design Patterns/UML/3.png" alt="聚合关系"></p>
<ol start="6">
<li>组合关系：</li>
</ol>
<p>同样表示整体由部分构成的语义，但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；</p>
<p><img src="/2018/12/19/Design Patterns/UML/4.png" alt="组合关系"></p>
<p><strong>如何理解聚合和组合的区别？</strong></p>
<p>生命周期:<br>聚合：A和B生命周期不同<br>组合：A和B生命周期相同。</p>
<p>生活案例：<br>聚合：雁群有雁子<br>组合：雁子有翅膀</p>
<p>代码区别：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//聚合:GooseGroup对象死亡了，其中的Goose还可以存在。</span></span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">GooseGroup</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">      <span class="keyword">public</span> Goose goose;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">GooseGroup</span><span class="params">(Goose goose)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.goose = goose;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//组合:GooseGroup对象死亡了，其中的Wings也死亡。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Goose</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Wings wings;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Goose</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        wings=<span class="keyword">new</span> Wings();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="时序"><a href="#时序" class="headerlink" title="时序"></a>时序</h2><p>[时序图]<a href="https://www.cnblogs.com/ywqu/archive/2009/12/22/1629426.html" target="_blank" rel="noopener">https://www.cnblogs.com/ywqu/archive/2009/12/22/1629426.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>lambda</title>
    <url>/2018/09/21/Java/lambda/</url>
    <content><![CDATA[<h1 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h1><h2 id="lambda的产生"><a href="#lambda的产生" class="headerlink" title="lambda的产生"></a>lambda的产生</h2><ul>
<li>不想在一个类中把一个方法写死，这样每次需求修改都要重写这个方法，因此使用接口的多态来实现。</li>
<li>根据需求我们需要去实现接口，但是这样需要定义很多只会在一个地方使用一次的类，因此使用匿名内部类。</li>
<li>当一个接口中只有一个抽象方法的时候（称为函数式接口），使用匿名内部类也会显得有些地方代码多余，因此使用lambda来优化。</li>
</ul>
<h2 id="lambda的使用注意"><a href="#lambda的使用注意" class="headerlink" title="lambda的使用注意"></a>lambda的使用注意</h2><ul>
<li>lambda所实现的接口我们称为目标类型，同一个Lambda表达式在不同的地方可能目标类型不一样，但是能够使用lambda的前提是编译器能用通过环境推断出目标类型。</li>
<li>函数式接口是相当简单的，因此我们没有必要去在我们的应用中去定义它，JDK8的util.function下专门定义了函数式接口来让我们使用，结合泛型来使用。</li>
<li>内部类中通过继承得到的成员（包括来自 Object 的方法）可能会把外部类的成员掩盖（shadow），此外未限定（unqualified）的 this 引用会指向内部类自己而非外部类。而lambda是词法作用域，和for，if等一样。</li>
</ul>
<h2 id="词法作用域-和-动态作用域"><a href="#词法作用域-和-动态作用域" class="headerlink" title="词法作用域 和 动态作用域"></a>词法作用域 和 动态作用域</h2><p>词法作用域是在写代码或者定义时确定的，而动态作用域是在运行时确定的（this也是！）。<br>词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。</p>
<h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><ul>
<li>在lambda中实现的方法的逻辑，已经由其他已经存在的方法实现，这时候只需要调用这个方法，并且直接返回结果。<br>这个过程可以有<strong>方法引用</strong>来简化。</li>
</ul>
<table>
<thead>
<tr>
<th>Kind</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>Reference to a static method</td>
<td>ContainingClass::staticMethodName</td>
</tr>
<tr>
<td>Reference to an instance method of a particular object</td>
<td>containingObject::instanceMethodName</td>
</tr>
<tr>
<td>Reference to an instance method of an arbitrary object of a particular type</td>
<td>ContainingType::methodName</td>
</tr>
<tr>
<td>Reference to a constructor</td>
<td>ClassName::new</td>
</tr>
</tbody>
</table>
<ul>
<li>方法引用相当于调用已有的方法作为该Lambda的实现，注意返回的依然是一个对象。</li>
<li>引用的方法存在重载的使用，将会通过函数式接口中的方法来判断具体调用哪一个。</li>
</ul>
<h1 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h1><ul>
<li>默认方法使我们可以给库里的接口添加新的方法而不会影响这个接口的老代码。</li>
<li>以往的解决方案是在实现类中写一个抽象方法，现在可以在接口中写一个默认方法。实现类可以选择实现与否。</li>
</ul>
<h1 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h1><ul>
<li>使用集合不仅仅是为了存储数据（读取元素数据），也是为了检索数据（对这些数据整体做操作）。</li>
<li>java8有一种更简洁的方式来检索集合，就是聚合操作。</li>
<li>聚合操作不能读取数据元素</li>
<li>聚合操作的中间操作时迟加载的，在终端执行时才会按顺序一起执行。</li>
<li>聚合操作中不要更改流的源的值，否则会发生线程干扰。</li>
</ul>
<h2 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h2><ul>
<li>stream是元素的序列，但是不是存储数据的，而是以管道的方式从源获取的值。不会改变源的值。</li>
</ul>
<h2 id="管道-pipeline"><a href="#管道-pipeline" class="headerlink" title="管道 pipeline"></a>管道 pipeline</h2><ul>
<li>管道是聚合操作的一个序列。</li>
</ul>
<ol>
<li>源：stream的来源，可以是集合，数组， a generator function, or an I/O channel。</li>
<li>中间操作：过滤stream数据，生成一个新的stream.</li>
<li>终端操作：返回基本数据类型,返回一个值得也叫reduction operations。</li>
</ol>
<h3 id="Stream-reduce"><a href="#Stream-reduce" class="headerlink" title="Stream.reduce"></a>Stream.reduce</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reduce(0,(a, b) -&gt; a + b);</span><br><span class="line">//需要两个参数，第二个参数是个lambda表达式</span><br><span class="line">//第一个参数是初始值以及无元素的返回值</span><br><span class="line">//第二个参数a是当前结果，b是下一个元素值</span><br><span class="line">//返回一个新的当前结果</span><br></pre></td></tr></table></figure>
<h3 id="Stream-collect"><a href="#Stream-collect" class="headerlink" title="Stream.collect"></a>Stream.collect</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">collect(supplier, accumulator, combiner);</span><br><span class="line">//需要3个参数，第一个参数是一个lambda表达式</span><br><span class="line">//第一个参数提供结果容器</span><br><span class="line">//第二个参数是一个“函数”，“函数”的参数是每一个元素值</span><br><span class="line">//第三个参数也是一个“函数”，“函数”的参数是另一个结果容器，作为平行操作时把子结果合在一起的逻辑。</span><br><span class="line"></span><br><span class="line">collect(Collectors)</span><br><span class="line">//这个类封装在collect操作中用作参数的函数，该函数需要三个参数（supplier，accumulator和combiner函数）。</span><br><span class="line">//Collectors中海油很多特别的操作</span><br></pre></td></tr></table></figure>
<h2 id="迟加载的好处"><a href="#迟加载的好处" class="headerlink" title="迟加载的好处"></a>迟加载的好处</h2><ul>
<li>java编译和运行时优化，将管道中的操作一起操作，这样就只需要遍历一次，而不是每个聚合操作都遍历一次。</li>
<li>对于无限数据源，我们可以满足某个条件就停止。</li>
</ul>
<h2 id="聚合操作和迭代器的区别"><a href="#聚合操作和迭代器的区别" class="headerlink" title="聚合操作和迭代器的区别"></a>聚合操作和迭代器的区别</h2><ul>
<li>迭代是外部迭代，外部迭代需要指定迭代的对象和迭代的方式(next)。只能按顺序迭代，否则有数据问题。</li>
<li>聚合操作是内部操作，只需要指定迭代的对象。可以平行操作（parallelStream）。</li>
</ul>
<h3 id="线程平行执行"><a href="#线程平行执行" class="headerlink" title="线程平行执行"></a>线程平行执行</h3><p>使用Iterators迭代集合，会有县城干扰和数据不一致问题。</p>
<ul>
<li>线程干扰：多线程同时执行一个对象中的非原子操作，会出现数据最终一致性错误的问题。比如一个+1，一个-1，最终结果是-1.</li>
<li>解决一致性问题：设置变量可见性：单线程，同步块，volatile，thread.start规则，thread.join方式</li>
</ul>
<p>虽然集合提供synchronization wrappers来解决线程安全问题，但是这样会产生线程争夺，线程争夺必然不能平行执行。<br> <strong>聚合操作和并行流使您可以实现与非线程安全集合的并行性，前提是您在操作集合时不要修改集合。</strong></p>
<p>更多线程平行的学习：<a href="https://docs.oracle.com/javase/tutorial/collections/streams/parallelism.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/collections/streams/parallelism.html</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[java lambda文档] <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#syntax" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#syntax</a></p>
<p>[Shadowing] <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#shadowing" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#shadowing</a></p>
<p>[聚合操作] <a href="https://docs.oracle.com/javase/tutorial/collections/streams/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/collections/streams/index.html</a></p>
<p>[java8 新特性]<a href="https://blog.csdn.net/Hatsune_Miku_/article/details/73556641.html" target="_blank" rel="noopener">https://blog.csdn.net/Hatsune_Miku_/article/details/73556641.html</a></p>
<p>并行操作：<a href="https://docs.oracle.com/javase/tutorial/collections/streams/parallelism.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/collections/streams/parallelism.html</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>01Maven简介与安装</title>
    <url>/2019/12/24/Maven/01Maven%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="Maven简介与安装"><a href="#Maven简介与安装" class="headerlink" title="Maven简介与安装"></a>Maven简介与安装</h1><h2 id="何为Maven"><a href="#何为Maven" class="headerlink" title="何为Maven"></a>何为Maven</h2><p><strong>什么是maven？</strong></p>
<p>Maven主要服务于基于Java平台的项目构建、依赖管理和项目信息管理。</p>
<p><strong>使用Maven的好处？</strong></p>
<ol>
<li>项目构建：自动化构建过程，从清理、编译、测试到生成报告，再到打包和部署。Maven抽象了一个完整的构建生命周期模型；标准化构建过程。</li>
<li>依赖管理：通过坐标系统准确地定位每一个构件（artifact），也就是通过一组坐标Maven能够找到任何一个Java类库（如jar文件）。</li>
<li>项目信息管理：管理项目描述、开发者列表、版本控制系统地址、许可证、缺陷管理系统地址等。除了直接的项目信息，通过Maven自动生成的站点，以及一些已有的插件，还可以轻松地获得项目文档、测试报告、静态分析报告、源码版本日志报告等非常具有价值的项目信息。</li>
<li>为全世界的Java开发者提供了一个免费的中央仓库，在其中几乎可以找到任何的流行开源类库。</li>
<li>对于项目目录结构、测试用例命名方式等内容都有既定的规则，只要遵循了这些成熟的规则，用户在项目间切换的时候就免去了额外的学习成本，可以说是约定优于配置。</li>
</ol>
<h2 id="为什么选择Maven"><a href="#为什么选择Maven" class="headerlink" title="为什么选择Maven"></a>为什么选择Maven</h2><p><strong>什么是Make？和Make的对比？</strong></p>
<p>Make也许是最早的构建工具，具体不详,没用过,可以不了解.Make的强大之处在于它可以利用所有系统的本地命令，尤其是UNIX/Linux系统，丰富的功能、强大的命令能够帮助Make快速高效地完成任务。</p>
<p>对比：</p>
<ol>
<li>使用Make，就不能实现（至少很难）跨平台的构建，这对于Java来说是非常不友好的</li>
<li>Makefile的语法也成问题，很多人抱怨Make构建失败的原因往往是一个难以发现的空格或Tab使用错误。</li>
</ol>
<p><strong>什么是Ant？和Ant的对比？</strong></p>
<p>可以将Ant看成是一个Java版本的Make，也正因为使用了Java，Ant是跨平台的。此外，Ant使用XML定义构建脚本，相对于Makefile来说，这也更加友好。</p>
<p>对比：</p>
<ol>
<li>和Make一样，Ant也都是过程式的，开发者显式地指定每一个目标，以及完成该目标所需要执行的任务。针对每一个项目，开发者都需要重新编写这一过程，这里其实隐含着很大的重复。Maven是声明式的，项目构建过程和过程各个阶段所需的工作都由插件实现，并且大部分插件都是现成的，开发者只需要声明项目的基本元素，Maven就执行内置的、完整的构建过程。这在很大程度上消除了重复。</li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><strong>目录结构和内容？</strong></p>
<ul>
<li>Bin：该目录包含了mvn运行的脚本，这些脚本用来配置Java命令，准备好classpath和相关的Java系统属性，然后执行Java命令。</li>
<li>Boot：maven默认的类加载器，相对于默认的java类加载器，它提供了更丰富的语法以方便配置。</li>
<li>Conf：该目录包含了一个非常重要的文件settings.xml。直接修改该文件，就能在机器上全局地定制Maven的行为。</li>
<li>Lib：该目录包含了所有Maven运行时需要的Java类库</li>
</ul>
<p><strong>什么情况下需要设置代理？</strong></p>
<ol>
<li>提高访问速度：通常代理服务器都设置一个较大的缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时，则直接由缓冲区中取出信息，传给用户，以提高访问速度。</li>
<li>隐藏真实身份：上网者也可以通过代理服务器隐藏自己的真实地址信息，还可隐藏自己的IP，防止被黑客攻击。</li>
<li>突破限制：有时候网络供应商会对上网用户的端口，目的网站，协议，游戏，即时通讯软件等的限制，使用代理服务器都可以突破这些限制。</li>
<li>安全认证</li>
</ol>
<p><strong>如何设置代理？</strong></p>
<p>在setting.xml中配置：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">proxy</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>optional<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">active</span>&gt;</span>true<span class="tag">&lt;/<span class="name">active</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">protocol</span>&gt;</span>http<span class="tag">&lt;/<span class="name">protocol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">username</span>&gt;</span>proxyuser<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">password</span>&gt;</span>proxypass<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">host</span>&gt;</span>proxy.host.net<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span>&gt;</span>80<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">nonProxyHosts</span>&gt;</span>local.net|some.host.com<span class="tag">&lt;/<span class="name">nonProxyHosts</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">proxy</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>mvn命令实际上是一个java进程，当项目较大时，如果运行内存不足，也会出现异常，<strong>怎么处理？</strong></p>
<p>使用Mvn命令时设置MAVEN_OPTS环境</p>
<p><strong>配置用户所属的setting.xml文件的好处？</strong></p>
<ol>
<li>避免影响其他用户</li>
<li>conf下的setting.xml每次更新就会重置</li>
</ol>
<p><strong>使用IDE自带的Maven会有什么问题？</strong></p>
<ol>
<li>自带的通常比较新，不一定很稳定</li>
<li>ide中的Maven和命令行的Maven版本如果不一定，可能会出现构建问题</li>
</ol>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven实战</tag>
      </tags>
  </entry>
  <entry>
    <title>03坐标和依赖</title>
    <url>/2020/01/13/Maven/03%E5%9D%90%E6%A0%87%E5%92%8C%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[<h1 id="坐标和依赖"><a href="#坐标和依赖" class="headerlink" title="坐标和依赖"></a>坐标和依赖</h1><h2 id="何为Maven坐标"><a href="#何为Maven坐标" class="headerlink" title="何为Maven坐标"></a>何为Maven坐标</h2><p>世界上任何一个构件都可以使用maven坐标唯一标识，maven坐标的元素包括groupId，artifactId，version，packaging，classifier。现在，只要我们提供正确的坐标元素，maven就能找到对应的构件。</p>
<h2 id="坐标详解"><a href="#坐标详解" class="headerlink" title="坐标详解"></a>坐标详解</h2><ul>
<li>groupId：定义当前这个maven项目录属的实际项目，表示方式通常与域名反向相对应。</li>
<li>artifactId：定义实际项目中的一个maven项目，推荐做法使用实际项目名称作为artifactId的前缀。maven生成的构件，其文件名会以artifactId作为开头。</li>
<li>version：定义maven项目当前所处的版本。</li>
<li>packaging：定义maven项目的打包方式，如果不定义packaging，默认使用jar。</li>
<li>classifier：帮助定义构建输出的一些附属构件。不能直接定义classifier。</li>
</ul>
<p><strong>实际项目和Maven项目是什么关系？</strong></p>
<p>一个公司（组织）下可以由很多个实际项目，而一个实际项目可以分成多个模块，因此artifactId用来定义一个maven项目，也就是一个模块</p>
<h2 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h2><p>程序编译，测试，运行阶段所需要的依赖是有区别的，比如测试所需要的依赖在运行时就不需要，那么这部分空间就可以被节约，Maven针对程序编译，测试，运行阶段所需要的依赖不同而自动引入到不同的classpath（classpath是应用加载器的扫描路径，也就是类加载的路径范围）</p>
<p>设置依赖范围的元素是<scope></scope></p>
<ul>
<li>compile：编译依赖范围，使用此依赖范围对于编译、测试、运行三种classpath都有效，即在编译、测试和运行时都要使用该依赖jar包；</li>
<li>test：测试依赖范围，只对测试有效，表明只在测试的时候需要，在编译和运行时将无法使用该类依赖，如 junit；</li>
<li>provided：所在的容器运行后已提供的依赖范围。编译和测试有效，运行无效。如servlet-api，在项目运行时，tomcat等容器已经提供，无需Maven重复引入；</li>
<li>runtime：运行时依赖范围。测试和运行有效，编译无效。如 jdbc 驱动实现，编译时只需接口，测试或运行时才需要具体的 jdbc 驱动实现；</li>
<li>system：系统依赖范围，使用system范围的依赖时必须通过sys03坐标和依赖ath元素显示地指定依赖文件的路径，不依赖Maven仓库解析，所以可能会造成建构的不可移植，谨慎使用</li>
</ul>
<p><img src="/2020/01/13/Maven/03坐标和依赖/01.png" alt="依赖范围"></p>
<h2 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h2><p>依赖传递的提出为了解决问题：如果A依赖B，而B依赖C，C需要在A中声明吗？<br>答案是：C会作为A的<code>传递性依赖</code>自动引入</p>
<p><strong>依赖的范围如何传递？</strong></p>
<p><img src="/2020/01/13/Maven/03坐标和依赖/02.png" alt="依赖范围传递"></p>
<h2 id="依赖调解"><a href="#依赖调解" class="headerlink" title="依赖调解"></a>依赖调解</h2><p>依赖调解的提出为了解决问题：</p>
<ol>
<li>A-&gt;B-&gt;C-&gt;X(1.0)、A-&gt;D-&gt;X(2.0)，那个X会被使用？第一原则：路径最近优先</li>
<li>A-&gt;B-&gt;Y(1.0)、A-&gt;C-&gt;Y(2.0)，那个Y会被使用？第二原则：先声明优先</li>
</ol>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven实战</tag>
      </tags>
  </entry>
  <entry>
    <title>02使用入门</title>
    <url>/2020/01/08/Maven/02%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="使用入门"><a href="#使用入门" class="headerlink" title="使用入门"></a>使用入门</h1><h2 id="编写POM"><a href="#编写POM" class="headerlink" title="编写POM"></a>编写POM</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.company.project<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello-world<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hello maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>第一行：是XML头，指定了该文档的版本和编码方式</li>
<li>project：是所有pom.xml的根元素，它还声明了一些POM相关的命名空间及xsd元素，虽然这些元素不是必须的，但是使用它们可以让第三方工具帮助我们快速编辑POM文件。</li>
<li>modelVersion：指定了当前POM模型的版本，对于Maven2及Maven3来说，它只能是4.0.0。</li>
<li>groupId：定义了项目属于哪个组，这个组往往和项目所在的组织或公司存在关联。比如在googlecode上建立了一个名为myapp的项目，那么groupId就应该是com.googlecode</li>
<li>artifactId：定义了而当前Maven项目在组中的唯一ID</li>
<li>version：指定了项目Hello-World的当前版本——1.0-SNAPSHOT。SNAPSHOT意为快照，表示该项目还处于开发中，是不稳定的版本。</li>
<li>name：声明了一个对于用户友好的项目名称，这个元素并不是必须的，但是推荐设立，以方便信息交流。</li>
</ul>
<p>mvn clean compile：清理target、编译</p>
<h2 id="编写测试代码"><a href="#编写测试代码" class="headerlink" title="编写测试代码"></a>编写测试代码</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>dependencies：声明项目依赖，会自动从仓库中去下载对应的jar包</li>
</ul>
<p>mvn clean test：清理target、测试</p>
<h2 id="打包和运行"><a href="#打包和运行" class="headerlink" title="打包和运行"></a>打包和运行</h2><p>mvn clean package：打包<br>mvn clean install：安装项目到本地仓库</p>
<p>默认打包的jar是不能直接运行的，因为带有main方法的类信息不会添加到MANIFEST.MF文件中，为了生成可执行的Jar，需要借助maven-shade-plugin</p>
<h2 id="使用Archetype生成项目骨架"><a href="#使用Archetype生成项目骨架" class="headerlink" title="使用Archetype生成项目骨架"></a>使用Archetype生成项目骨架</h2><p> mvn archetype:generate -DarchetypeCatalog=internal</p>
<blockquote>
<p>-DarchetypeCatalog=internal 设置maven不要从远程服务器上获取catalog</p>
</blockquote>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven实战</tag>
      </tags>
  </entry>
  <entry>
    <title>06聚合和继承</title>
    <url>/2020/01/14/Maven/06%E8%81%9A%E5%90%88%E5%92%8C%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1 id="聚合和继承"><a href="#聚合和继承" class="headerlink" title="聚合和继承"></a>聚合和继承</h1><p><strong>聚合解决什么问题？</strong></p>
<p>当一个项目分成多个模块开发，如何一次执行整个项目，而不是分别执行每个模块</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>my.maven.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mytest-project0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>mytest-project0 Maven Webapp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">module</span>&gt;</span>mytest-project1<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">module</span>&gt;</span>mytest-project2<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li>该aggregator本身也做为一个Maven项目，它必须有自己的POM</li>
<li>它的打包方式必须为：pom</li>
<li>版本：聚合模块的版本和被聚合模块版本一致</li>
<li>relative path：每个module的值都是一个当前POM的相对目录</li>
<li>目录名称：为了方便的快速定位内容，模块所处的目录应当与其artifactId一致(Maven约定而不是硬性要求)，总之，模块所处的目录必须和<module>模块所处的目录</module>相一致。</li>
<li>习惯约定：为了方便构建，通常将聚合模块放在项目目录层的最顶层，其它聚合模块作为子目录存在。这样当我们打开项目的时候，第一个看到的就是聚合模块的POM</li>
<li>聚合模块减少的内容：聚合模块的内容仅仅是一个pom.xml文件，它不包含src/main/java、src/test/java等目录，因为它只是用来帮助其它模块构建的工具，本身并没有实质的内容。</li>
<li>聚合模块和子模块的目录：他们可以是父子类，也可以是平行结构，当然如果使用平行结构，那么聚合模块的POM也需要做出相应的更改。</li>
</ol>
<p><strong>继承解决什么问题？</strong></p>
<p>当多个模板的POM有相同的配置，可以抽离出重复的配置，减少重复。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mytest-project1<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>my.maven.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mytest-project0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可被继承的有：</p>
<ol>
<li>groupId:项目组ID,项目坐标的核心元素</li>
<li>version: 项目版本, 项目坐标的核心元素</li>
<li>description: 项目的描述信息</li>
<li>organization: 项目的组织信息</li>
<li>inceptionYear: 项目的创始年份</li>
<li>url: 项目的URL地址</li>
<li>developers: 项目开发者信息</li>
<li>contributors: 项目的贡献者信息</li>
<li>distributionManagement: 项目的部署配置</li>
<li>issueManagement: 项目的缺陷跟踪系统信息</li>
<li>ciManagement: 项目的持续集成系统信息</li>
<li>scm: 项目的版本控制系统信息</li>
<li>mailingLists: 项目的邮件列表信息</li>
<li>properties: 自定义的maven属性</li>
<li>dependencies: 项目的依赖配置</li>
<li>dependencyManagement: 项目的依赖管理配置</li>
<li>repositories: 项目的仓库配置</li>
<li>build: 包括项目的源码目录配置、输出目录配置、插件配置、插件管理配置等</li>
<li>reporting: 包括项目的报告输出目录配置、报告插件配置等</li>
</ol>
<h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>dependencies是可以被继承的，这个时候我们就想到让我们的发生了共用的依赖元素转移到parent中，这样我们又进一步的优化了配置。可是问题也随之而来，如果有一天我创建了一个新的模块，但是这个模块不需要这些parent的依赖，<strong>这时候如何处理？</strong></p>
<p>dependencyManagement元素可以解决这个问题：在dependencyManagement中配置的元素既不会给parent引入依赖，也不会给它的子模块引入依赖，仅仅是它的配置是可继承的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父pom --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">target.version</span>&gt;</span>2.5.6<span class="tag">&lt;/<span class="name">target.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>your groupId<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>your artifactId<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;target.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 子pom --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>your groupId<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>your artifactId<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样做似乎还是有重复的配置，但是可以有效的避免多个子模块使用依赖版本不一致的情况，有助于降低依赖冲突的几率。<br>插件的管理同样有pluginManagement元素</p>
<blockquote>
<p>聚合POM和父POM没有要求是同一个POM，但是一般采用同一个</p>
</blockquote>
<h2 id="约定大于配置"><a href="#约定大于配置" class="headerlink" title="约定大于配置"></a>约定大于配置</h2><p><strong>在Maven中，约定大于配置：</strong></p>
<ol>
<li>默认源码目录为src/main/java</li>
<li>默认的源资源目录src/main/resource</li>
<li>默认测试源码目录为src/test/java</li>
<li>默认的测试资源目录src/test/resource</li>
<li>默认编译输出为target/classes/</li>
<li>默认打包方式为jar</li>
<li>默认包输出目录为target/</li>
</ol>
<p><strong>如果想要自定义源码目录：</strong><br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--修改源代码目录 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/src/main/java<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/target/classes/<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span> <span class="comment">&lt;!-- $&#123;project.build.directory&#125;就是我们通常看到的target目录 --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--修改测试源代码目录 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">testSourceDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/src/test/java <span class="tag">&lt;/<span class="name">testSourceDirectory</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">testOutputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/target/test-classes<span class="tag">&lt;/<span class="name">testOutputDirectory</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--修改资源目录 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.build.directory&#125;/src/main/resource<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/*.java<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--修改测试资源目录 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">testResource</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.build.directory&#125;/src/test/resource<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/*.java<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">testResources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>默认的包结构定义在超级POM中</p>
</blockquote>
<h2 id="反应堆"><a href="#反应堆" class="headerlink" title="反应堆"></a>反应堆</h2><p>在多模块的Maven项目中，反应堆指所有模块组成的一个构建结构，包含了各模块之间的继承与依赖关系，从而能够自动计算出合理的模块构建顺序。</p>
<p>反应堆的建构顺序规则：<br>Maven按序杜旭POM，如果该POM没有依赖模块，那么构建该模块，否则就先构建其依赖模块，如果该依赖还依赖于其他模块，则进一步先构建依赖的依赖。<br>依赖关系会将反应堆构成一个有向非循环图，或出现循环，会报错。</p>
<p>反应堆裁剪（部分模块构建）：</p>
<ul>
<li>-pl：构建指定模块，逗号分隔</li>
<li>-rf：构建反应堆顺序中指定模块之后的所有模块</li>
<li>-am：同时构建所列模块以及其依赖的模块</li>
<li>-amd：同时构建所列模块以及依赖其的模块</li>
</ul>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven实战</tag>
      </tags>
  </entry>
  <entry>
    <title>04仓库</title>
    <url>/2020/01/13/Maven/04%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<h1 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h1><p>任何一个依赖、插件或者项目构建的输出都可以称为构件，任何一个构件都有唯一的坐标标识</p>
<h2 id="仓库的布局"><a href="#仓库的布局" class="headerlink" title="仓库的布局"></a>仓库的布局</h2><p>每个坐标对应唯一的存储路径</p>
<p>如：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.company.project<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello-world<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hello maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>存储路径为：com/company/project/hello-world/0.0.1-SNAPSHOT/hello-world-0.0.1-SNAPSHOT.extension</p>
<h2 id="仓库的分类"><a href="#仓库的分类" class="headerlink" title="仓库的分类"></a>仓库的分类</h2><ul>
<li>本地仓库：用来存储从远程仓库下载的插件和jar包，当项目需要使用，插件或jar包时，优先从本地仓库查找</li>
<li>远程仓库：当项目需要使用插件或jar包时，本地仓库没有，则默认去远程仓库下载</li>
</ul>
<p><img src="/2020/01/13/Maven/04仓库/01.png" alt="仓库的分类"></p>
<p>本地仓库路径：<br>默认：.m2/repository<br>可修改setting.xml文件中的：</p>
<localrepository>D:\Java\Maven\repository</localrepository>

<p>本地仓库只有一个，远程仓库可以由多个（至少一个）</p>
<p>远程仓库又可以根据用途分为：</p>
<ul>
<li>中央仓库：Maven 工具内置了一个中央仓库地址，服务于整个互联网，由 Maven 团队自己维护，存储了几乎所有开源的 jar 包（中央仓库是远程仓库的默认仓库）</li>
<li>私服：私服是一种特殊的远程仓库，它是架设在局域网内的一台服务器，提供仓库服务，用来代理所有外部的远程仓库</li>
<li>镜像仓库：镜像仓库就是其它的公共仓库</li>
</ul>
<p><strong>私服有什么作用？</strong></p>
<ol>
<li>节省外网宽带：大量对于外网仓库的重复请求会消耗很大的带宽</li>
<li>加速Maven构建：maven一些内部机制（如快照更新检查）要求Maven在构建时不停的检查远程仓库数据，这会大大的降低构建的速度，使用私服可以很好的解决这个问题。</li>
<li>部署三方构件：一般可能是公司私有的构件，不希望公开</li>
<li>提高稳定性，增强控制：当外网不稳定时，私服作为局域网，也可正常构建。另外，一些私服软件（如Nexus）还提供了很多额外的功能：如权限控制，RELEASE/SNAPSHOT区分。</li>
<li>降低中央仓库的负荷</li>
</ol>
<p><img src="/2020/01/13/Maven/04仓库/02.png" alt="私服"></p>
<h2 id="远程仓库的配置"><a href="#远程仓库的配置" class="headerlink" title="远程仓库的配置"></a>远程仓库的配置</h2><p>默认的中央仓库配置在超级POM包中:<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Central Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo.maven.apache.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>在pom.xml中配置远程仓库：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">repository</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-net-cn<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven China Mirror<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.net.cn/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">releases</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">repository</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>大部分的远程仓库无需认证即可访问，但有时处于安全考虑，需要认证才可访问，大部分私服都是如此</p>
<p>认证信息只能配置在setting.xml文件中：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>deploymentRepo<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">username</span>&gt;</span>repouser<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">password</span>&gt;</span>repopwd<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="部署到远程仓库"><a href="#部署到远程仓库" class="headerlink" title="部署到远程仓库"></a>部署到远程仓库</h2><p>配置部署地址：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>public<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://59.50.95.66:8081/nexus/content/repositories/releases<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>Snapshots<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://59.50.95.66:8081/nexus/content/repositories/snapshots<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="快照版本"><a href="#快照版本" class="headerlink" title="快照版本"></a>快照版本</h2><p><strong>为什么要区分发布版和快照版？</strong></p>
<p>当项目A和B同时开发，而B依赖A时，B如何做到及时更新A的最新版本？<br>方案1：B的开发者每次自己去构建A的最新版本，并引入依赖<br>方案2：A的开发者重新部署，B的开发者删除本地依赖后重新引入构件<br>方案3：每次都更新一个新的版本<br>很显然上面3个方案都很繁琐</p>
<p>因此引入快照版本：xxx-SNAPSHOT表示快照，A构建时Maven会将当前替换为当前的时间戳，再进行部署。之后B每次构建时Maven会自动去检查更新（默认每天一次），并进行替换。</p>
<blockquote>
<p>快照版本只应该在组织内部使用，使用外部的快照版本会很危险。</p>
</blockquote>
<p>除了快照版本，还有：</p>
<ul>
<li>RELEASE：表示最新发布版本</li>
</ul>
<p>“最新”是基于gruopId/artifactId/maven-metadata.xml检查更新的<br>“快照”是基于gruopId/artifactId/version/maven-metadata.xml检查更新的</p>
<h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>如果仓库X可以提供仓库Y存储的所有内容，那么认为X是Y的一个镜像。</p>
<p>镜像的配置：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>阿里云公共仓库<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>mirrorOf：任何对于中央仓库的请求都会转至该镜像</li>
</ul>
<h2 id="仓库搜索服务"><a href="#仓库搜索服务" class="headerlink" title="仓库搜索服务"></a>仓库搜索服务</h2><p><strong>如何根据项目的名称去搜索响应的Maven坐标？</strong></p>
<ol>
<li>Sonatype Nexus：Nexus提供了关键字搜索，类名搜索，左边搜索，校验和搜索等功能。</li>
<li>Jarvana：Jarvana还提供了便捷的Java文档浏览的功能。</li>
<li>MVNbrowser：只提供关键字搜索的功能。能够告诉用户该构件的依赖于其他那些构件（Dependencies）以及该构件给哪些其他构件依赖（Referenced By）</li>
</ol>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven实战</tag>
      </tags>
  </entry>
  <entry>
    <title>05生命周期和插件</title>
    <url>/2020/01/14/Maven/05%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="生命周期和插件"><a href="#生命周期和插件" class="headerlink" title="生命周期和插件"></a>生命周期和插件</h1><p><strong>什么是生命周期？</strong></p>
<p>Maven 构建生命周期就是 Maven 将一个整体任务划分为一个个的阶段，类似于流程图，按顺序依次执行。也可以指定该任务执行到中间的某个阶段结束。<br>Maven 的内部有三个构建生命周期，分别是 clean, default, site。</p>
<p>周期之间互相独立，周期内的阶段有前置依赖。</p>
<p><strong>如何使用构建生命周期来完成构建工作？</strong></p>
<p>使用mvn命令，如执行mvn install命令，将完成validate, compile, test, package, verify, install阶段<br>也可以指定多个阶段，如执行mvn clean deploy命令，首先完成的clean lifecycle，将以前构建的文件清理，然后再执行default lifecycle的validate, compile, test, package, verify, insstall, deploy 阶段，将package阶段创建的包发布到远程仓库中。</p>
<p><strong>什么是插件？</strong></p>
<p>生命周期只是抽象的概念，具体Maven对工程的所有操作实实在在的都是由插件来完成的。一个插件可以支持多种功能，称之为目标（goal），例如：compiler插件有两个目标：compile和testCompile，分别实现编译源代码和编译测试代码。</p>
<p><strong>生命周期和插件的关系？</strong></p>
<p>一个插件可能有一个或多个插件目标。生命周期的某个阶段可以绑定一个或多个插件目标；一个插件目标也可以绑定到一个或多个生命周期阶段。他们是多对多的关系。</p>
<p><strong>如何绑定生命周期和插件？</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.modello<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>modello-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">phase</span>&gt;</span>generate-sources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>java<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>phase：阶段</li>
<li>goal：插件目标</li>
</ul>
<h2 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h2><p>配置插件目标的参数：</p>
<ul>
<li>命令行插件配置：mvn install -Dmaven.test.skip=true</li>
<li><p>POM中插件全局配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-war-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 利用属性传递版本号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;plugin.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置编码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置名称 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">warName</span>&gt;</span>ROOT<span class="tag">&lt;/<span class="name">warName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>POM中插件目标配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 依赖插件 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>copy-dependencies<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">phase</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>copy-dependencies<span class="tag">&lt;/<span class="name">goal</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">                <span class="comment">&lt;!-- $&#123;project.build.directory&#125;为Maven内置变量，缺省为target --&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/lib<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span>  </span><br><span class="line">                <span class="comment">&lt;!-- 表示是否不包含间接依赖的包 --&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">excludeTransitive</span>&gt;</span>false<span class="tag">&lt;/<span class="name">excludeTransitive</span>&gt;</span>  </span><br><span class="line">                <span class="comment">&lt;!-- 表示复制的jar文件去掉版本信息 --&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">stripVersion</span>&gt;</span>true<span class="tag">&lt;/<span class="name">stripVersion</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="获取插件信息"><a href="#获取插件信息" class="headerlink" title="获取插件信息"></a>获取插件信息</h2><ol>
<li>在线查找插件：<br>目前，插件基本上都来源于两处，一个是 Apache；另一个是 Codehaus。因为 Maven 本身就来自 Apache 软件基金会，所有在 Apache 上有很多 Maven 的官方插件，而且每天有很多人在使用这些插件，这些插件都经过了很多项目的实际考验，所以它们比较可靠。</li>
<li>使用 maven-help-plugin 查看插件：<br>mvn help:describe -Dplugin=org.apache.maven.plugins:maven-site-plugin:3.4 -Ddetail<br>mvn help:describe -Dplugin=site -Dgoal=site -Ddetail</li>
</ol>
<h2 id="从命令行调用插件"><a href="#从命令行调用插件" class="headerlink" title="从命令行调用插件"></a>从命令行调用插件</h2><p>mvn命令后面除了可以接多个phase外，也可以接多个goal<br>如：mvn dependency:tree 表示 执行dependency插件的tree目标</p>
<p>上述dependency并不是一个完整的插件坐标，<strong>那么如何找到对应的目标？</strong></p>
<p>插件查库和依赖仓库是区分开的，Maven内置的额插件仓库配置：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Central Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo.maven.apache.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>never<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果不指定groupId，那么默认是org.apache.maven.plugins<br>如果不指定version，那么默认是最新版本（包含快照）</p>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven实战</tag>
      </tags>
  </entry>
  <entry>
    <title>07仓库+测试+版本管理</title>
    <url>/2020/01/15/Maven/07%E4%BB%93%E5%BA%93+%E6%B5%8B%E8%AF%95+%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="使用Nexus创建私服"><a href="#使用Nexus创建私服" class="headerlink" title="使用Nexus创建私服"></a>使用Nexus创建私服</h1><h2 id="仓库和仓库组"><a href="#仓库和仓库组" class="headerlink" title="仓库和仓库组"></a>仓库和仓库组</h2><p>nexus仓库分类：</p>
<ol>
<li>group（仓库组）：将多个宿主仓库聚合到同一个group中，使用中统一指定聚合仓库的仓库地址可以获取到同一group下的所有包，免去多仓库多地址的配置繁琐。聚合仓库的聚合成员可以在仓库设置中添加和移除。</li>
<li>hosted（宿主仓库）：常用仓库</li>
<li>proxy（代理仓库）：当用户向 proxy 类型仓库请求下载一个依赖构件时，就会先在自己的库里查找，如果找不到的话，就会从设置的远程仓库下载并缓存</li>
<li>virtual（虚拟仓库）：</li>
</ol>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>本章内容概览:</p>
<ol>
<li>测试插件介绍（surefire）</li>
<li>如何跳过测试？</li>
<li>如何指定要运行的测试用例？</li>
<li>如何包含和排序测试用例？</li>
<li>如何生成测试报告？</li>
</ol>
<h1 id="web页面测试"><a href="#web页面测试" class="headerlink" title="web页面测试"></a>web页面测试</h1><p>本章内容概览:</p>
<ol>
<li><p>web项目目录结构以及war文件目录结构：<br><img src="/2020/01/15/Maven/07仓库+测试+版本管理/01.png" alt="war文件目录结构"></p>
<p><img src="/2020/01/15/Maven/07仓库+测试+版本管理/02.png" alt="web项目目录结构"></p>
</li>
<li>web页面测试插件介绍（jetty-maven-plugin）</li>
<li><p>为了在命令行直接运行 mvn jetty:run，需要配置setting.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginGroup</span>&gt;</span>org.mortbay.jetty<span class="tag">&lt;/<span class="name">pluginGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改默认端口 mvn jetty:run -Djetty.port = 9999</p>
</li>
<li>使用Cargo实现自动部署</li>
</ol>
<h1 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h1><p>本章内容概览:</p>
<ol>
<li>版本号约定：&lt;主版本&gt;.&lt;次版本&gt;.&lt;增量版本&gt;-&lt;里程碑版本&gt;<ul>
<li>主版本：表示项目的重大架构变更</li>
<li>此版本：表示较大范围的功能变更</li>
<li>增量版本：重大bug的修复</li>
<li>里程碑版本：与正式版本相比，往往表示不是非常稳定，还需要很多测试</li>
</ul>
</li>
<li>版本如何进行自动迭代？</li>
</ol>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven实战</tag>
      </tags>
  </entry>
  <entry>
    <title>08灵活的构建</title>
    <url>/2020/01/16/Maven/08%E7%81%B5%E6%B4%BB%E7%9A%84%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="灵活的构建"><a href="#灵活的构建" class="headerlink" title="灵活的构建"></a>灵活的构建</h1><p>如何在不同的环境下展现不同的构建特性？</p>
<h2 id="Maven属性"><a href="#Maven属性" class="headerlink" title="Maven属性"></a>Maven属性</h2><p>Maven中的属性有：</p>
<ol>
<li>内置属性：两个常用内置属性 ${basedir} 表示项目跟目录，即包含pom.xml文件的目录；${version} 表示项目版本</li>
<li>POM属性：用户可以使用该类属性引用POM文件中对应元素的值。如${project.artifactId}就对应了<project> <artifactid>元素的值，常用的POM属性包括：<ul>
<li>${project.build.sourceDirectory}:项目的主源码目录，默认为src/main/java/</li>
<li>${project.build.testSourceDirectory}:项目的测试源码目录，默认为src/test/java/</li>
<li>${project.build.directory} ： 项目构建输出目录，默认为target/</li>
<li>${project.outputDirectory} : 项目主代码编译输出目录，默认为target/classes/</li>
<li>${project.testOutputDirectory}：项目测试主代码输出目录，默认为target/testclasses/</li>
<li>${project.groupId}：项目的groupId</li>
<li>${project.artifactId}：项目的artifactId</li>
<li>${project.version}：项目的version,与${version} 等价</li>
<li>${project.build.finalName}：项目打包输出文件的名称，默认为${project.artifactId}-${project.version}</li>
</ul>
</artifactid></project></li>
<li>自定义属性：通过<properties>可以自定义一个或多个Maven属性，然后在POM的其他地方使用${properties}的方式引用该属性</properties></li>
<li>Settings属性：与POM属性同理，用户使用以settings. 开头的属性引用settings.xml文件中的XML元素的值。</li>
<li>Java系统属性：所有java系统属性都可以用Maven属性引用，如${user.home}指向了用户目录。</li>
<li>环境变量属性：所有环境变量属性都可以使用以env. 开头的Maven属性引用，如${env.JAVA_HOME}指代了JAVA_HOME环境变量的的值。</li>
</ol>
<h2 id="构建不同环境的配置"><a href="#构建不同环境的配置" class="headerlink" title="构建不同环境的配置"></a>构建不同环境的配置</h2><ol>
<li><p>开启资源过滤，让其他资源文件也可以解析Maven属性</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 替换配置文件中的数据项 start --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">testResource</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/test/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">testResources</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 替换配置文件中的数据项 end --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<profile>构建不同环境下的配置</profile></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>local<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">zoo.url</span>&gt;</span>172.17.103.107:2181<span class="tag">&lt;/<span class="name">zoo.url</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">log.level</span>&gt;</span>DEBUG<span class="tag">&lt;/<span class="name">log.level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">		    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>false<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">zoo.url</span>&gt;</span>172.17.103.108:2181<span class="tag">&lt;/<span class="name">zoo.url</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">log.level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">log.level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在资源文件中使用配置信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zoo.url=$&#123;zoo.url&#125;</span><br><span class="line">log.level=$&#123;log.level&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定环境进行构建：</p>
<ul>
<li>命令行：mvn clean install -Pdev</li>
<li>settings.xml文件：修改active-Profiles元素</li>
</ul>
</li>
<li><p>指定条件激活环境</p>
<ul>
<li><p>指定系统属性存在</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>profileProperty<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指定系统属性等于某值</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>profileProperty<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指定操作系统</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">os</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>Window XP<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">family</span>&gt;</span>Windows<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">arch</span>&gt;</span>x86<span class="tag">&lt;/<span class="name">arch</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.2600<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">os</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指定文件存在</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">missing</span>&gt;</span>t1.properties<span class="tag">&lt;/<span class="name">missing</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exists</span>&gt;</span>t2.properties<span class="tag">&lt;/<span class="name">exists</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置默认</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>profile的分类：</p>
<ol>
<li>pom.xml：pom.xml 中声明的 profile 只对当前项目有效。</li>
<li>用户 settings.xml：在用户目录下的“.m2/settings.xml”中的 profile，对本机上的该用户的所有 Maven 项目有效。</li>
<li>全局 settings.xml：在 Maven 安装目录下 conf/settings.xml 中配置的 profile，对本机上所有项目都有效。</li>
</ol>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven实战</tag>
      </tags>
  </entry>
  <entry>
    <title>09编写maven插件</title>
    <url>/2020/01/16/Maven/09%E7%BC%96%E5%86%99maven%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="编写maven插件"><a href="#编写maven插件" class="headerlink" title="编写maven插件"></a>编写maven插件</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li><p>使用archetype创建一个Maven插件项目</p>
<p>mvn archetype:generate -DarchetypeCatalog=internal</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sunyi1<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-loc-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>maven-plugin<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>maven-loc-plugin Maven Plugin<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- FIXME change it to the project's website --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-plugin-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意点：</p>
<ol>
<li>packaging必须为maven-plugin</li>
<li>依赖maven-plugin-api，开发插件需要包</li>
</ol>
</li>
<li><p>创建CountMojo类：继承AbstractMojo,实现execute()方法，提供@goal标注</p>
</li>
<li>使用@parameter设置可配置参数</li>
</ol>
<h2 id="标注"><a href="#标注" class="headerlink" title="标注"></a>标注</h2><ul>
<li>@goal <name>:唯一必须声明的标注，当用户命令行调用或在pom中配置插件是，需使用该目标名称</name></li>
<li>@phase <phase>:默认将该目标绑定至default声明周期的某个阶段，这样在配置使用插件目标时，就无需声明phase，如maven-surefire-plugin的test目标带有@phase tes标注</phase></li>
<li>@requiresDependencyResolution <scope>:在运行mojo之前必须解析所有指定范围的依赖，如maven-surefire-plugin的test目标带有requiresDependencyResolution test标注，表示执行测试前，所有测试范围的依赖必须得到解析</scope></li>
<li>@requiresProject &lt;true/false&gt;:该目标是否必须在一个maven项目中运行（如测试插件用于测试其他项目），默认为true。大部分插件目标需依赖一个项目才能运行，但是，maven-help-plugin的system目标例外，它用来显示系统属性和环境变量信息，无需实际项目。</li>
<li>@requiresOnline &lt;true/false&gt;:是否要求maven必须是在线状态，默认值为false</li>
<li>@requiresReport &lt;true/false&gt;:是否要求项目报告已经生成，默认为false</li>
<li>@aggregator ：当mojo在多模块项目上运行时，该标注表示目标只会在顶层模块运行。</li>
<li>@requiresDirectInvocation &lt;true/false&gt;:为true时，该目标就只能通过命令行直接调用。默认为false</li>
<li>@execute goal=”<goal>“:在运行该目标之前，让maven运行另外一个目标。如果是本插件目标，则直接调用目标名称，否则，使用“prefix:goal”</goal></li>
<li>@execute phase=”<phase>“:在运行该目标前，让maven先运行一个并行的生命周期，到指定的阶段为止。到phase执行完，才执行插件目标</phase></li>
<li>@execute lifecycle=”<lifecycle>“ phase = “<phase>“:在运行该目标前，让maven先运行一个自定义的生命周期，到指定的阶段为止。</phase></lifecycle></li>
</ul>
<h2 id="错误处理和日志"><a href="#错误处理和日志" class="headerlink" title="错误处理和日志"></a>错误处理和日志</h2><ol>
<li>提供MojoExecutionException 和 MojoFailureException 两类异常</li>
<li>提供getLog()方法，获得Log对象，支持四种级别的日志：debug，info，warn，requiresReport</li>
</ol>
<h2 id="插件测试"><a href="#插件测试" class="headerlink" title="插件测试"></a>插件测试</h2><p>使用maven-invoker-plugin进行测试</p>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven实战</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql并发</title>
    <url>/2019/10/28/MySQL/Mysql%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h1 id="Mysql并发"><a href="#Mysql并发" class="headerlink" title="Mysql并发"></a>Mysql并发</h1><p><strong>在事务并发的情形下会出现哪些？</strong></p>
<ol>
<li>丢失更新：更新操作并不是原子操作，在并发可能出现同时更新同一行，这时其中一个更新操作就会丢失。</li>
<li>脏读：其它事务修改了数据并回滚，导致读到错误数据。</li>
<li>不可重复读：其它事务修改了数据，导致前后读不一致。</li>
<li>幻读：不可重复读的特殊情况，其它事务插入或删除数据，导致前后读不一致。</li>
</ol>
<p><strong>如何解决这些问题？</strong></p>
<p>使用锁来处理并发问题，不同的加锁机制可以解决不同的问题。</p>
<p><strong>如何加锁（加锁时机，释放时机，读写锁）？</strong></p>
<p>根据加锁的机制可以归为三层封锁协议：</p>
<ol>
<li>第一级封锁协议：修改数据前加写锁，持续到事务结束。防止了丢失更新。</li>
<li>第二级封锁协议：修改数据前加写锁，持续到事务结束。读取数据前加读锁，读取数据后释放。防止了脏读。</li>
<li>第三级封锁协议：修改数据前加写锁，持续到事务结束。读取数据前加读锁，持续到事务结束。防止了不可重复读。</li>
</ol>
<p><strong>如何处理死锁的问题？</strong></p>
<p>三层封锁都会出现死锁问题<br>处理死锁的方案跟多，如按顺序加锁和释放，有需要再深究</p>
<p><strong>封锁协议和Mysql隔离级别的关系？</strong></p>
<p>大致对应关系：</p>
<ul>
<li>第一级封锁协议对应RU(READ UNCOMMITTED)</li>
<li>第二级封锁协议对应RC(READ COMMITTED)</li>
<li>第三级封锁协议对应PR(REPEATABLE READ)</li>
</ul>
<p><strong>第二级封锁协议和Mysql RC隔离级别的区别？</strong></p>
<p>第二级封锁协议中，获取读锁必须等待写锁释放，这会带来一定的性能阻塞。<br>Mysql使用MVCC（多版本并发控制）实现第二级封锁协议，可以做到不加锁读非阻塞读取数据</p>
<p><strong>MVCC实现简单原理？</strong></p>
<p>InnoDB为每个记录维护三个隐藏字段：</p>
<ul>
<li>ID：唯一编号</li>
<li>DB_TRX_ID：当前处理事务ID</li>
<li>DB_ROLL_PTR:回滚指针，指向历史记录中的ID</li>
</ul>
<p>InnoDB同时会维护两个隐藏表：</p>
<ul>
<li>redo_log：记录历史操作</li>
<li>undo_log：记录历史数据</li>
</ul>
<p><img src="/2019/10/28/MySQL/Mysql并发/01.png" alt="MVCC"></p>
<p>DML对应的操作结果：</p>
<ul>
<li>INSERT：新插入一行，保存当前事务编号作为行版本号</li>
<li>DELETE：加入undo_log中，并保存当前事务编号作为行版本号</li>
<li>UPDATE：INSERT后DELETE，并将回滚指针指向历史数据</li>
</ul>
<p>SELECT比较特殊，需要根据read view进行判断<br>read view是InnoDB维护的一个当前系统中的活跃事务列表，当前事务与正在内存中commit的事务不在活跃事务列表中<br>SELECT的判断如下：<br>某行的事务id为trx_id，read view中最早的事务id为trx_id_min, 最迟的事务id为trx_id_max</p>
<ul>
<li>trx_id&lt; trx_id_min，表明该行记录所在的事务已经在本次新事务创建之前就提交了，可见</li>
<li>trx_id&gt;trx_id_max，表明该行记录所在的事务在本次新事务创建之后才开启，不可见，之后索引DB_ROLL_PTR</li>
<li>trx_id_min &lt;= trx_id &lt;= trx_id_max，若read view包含trx_id，不可见，否则可见，之后索引DB_ROLL_PTR</li>
</ul>
<p><strong>MVCC SELECT的特殊性：</strong></p>
<p>MVCC中的SELECT只能读到当前事务可见的版本数据，所以是一种<code>快照读</code>，但是在UPDAET,DELETE,INSERT以及LOCK IN SHARE MODE 和 FOR UPDATE中，对数据存在性的判断读都是<code>当前读</code>，而且，快照读和当前读并不能解决幻读的问题</p>
<blockquote>
<p>MVCC对写是加锁的</p>
</blockquote>
<p><strong>MVCC在PR中和在RC中的区别？</strong></p>
<p>RC解决脏读，PR解决不可重复读，但是MVCC正好是在这两种级别下都工作的，关键在于生成read view的机制不同：</p>
<ul>
<li>在RC中，read view在每个操作前都会重新生成</li>
<li>在PR中，read view在事务开始时生成，并持续到事务结束</li>
</ul>
<p><strong>PR隔离防止幻读了吗？</strong></p>
<p>第三级封锁协议不能解决幻读，快照读和当前读也不能解决幻读的问题，但是奇怪的是Mysql的PR级别确实是防止幻读了，<strong>到底是怎么回事呢？</strong></p>
<p>原因是，Mysql会给范围读加<code>间隙锁</code>，使得期间无法删除或者插入数据，由此解决了幻读，<strong>但是我们不才说了SELECT是不加锁的么？</strong></p>
<p>这是因为，除了SELECT外，还有两个特殊的读LOCK IN SHARE MODE 和 FOR UPDATE，他们是以加锁的实现的</p>
<p><strong>LOCK IN SHARE MODE和FOR UPDATE的区别？</strong></p>
<p>LOCK IN SHARE MODE加读锁<br>FOR UPDATE加写锁</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>连表操作</title>
    <url>/2018/10/18/MySQL/Mysql%E8%BF%9E%E8%A1%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="连表操作"><a href="#连表操作" class="headerlink" title="连表操作"></a>连表操作</h1><p><img src="/2018/10/18/MySQL/Mysql连表操作/1.png" alt="关系表"></p>
<h2 id="inner-join："><a href="#inner-join：" class="headerlink" title="(inner) join："></a>(inner) join：</h2><p>Aa<br>Ac<br>Bd</p>
<h2 id="left-join"><a href="#left-join" class="headerlink" title="left join"></a>left join</h2><p>Aa<br>Ac<br>Bd<br>C_<br>D_</p>
<h2 id="right-join"><a href="#right-join" class="headerlink" title="right join"></a>right join</h2><p>Aa<br>Ac<br>Bd<br>_b</p>
<h2 id="full-join-mysql不支持"><a href="#full-join-mysql不支持" class="headerlink" title="full join(mysql不支持)"></a>full join(mysql不支持)</h2><p>Aa<br>Ac<br>Bd<br>C_<br>D_<br>_b</p>
<h2 id="cross-join"><a href="#cross-join" class="headerlink" title="cross join"></a>cross join</h2><p>Aa<br>Ab<br>Ac<br>Ad<br>Ba<br>Bb<br>Bc<br>Bd<br>Ca<br>Cb<br>Cc<br>Cd<br>Da<br>Db<br>Dc<br>Dd</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL命令执行过程和基本管理</title>
    <url>/2018/10/08/MySQL/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="MySQL命令执行过程"><a href="#MySQL命令执行过程" class="headerlink" title="MySQL命令执行过程"></a>MySQL命令执行过程</h1><p><strong>客户端如何连接MySQ L服务端？</strong></p>
<ol>
<li>TCP/IP：指定IP，端口号，用户名，密码进行连接。</li>
<li>命名管道和共享内存：WINDOWS客户端，服务端连接方式。</li>
<li>Unix套接字：类Unix客户端，服务端连接方式。</li>
</ol>
<p><strong>语句在服务端如何处理?</strong></p>
<p><img src="/2018/10/08/MySQL/命令执行过程和基本管理/1.png" alt="MySQL命令执行过程"></p>
<h1 id="MySQL的基本管理"><a href="#MySQL的基本管理" class="headerlink" title="MySQL的基本管理"></a>MySQL的基本管理</h1><p><strong>如何启动MySQL？</strong></p>
<h2 id="UNIX中"><a href="#UNIX中" class="headerlink" title="UNIX中"></a>UNIX中</h2><ul>
<li>mysqld:直接启动MySQL服务器程序</li>
<li>mysql_sage:同时启动另外一个监控进程，在MySQL服务器程序挂了的时候，可以帮助重启它。另外会将服务器程序的出错信息和其他诊断信息重定向到某个文件中，产生出错日志。</li>
<li>mysql.server:mysql.server只是对mysql_safe的一个封装，在调用mysql.server时需要在后边指定start参数。</li>
<li>mysql_multi:运行多个MySQL服务器程序</li>
</ul>
<p>关闭:mysql.server stop</p>
<h2 id="WINDOWS中"><a href="#WINDOWS中" class="headerlink" title="WINDOWS中"></a>WINDOWS中</h2><ul>
<li>手动启动：双击mysqld文件</li>
</ul>
<p><strong>WINDOWS中可以自动启动？</strong></p>
<p>可以，采用服务的方式，把某个程序程序注册为Windows服务。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注册：&quot;完整的可执行文件路径&quot; --install[-manual] [服务名]//加manual表示不要开机自动启动</span><br><span class="line">启动：net start MySQL</span><br><span class="line">关闭：net stop MySQL</span><br><span class="line">删除：&quot;完整的可执行文件路径&quot; --remove [服务名]</span><br></pre></td></tr></table></figure></p>
<p><strong>在服务端启动时服务的一些属性如何配置？</strong></p>
<h2 id="启动选项"><a href="#启动选项" class="headerlink" title="启动选项"></a>启动选项</h2><p>这些属性称为启动选项。</p>
<ol>
<li>可以在启动的命令行中配置，如果不写会有默认启动选项。</li>
<li>可以在配置文件修改。</li>
</ol>
<p>配置文件有多个，存在优先级。<br>命令行中的配置优先配置文件中的配置。</p>
<p><strong>配置文件中的配置有优先级吗？</strong><br>有，我们先了解一下配置文件。</p>
<h2 id="配置文件中的内容"><a href="#配置文件中的内容" class="headerlink" title="配置文件中的内容"></a>配置文件中的内容</h2><p>内容如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">(具体的配置内容...)</span><br><span class="line">[server]</span><br><span class="line">(具体的配置内容...)</span><br><span class="line">[mysql_safe]</span><br><span class="line">(具体的配置内容...)</span><br><span class="line">[mysql.server]</span><br><span class="line">(具体的配置内容...)</span><br><span class="line">[client]</span><br><span class="line">(具体的配置内容...)</span><br></pre></td></tr></table></figure></p>
<p>不同的启动命令读取不同分组中的内容</p>
<p><img src="/2018/10/08/MySQL/命令执行过程和基本管理/2.png" alt="启动命令的读取"></p>
<p>如果不同分组有同样的配置，按后出现的为准。</p>
<p><strong>如何表示服务端已经启动后的属性信息？进一步，我如果需要修改这些属性？</strong></p>
<h2 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h2><p>除了我们的自定义变量，其实MySQL服务器程序自身就维护了非常多的变量，这些变量也被称为系统变量。每个系统变量都代表服务器程序的一个设置项。<br>这些系统变量都可以在运行中查看，大部分都是在作为启动选项被赋值，有些可以在运行时被修改值。</p>
<p><strong>一个用户修改了系统变量会不会对另一个用户造成影响？</strong><br>会，因此需要有作用域。</p>
<h2 id="系统变量的作用域"><a href="#系统变量的作用域" class="headerlink" title="系统变量的作用域"></a>系统变量的作用域</h2><ul>
<li>GLOBAL：对所有客户端都有效。</li>
<li>SESSION：只对本客户端有效。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET [GLOBAL|SESSION] 系统变量名 = 值;</span><br><span class="line">SET [@@(GLOBAL|SESSION).]var_name = XXX;</span><br><span class="line">SHOW [GLOBAL|SESSION] VARIABLES [LIKE 匹配的模式];</span><br></pre></td></tr></table></figure>
<p>不写默认是SESSION</p>
<p>注意：</p>
<ol>
<li>并不是所有系统变量都具有GLOBAL和SESSION的作用范围。</li>
<li>有些系统变量是只读的，并不能设置值，比如版本号。</li>
</ol>
<p>启动选项和系统变量有区别也有联系</p>
<p>为了让我们更好的了解服务器程序的运行情况，MySQL服务器程序中维护了好多关于程序运行状态的变量，它们被称为状态变量</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>索引优化</title>
    <url>/2018/10/08/MySQL/%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h1><p><strong>索引一定可以好么？</strong></p>
<h2 id="索引的代价"><a href="#索引的代价" class="headerlink" title="索引的代价"></a>索引的代价</h2><ul>
<li>空间上：存储索引页需要额外的空间。</li>
<li>时间上：对数据的增删改都需要去维护索引。</li>
</ul>
<p><strong>如何使用索引能发挥最大能力？</strong></p>
<h2 id="会使用索引的场景"><a href="#会使用索引的场景" class="headerlink" title="会使用索引的场景"></a>会使用索引的场景</h2><ul>
<li>全值匹配</li>
<li>匹配左边的列</li>
<li>匹配范围值</li>
<li>精确匹配某一列并范围匹配另外一列</li>
<li>用于排序</li>
<li>用于分组</li>
</ul>
<p><strong>关于联合索引中的搜索顺序你知道吗？</strong><br>尽量按照定义索引列时的顺序来查询。如索引是A,B,C,如果采用A,C,B的查找一般也是可以的，但是这只是命令执行过程中的一个“语法优化”的关系，比较老的数据库可能不支持。</p>
<p><strong>范围查找会用到索引吗？</strong><br>只有使用最左边的索引列的范围查找会用到索引。</p>
<p><strong>为什么排序会用到索引？</strong><br>没有索引的排序会将查出来的数据放到内存中，再采用排序算法去处理。如果排序的顺序和索引顺序一致，则可以省略到这一个步骤。但是需要注意带排序的顺序也要遵循定义索引列时的顺序</p>
<h2 id="使用索引需要注意的事项"><a href="#使用索引需要注意的事项" class="headerlink" title="使用索引需要注意的事项"></a>使用索引需要注意的事项</h2><ul>
<li>只为用于搜索、排序或分组的列创建索引</li>
<li>为列的基数大的列创建索引</li>
<li>索引列的类型尽量小</li>
<li>可以只对字符串值的前缀建立索引</li>
<li>只有索引列在比较表达式中单独出现才可以适用索引</li>
<li>为了尽可能少的让聚簇索引发生页面分裂和记录移位的情况，建议让主键拥有AUTO_INCREMENT属性。</li>
<li>定位并删除表中的重复和冗余索引</li>
<li>尽量适用覆盖索引进行查询，避免回表带来的性能损耗。</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>MySQL索引</tag>
      </tags>
  </entry>
  <entry>
    <title>05 清理和初始化</title>
    <url>/2018/11/14/THING%20IN%20JAVA/05%20%E6%B8%85%E7%90%86%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<h1 id="清理和初始化"><a href="#清理和初始化" class="headerlink" title="清理和初始化"></a>清理和初始化</h1><h2 id="默认构造器"><a href="#默认构造器" class="headerlink" title="默认构造器"></a>默认构造器</h2><p>只要定义了一个构造器，编译器就不会帮我们自动创建默认构造器了。</p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="keyword">new</span> String();</span><br><span class="line">String b = <span class="keyword">new</span> String();</span><br><span class="line">a.toString();</span><br></pre></td></tr></table></figure>
<p><strong>如何确定调用类中的方法的对象是哪一个？</strong></p>
<p>实际上，a.toString()的真实调用时这样的：String(a)。<br>编译器会暗自把“所操作的对象的引用”作为第一个参数传递给peel()。</p>
<p><strong>使用this有什么用？</strong></p>
<ol>
<li>构造器中调用其它构造器只能使用this(参数)，这时候的this的含义不表示对象的引用了。不能使用两次。</li>
<li>区别参数和成员对象。</li>
<li>返回当前的对象，this的类型是实际运行时类型。</li>
</ol>
<p>注意：static方法不能使用this</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>一般来说，JAVA中的GC可以帮我们回收无用对象占有的资源，但也有一些特殊情况：垃圾回收期只回收使用new关键字分配的内存，通过其他方式获取的“特殊”内存区域，GC不知道如何回收。</p>
<p><strong>如何应对这种情况？</strong></p>
<p>JAVA提供了finalize()方法，垃圾回收器在回收对象前会调用这个方法。</p>
<p><strong>finalize()这和C++中的析构函数一样吗？</strong></p>
<p>C++中的对象可以在栈中，也可以在堆中。在栈中的对象生命周期是当前方法的作用域，离开这个作用域“{}”，就会调用析构函数，并且回收内存。在堆中的对象（使用new）需要使用delete来销毁，并且在回收内存也会调用析构函数。那么这里有两点：</p>
<ol>
<li>对象内存一定会被回收。</li>
<li>析构函数正常情况下都会被调用。<blockquote>
<p>C++中没有被回收的内存会造成内存泄漏，一直到下次重启这部分占用的内存才会消除。</p>
</blockquote>
</li>
</ol>
<p>由此我们可以分析出java中的垃圾回收和finalize()的区别了：</p>
<ol>
<li>对象不一定会被回收,即便是GC开始回收了。</li>
<li>因此finalize()也不一定会被调用，因此在finalize()中处理关闭资源等普通的清理操作是没有意义的。<blockquote>
<p>和C++还有不一样的一点是，finalize()是不能被直接调用的。</p>
</blockquote>
</li>
</ol>
<p><strong>那么finalize()有什么用呢？</strong></p>
<p>我们说垃圾回收是和内存不足了有关的，那么也就意味着：</p>
<ol start="3">
<li>只有内存不足的时候才会调用finalize()，也就意味着，在finalize()中最好也是处理内存相关的清理操作，而不是关闭资源等普通的清理操作。</li>
</ol>
<p><strong>需要在finalize()里处理的内存清理操作是什么？</strong></p>
<p>这种情况主要发生在“本地方法”的情况下，即在JAVA中调用了非JAVA的方法，这部分方法申请的内存需要使用free()来释放，因此在finalize()中调用free()方法。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>变量在使用前必须初始化，否则会出现程序错误。<br>成员变量会有一个默认值，局部变量需要手动赋值。</p>
<p><strong>初始化的顺序是怎样的？</strong></p>
<p>感觉就是分为类的初始化和对象的初始化。</p>
<ol>
<li>当首次调用静态方法，静态字段，构造器（可以看成静态方法）时，检查Class文件，若未发现，开始类初始化：加载.class文件，然后按顺序执行所有的静态初始化。</li>
<li>之后就不会再做类初始化了，当调用new()的时候执行对象的初始化：先在堆上分配空间，这块空间会被清零，也就是开始赋默认值，执行非静态的初始化。</li>
<li>执行构造器。</li>
<li>将引用指向这个地址（这一步有可能重排序）</li>
</ol>
]]></content>
      <categories>
        <category>Thinking in Java 读书笔记</category>
      </categories>
      <tags>
        <tag>清理和初始化</tag>
        <tag>JAVA编程思想</tag>
        <tag>Thinking in JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>13 String</title>
    <url>/2018/10/26/THING%20IN%20JAVA/13%20String/</url>
    <content><![CDATA[<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h2><p>String中每一个看似会修改String的方法，其实都是创建了一个全新的对象。<br>这也比较符合常识。</p>
<p><strong>不变带来的问题？</strong></p>
<p>看下面的一个案例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">"a"</span>;</span><br><span class="line">String b =a + <span class="string">"abc"</span> + <span class="number">123</span> + <span class="string">"a"</span>;</span><br></pre></td></tr></table></figure></p>
<p>String的“+”操作符使用append()重载了，append返回的是一个新对象。<br>a+”abc”会生成一个新的中间对象。<br>之后+123又生成一个中间对象，类推。<br>这样造成的问题是String的操作会生成许多没用的中间对象</p>
<p><strong>怎么办？</strong></p>
<p>JAVA的开发者也意识到这个问题。<br>于是最开始是对编译器作了一个优化。<br>像上面的案例，编译器会暗自生成一个StringBuilder来作字符串的拼接。<br>StringBuilder的append方法返回的是同一个对象。</p>
<p><strong>优化过了我们就可以随意使用String了吗？</strong></p>
<p>编译器的优化只针对String的简单操作。<br>涉及到String的循环拼接，每一个循环都要创建一个StringBuilder，这样实际的效果也没有多大的差别。</p>
<h2 id="无意识的递归"><a href="#无意识的递归" class="headerlink" title="无意识的递归"></a>无意识的递归</h2><p>当一个字符串对象+一个其他对象，会首先调用这个对象的toString()方法把它转成一个字符串对象。</p>
<h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><p><strong>还记得C中的printf()吗？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Row 1: [%d %f]\n"</span>, x, y);</span><br></pre></td></tr></table></figure>
<p>JAVA也延续了这种传统，使用System.out.printf()或者System.out.format():<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.printf(<span class="string">"Row 1: [%d %f]\n"</span>, x, y);</span><br></pre></td></tr></table></figure></p>
<p><strong>System.out.print()的真实面目：</strong></p>
<p>底层使用了Formatter类，这个类是专门用来处理格式化的。<br>它有很多构造器，参数都是关于格式化结果输出到哪个地方：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Formatter f = <span class="keyword">new</span> Formatter(System.out);</span><br><span class="line">f.format(<span class="string">"%s The Turtle is at (%d,%d)\n"</span>, name, x, y);</span><br></pre></td></tr></table></figure></p>
<p><strong>如何更精确的控制输出的格式？</strong></p>
<p>正确的使用格式化说明符:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">%[argument_index$][flags][width][.precision]conversion</span><br></pre></td></tr></table></figure></p>
<p>width:占位长度，不够用空格补。<br>.precision:多含义，最大长度，小数点个数。<br>+”-“:左对齐，默认是右对齐。</p>
<p><strong>还记得C中的sprintf()吗？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sprintf(s, <span class="string">"%d"</span>, <span class="number">123</span>);</span><br></pre></td></tr></table></figure>
<p>JAVA也延续了这种传统：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = String.format(<span class="string">"%02X "</span>, b);</span><br></pre></td></tr></table></figure></p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>关于正则表达式的语法，百度一下吧。<br>注意的是JAVA中字符串里的“\”表示反斜杠，正则表达式中”\“表示一个反斜杠<br>因此在JAVA的字符串中的正则表达式里”\\”才表达表示反斜杠</p>
<p><strong>如何创建正则表达式</strong></p>
<p><img src="/2018/10/26/THING IN JAVA/13 String/1.png" alt=""><br><img src="/2018/10/26/THING IN JAVA/13 String/2.png" alt=""><br><img src="/2018/10/26/THING IN JAVA/13 String/3.png" alt=""></p>
<h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><ol>
<li>贪婪型：它的特性是一次性地读入整个字符串，如果不匹配就吐掉最右边的一个字符再匹配，直到找到匹配的字符串或字符串的长度为0为止。它的宗旨是读尽可能多的字符，所以当读到第一个匹配时就立刻返回。</li>
<li>勉强型：它的特性是从字符串的左边开始，试图不读入字符串中的字符进行匹配，失败，则多读一个字符，再匹配，如此循环，当找到一个匹配时会返回该匹配的字符串，然后再次进行匹配直到字符串结束。</li>
<li>占有型：它和贪婪模式很相似，不同点是它不会往会吐。</li>
</ol>
<p><strong>JAVA里如何使用正则表达式？</strong></p>
<p>最简答的是使用String中的一些方法：</p>
<ol>
<li>matches(“xxx”)：成功true，失败false.</li>
<li>split(“xxx”)：以xxx来分割字符串为数组。</li>
<li>replaceFirst(“xxx”,str),replaceAll：用str来替换匹配成功的值。</li>
</ol>
<p><strong>仅仅在String中使用正则表达式的功能还是有些简单的，有更多的用法？</strong></p>
<h2 id="Pattern和Matcher类"><a href="#Pattern和Matcher类" class="headerlink" title="Pattern和Matcher类"></a>Pattern和Matcher类</h2><p>Pattern是一个正则表达式类，它的构造器私有化了，但是可以通过compile(string regex)返回一个正则表达式对象。<br>之后pattern里有个matcher(CharSquence str)来生成一个Matcher对象。</p>
<blockquote>
<p>CharSquence是String,StringBuilder,CharBuffer,StringBuffer抽象出来的一般化定义。</p>
</blockquote>
<p>Matcher对象里提供了更多匹配的功能：</p>
<ol>
<li>matches():整个字符串整个匹配。</li>
<li>lookingAt():起始部分是否匹配。</li>
<li>find():迭代式的搜索是否有匹配的部分，接受一个起始点参数I。</li>
</ol>
<p><strong>如何从匹配出来的字符串中选取我需要的内容？</strong></p>
<p>使用组，组是用括号划分的正则表达式：A(B(C))D<br>组0是ABCD,组1是BC,组2是C。<br>案例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Groups</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">final</span> String POEM = <span class="string">"Twas brillig, and the slithy toves\n"</span> + <span class="string">"Did gyre and gimble in the wabe.\n"</span> + <span class="string">"All mimsy were the borogoves,\n"</span> + <span class="string">"And the mome raths outgrabe.\n\n"</span> + <span class="string">"Beware the Jabberwock, my son,\n"</span> + <span class="string">"The jaws that bite, the claws that catch.\n"</span> + <span class="string">"Beware the Jubjub bird, and shun\n"</span> + <span class="string">"The frumious Bandersnatch."</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Matcher m = Pattern.compile(<span class="string">"(?m)(\\S+)\\s+((\\S+)\\s+(\\S+))$"</span>).matcher(POEM);</span><br><span class="line">        <span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m.groupCount(); j++) printnb(<span class="string">"["</span> + m.group(j) + <span class="string">"]"</span>);</span><br><span class="line">            print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output: [the slithy toves][the][slithy toves][slithy][toves]</span></span><br><span class="line"><span class="comment">[in the wabe.][in][the wabe.][the][wabe.]</span></span><br><span class="line"><span class="comment">[were the borogoves,][were][the borogoves,][the][borogoves,]</span></span><br><span class="line"><span class="comment">[mome raths outgrabe.][mome][raths outgrabe.][raths][outgrabe.]</span></span><br><span class="line"><span class="comment">[Jabberwock, my son,][Jabberwock,][my son,][my][son,]</span></span><br><span class="line"><span class="comment">[claws that catch.][claws][that catch.][that][catch.]</span></span><br><span class="line"><span class="comment">[bird, and shun][bird,][and shun][and][shun]</span></span><br><span class="line"><span class="comment">[The frumious Bandersnatch.][The][frumious Bandersnatch.][frumious][Bandersnatch.]</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure></p>
<ol start="4">
<li>start():返回匹配成功的字符串的开始位置。</li>
<li>end():返回匹配成功的字符串的最后位置+1。</li>
<li>Pattern.split(CharSequence input[,int limit]):断开成字符串对象数组。</li>
<li>reset():将现有的Matcher用于一个新的字符串，好处是不需要创建很多个Matcher对象。</li>
</ol>
<p>正则表达式结合I/O流可以实现对文件的检索。<br>至于如何读取文件，在以后会详细的学习。</p>
]]></content>
      <categories>
        <category>Thinking in Java 读书笔记</category>
      </categories>
      <tags>
        <tag>JAVA编程思想</tag>
        <tag>Thinking in JAVA</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>16 数组</title>
    <url>/2018/11/08/THING%20IN%20JAVA/16%20%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组为什么特殊？"><a href="#数组为什么特殊？" class="headerlink" title="数组为什么特殊？"></a>数组为什么特殊？</h2><ol>
<li>效率：就是一个简单的线性序列，因此访问速度很快。但是代价是空间被限制。ArrayList空间的自动分配是将旧实例中所有的引用移到新实例中，但是这种弹性需要额外的开销。</li>
<li>类型：在泛型出现之前，容器中的所有对象都当作根对象Object处理，而数组可以定义具体类型(这种数组成为对象数组)，以通过编译器检查，防止插入错误类型和抽取不当类型。</li>
<li>数组可以持有基本类型：容器只能持有对象，当然，现在的JAVA具有了自动包装机制，让容器看起来也持有基本类型。</li>
</ol>
<h2 id="数组和容器的差别在哪？"><a href="#数组和容器的差别在哪？" class="headerlink" title="数组和容器的差别在哪？"></a>数组和容器的差别在哪？</h2><p>在于数组使用[]来访问，容器使用set()，get()。<br>随着泛型和自动包装的出现，数组仅有的优势在于效率，但是这种效率的提升并不能代替容器带来的简便，因此还是推荐使用容器。</p>
<h2 id="数组是一个对象吗？"><a href="#数组是一个对象吗？" class="headerlink" title="数组是一个对象吗？"></a>数组是一个对象吗？</h2><p>是的，只是这个对象很特殊，我们找不到他的CLASS文件，因为他是由底层JAVA虚拟机来生成的，因此数组也是Object的子类，但是会特别对待，具体的知识了解JVM后才能弄明白。<br>对象数组中保存其他对象的引用。<br>基本类型数组保存值。</p>
<h2 id="数组重写了Object类里的toString-方法吗？"><a href="#数组重写了Object类里的toString-方法吗？" class="headerlink" title="数组重写了Object类里的toString()方法吗？"></a>数组重写了Object类里的toString()方法吗？</h2><p>没有，那要怎么输出数组中的值？而不是打印这个对象引用呢？<br>使用Arrays.toString(a)。<br>多维数组使用Arrays.deepToString(a)</p>
<h2 id="JAVA中的数组和C-C-中数组有区别吗？"><a href="#JAVA中的数组和C-C-中数组有区别吗？" class="headerlink" title="JAVA中的数组和C,C++中数组有区别吗？"></a>JAVA中的数组和C,C++中数组有区别吗？</h2><p>有，回忆在C，C++中调用函数返回一个数组的例子？我们只能返回一个数组的指针（意味着只能通过这个指针去访问数组元素），但是这么做的话会使这个数组的生命周期变得很复杂，内存无法回收，而且导致内存泄漏，而在JAVA中，我可以直接返回一个“数组”，剩下的一切交给垃圾回收器处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> A[] f()&#123;<span class="keyword">return</span> ...&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="数组和泛型为什么不能很好的结合？"><a href="#数组和泛型为什么不能很好的结合？" class="headerlink" title="数组和泛型为什么不能很好的结合？"></a>数组和泛型为什么不能很好的结合？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Peel&lt;Banana&gt;[] peels = <span class="keyword">new</span> Peel&lt;Banana&gt; [<span class="number">10</span>]; <span class="comment">// Illegal</span></span><br></pre></td></tr></table></figure>
<p>泛型的擦除会擦除参数类型信息，使得所有的参数类型都是Object，而数组并不满足于此，它需要明确的知道具体的参数类型是什么，所以产生了矛盾。<br>但是我们可以在泛型类或者泛型方法中使用参数化的数组。</p>
<p>但是可以这样处理：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Peel&lt;Banana&gt;[] peels;</span><br><span class="line">peels = (<span class="keyword">new</span> Peel&lt;Banana&gt;) Object[<span class="number">10</span>]; <span class="comment">// Illegal</span></span><br></pre></td></tr></table></figure></p>
<p><strong>如何理解</strong><br>有一个说法是，JAVA语法规范中说明：<br>数组是协变性的，具象性的，泛型时无关性的。</p>
<h2 id="如何快速的填充数组中的数据以用于各种测试？"><a href="#如何快速的填充数组中的数据以用于各种测试？" class="headerlink" title="如何快速的填充数组中的数据以用于各种测试？"></a>如何快速的填充数组中的数据以用于各种测试？</h2><ol>
<li>使用Arrays中的fill()方法，但是有一个局限，就是只能用同一个值（引用）填充数组。</li>
<li>使用Generator自定义一套生成的方式。</li>
</ol>
<h2 id="Arrays实用功能"><a href="#Arrays实用功能" class="headerlink" title="Arrays实用功能"></a>Arrays实用功能</h2><ol>
<li>arraycopy(source,splace,title,tpalce,length)复制</li>
<li>equals(a1,a2)，个数，每个元素equal()。</li>
<li>deepEquals()：多位数组比较</li>
<li>sort()：排序，排序的规则或者实现Comparable，要么传递一个Comparator类。</li>
</ol>
]]></content>
      <categories>
        <category>Thinking in Java 读书笔记</category>
      </categories>
      <tags>
        <tag>JAVA编程思想</tag>
        <tag>Thinking in JAVA</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>17 容器</title>
    <url>/2018/11/15/THING%20IN%20JAVA/17%20%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p><img src="/2018/11/15/THING IN JAVA/17 容器/1.png" alt="完整的容器关系图"></p>
<h2 id="填充容器"><a href="#填充容器" class="headerlink" title="填充容器"></a>填充容器</h2><ol>
<li>和数组一样，容器也有相应的Collections类来扩充容器的使用功能，使用fill()和nCopies()可以填充容器。问题：填充的对象单一。</li>
<li>使用构造器。问题：无法自动填充</li>
</ol>
<p><strong>如何更好的解决填充问题？</strong></p>
<ol>
<li>使用生成器Generator<t><br>填充一个Collection<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generators</span> </span>&#123;   </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">fill</span><span class="params">(Collection&lt;T&gt; coll, Generator&lt;T&gt; gen, <span class="keyword">int</span> n)</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)       </span><br><span class="line">        coll.add(gen.next());     </span><br><span class="line">    <span class="keyword">return</span> coll;   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</t></li>
</ol>
<p>也可以使用适配模式，定义适配Gneerator接口的Collection。</p>
<ol start="2">
<li>使用自定义的只读Collection</li>
</ol>
<p><strong>如何自定义？</strong></p>
<p>容器中有很多Abstract类，这些类已经实现了大部分Collection（Map）的功能，我们需要实现的已经很少了，如果只是需要定制一个只读的Collection（Map），需要做的事情就更少。</p>
<ol>
<li>创建一个MyMap，我们需要继承AbstractMap，实现里面的抽象方法，Set<entry> entrySet();</entry></li>
<li>从这个方法我们可以看出，还需要定义实现了Entry接口的对象和容纳这个对象的Set;</li>
<li>自定义MySet，需要继承AbstractSet，实现里面的抽象方法：int size()和Interator interator();</li>
<li>同时，这也说明需要定义一个实现了Iterator接口的对象，作为返回。</li>
</ol>
<p>那些只读的数据可以提前封装到Entry类中，但是这样会有一个问题：我每次创建一个Map，都需要把这些Entry类给生成一次，这样就造成了大量对象的创建，给内存空间和GC带来了很大的压力，<strong>有什么比较好的解决方案么？</strong></p>
<p>使用享元模式。</p>
<p><strong>什么是享元模式？</strong></p>
<p>大致的意思是将一个完整的对象和这个对象的一个外部（表面）对象表示关联起来，这样通过这个外部对象可以取得完整的对象，通常是使用map来做一个绑定。优势：</p>
<ol>
<li>不需要再创建大量的相同对象</li>
<li>创建的时间也减少<br>享元模式我感觉就像是缓存。</li>
</ol>
<h2 id="Collection的功能方法"><a href="#Collection的功能方法" class="headerlink" title="Collection的功能方法"></a>Collection的功能方法</h2><p><img src="/2018/11/15/THING IN JAVA/17 容器/2.png" alt="Collection的功能方法"><br>LIst有get(index)的方法，Set没有，因为Set的元素顺序是自己维护的。</p>
<p><strong>Collection中方法可选表示什么意思？</strong></p>
<p>表示实现了Collection（实际上是继承AbstractCollection）的类按需求可以选择的去实现这些方法，因此AbstractCollection会给默认的实现，尽管这些实现基本上是返回一个UnsupportedOperationException异常。</p>
<p><strong>这样处理的好处是什么？</strong></p>
<p>尽量使用一个接口满足绝大部分人的需求：比如两个不同需求的LIst:固定尺寸的List，不可修改的List，接口上前者比后者会多一个set()方法，因此需要两个不同的接口。但是对于容器而言，不同的需求是无穷无尽的，因此为了防止接口爆炸，兼容绝大多数的需求，实现易学易用，JAVA选择了牺牲一下接口应该具有的安全性。</p>
<p>上面提到的尺寸固定的List就是Arrays中的内部类，Arrays.asList()返回的List，它没有做add()方法的定义。而不可修改的List是指Collections.unmodifiableList()返回的List.</p>
<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>[优先队列]<a href="https://www.cnblogs.com/CarpenterLee/p/5488070.html" target="_blank" rel="noopener">https://www.cnblogs.com/CarpenterLee/p/5488070.html</a></p>
<h2 id="LIst"><a href="#LIst" class="headerlink" title="LIst"></a>LIst</h2><p>最简单的List需要继承AbstractList并且需要实现get(index)和size()方法。</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><img src="/2018/11/15/THING IN JAVA/17 容器/3.png" alt="几种不同的Set"><br>如果加入的元素没有实现所要求的方法，在使用的时候或者去重无效，或者抛出异常。</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><img src="/2018/11/15/THING IN JAVA/17 容器/4.png" alt="几种不同的Map"></p>
<p><strong>equal()和hashCode()分别扮演了怎樣的角色？</strong></p>
<p>hashCode()计算所在的散列值，但是两个对象也会出现散列值相同的情况，这时候再通过equal()去判断是否相等。</p>
<h2 id="HashMap的性能因子"><a href="#HashMap的性能因子" class="headerlink" title="HashMap的性能因子"></a>HashMap的性能因子</h2><p>容量：表的槽位<br>初始容量：初始表的槽位<br>尺寸：当前已使用的槽位<br>负载因子：尺寸/容量，当实际比例达到负载因子，会自动扩充容量（再散列）。</p>
]]></content>
      <categories>
        <category>Thinking in Java 读书笔记</category>
      </categories>
      <tags>
        <tag>JAVA编程思想</tag>
        <tag>Thinking in JAVA</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>20 注解</title>
    <url>/2018/11/26/THING%20IN%20JAVA/20%20%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="APT实现注解处理器"><a href="#APT实现注解处理器" class="headerlink" title="APT实现注解处理器"></a>APT实现注解处理器</h2><p>除了使用反射实现注解处理器，还可以使用APT来实现？</p>
<p><strong>什么是APT？和反射比起来有什么区别?</strong></p>
<p>APT:注解处理工具，属于编译时期处理注解的工具。<br>和反射处理注解比起来：</p>
<ol>
<li>因为发生在编译时期，性能比反射高一些。</li>
<li>比较重要的用途是用来生成新的代码。</li>
<li>使用起来比反射要复杂一些，尤其是在生成新代码的时候，最好结合JavaPoet来使用。</li>
<li>代码需要指定处理器手动调用编译器进行编译。</li>
</ol>
<p>TIJ中的APT方法已在JAVA6加入到JDK中，从网上找到的使用方法如下：</p>
<p>[JAVA apt使用语法]<a href="https://www.jianshu.com/p/07ef8ba80562" target="_blank" rel="noopener">https://www.jianshu.com/p/07ef8ba80562</a><br>[JAVA apt使用语法] <a href="https://juejin.im/post/584d4aa00ce463005c5dbc36" target="_blank" rel="noopener">https://juejin.im/post/584d4aa00ce463005c5dbc36</a><br>[JavaPoet使用指南] <a href="https://juejin.im/post/584d4b5b0ce463005c5dc444" target="_blank" rel="noopener">https://juejin.im/post/584d4b5b0ce463005c5dc444</a></p>
<p>可以结合访问者模式来优化实现方案：</p>
<p><strong>什么是访问者模式？</strong></p>
<p>参考：[访问者模式]<a href="https://blog.csdn.net/qq_24451605/article/details/51151985" target="_blank" rel="noopener">https://blog.csdn.net/qq_24451605/article/details/51151985</a></p>
<ul>
<li>Visitor:抽象访问者，在重载的visit函数中声明访问者可以访问的对象。</li>
<li>Concrete Visitor:实现一个访问者对于一个具体的元素的操作</li>
<li>Element:抽象元素，声明具有访问该类型元素权限的访问者的类型(一般是抽象类型)，提供重载的accept函数赋予权限</li>
<li>Concrete Element:实现accept方法，基本上是模板化的visitor.visit(this)</li>
<li><p>Object Structure:容纳多种类型或许不同，接口或者不同的元素的集合。</p>
</li>
<li><p>封装一些作用于数据结构中的各元素的操作，不同的操作可以借助新的visitor实现，降低了操作间的耦合性</p>
</li>
<li>访问者可以将数据结构和对数据的操作解耦，使得增加对数据结构的操作不需要取修改数据结构，也不必去修改原有的操作，而执行时再定义新的Visitor时闲着就行了(在操作添加上易拓展)</li>
</ul>
<p>案例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String university;</span><br><span class="line">    <span class="keyword">private</span> String rating;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bachelor</span> <span class="keyword">extends</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">( Visitor visitor )</span> </span>&#123;</span><br><span class="line">        visitor.visit( <span class="keyword">this</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">College</span> <span class="keyword">extends</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span> <span class="params">( Bachelor bachelor )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span> <span class="params">( College college )</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShowVisitor</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Bachelor bachelor)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A bachelor\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(College college)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" a college student!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SumVisitor</span> <span class="keyword">implements</span> <span class="title">Visitor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> totalBachelor;</span><br><span class="line"></span><br><span class="line">    SumVisitor()&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        totalBachelor = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Bachelor bachelor)</span> </span>&#123;</span><br><span class="line">        totalBachelor++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(College college)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTotal_bachelor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> totalBachelor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这里访问者模式运用到了我们这之前学过的JAVA多路分派的方法。</p>
<p><strong>使用访问者模式的优劣？</strong></p>
<p>看一个普通的案例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String university;</span><br><span class="line">    <span class="keyword">private</span> String rating;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bachelor</span> <span class="keyword">extends</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A bachelor\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> totalBachelor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">void</span> <span class="title">sum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        totalBachelor++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTotal_bachelor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> totalBachelor;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">College</span> <span class="keyword">extends</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" a college student!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相比，使用了访问者模式的优势在于：</p>
<ol>
<li>解决数据结构与数据操作分离的问题，避免某些操作污染数据对象类，符合单一职责原则，功能上具有良好的拓展性。</li>
<li>当我需要对某个数据结构新增一种操作逻辑的时候，需要新增一个访问者，这样的好处是维护的时候不需要再数据对象中浏览大量的操作逻辑来寻找，其次，当访问者或者数据结构的对象越来越多，代码就会越来越乱，维护起来也越来越不方便。<br>劣势在于：</li>
<li>没有面向接口编程，违反了依赖倒置原则，类之间的耦合增加，为类的修改带了麻烦。</li>
</ol>
]]></content>
      <categories>
        <category>Thinking in Java 读书笔记</category>
      </categories>
      <tags>
        <tag>JAVA编程思想</tag>
        <tag>Thinking in JAVA</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>02 重构原则</title>
    <url>/2019/01/07/refactoring/02%20%E9%87%8D%E6%9E%84%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="重构原则（P78-99）"><a href="#重构原则（P78-99）" class="headerlink" title="重构原则（P78-99）"></a>重构原则（P78-99）</h1><h2 id="为何重构"><a href="#为何重构" class="headerlink" title="为何重构"></a>为何重构</h2><ol>
<li>使代码更容易理解和修改</li>
<li>优化性能，便于维护</li>
</ol>
<p>利用重构技术开发时，应该把时间分配给两种截然不同的行为，添加新功能，以及重构。</p>
<h2 id="何时重构"><a href="#何时重构" class="headerlink" title="何时重构"></a>何时重构</h2><p>三次法则：第一次只管去做。第二次会反感，但是可以这样做。第三次应该重构。</p>
<p>时机：</p>
<ol>
<li>为了理解代码</li>
<li>为了弥补过去的不足，添加新特性</li>
<li>使用重构复审代码</li>
</ol>
<p>重构是为了明天的工作更加轻松。</p>
<p>修改接口：修改已经发布的接口需要谨慎修改，尽量采用<strong>在旧接口中调用新接口</strong>的方式来实现。</p>
<p>重构的前提是代码的大部分功能都健全，并且不建议在最后关头做重构。</p>
<h2 id="重构与设计"><a href="#重构与设计" class="headerlink" title="重构与设计"></a>重构与设计</h2><p>“预先设计”有必要，但是需要臆想到方方面面，难度大而且实施起来就不一定如意，因此可以<strong>使用重构来取代预先设计</strong>，只管按照最初的想法开始编码,让代码有效运作，然后再将它重构成型。这里并不是说预先设计就没有必要，最好还是有一个初步的设计，结合起来使用。</p>
<h2 id="重构与性能"><a href="#重构与性能" class="headerlink" title="重构与性能"></a>重构与性能</h2><p>三种编写快速软件的方式：</p>
<ol>
<li>时间预算法：分解设计时对每一个组件分配定量的资源——包括时间和执行的轨迹，每个组件绝对不能超过自己的预算时间，这种方法高度重视性能，运用在少部分系统中。</li>
<li>持续关注法：要求在任何时间做任何事都要保持系统的高性能，但是为了实现这种方法，开发的速度必然大大的降低，每一次都要思考最好的方式，性能改善分散在每一个角落，每一次修改都只是从程序的一个狭隘的角度出发。</li>
<li>大半的时间都消耗在一小部分的代码上，90%的优化工作都是白费劲。第三种方式就是先，编写良好的程序，不对性能做过多的关注，进入代码优化阶段时再对10%的“热点”部分做思考。</li>
</ol>
<p>重构虽然可能使程序运行的教慢，但是它能使得我们比较快的开发出容易理解，容易添加新功能，细粒度更小的良好代码，在性能优化阶段可以针对“热点”进行优化，使得性能调整更容易：</p>
]]></content>
      <categories>
        <category>重构 学习笔记</category>
      </categories>
      <tags>
        <tag>重构原则</tag>
        <tag>重构</tag>
      </tags>
  </entry>
  <entry>
    <title>07 责任重构</title>
    <url>/2019/01/09/refactoring/07%20%E8%B4%A3%E4%BB%BB%E9%87%8D%E6%9E%84/</url>
    <content><![CDATA[<h1 id="责任重构"><a href="#责任重构" class="headerlink" title="责任重构"></a>责任重构</h1><p>让代码尽量符合单一职责原则，会大大的提高阅读和维护效率</p>
<h2 id="Move-Method（搬移函数）"><a href="#Move-Method（搬移函数）" class="headerlink" title="Move Method（搬移函数）"></a>Move Method（搬移函数）</h2><p>problem:有个函数与其所驻class之外的另一个class进行更多交流：调用后者，或被后者调用；可以认为这个函数更适合作为另一个class的特性。<br>solution:在该函数最常引用的class中建立一个有着类似行为的新函数；之后将旧函数变成一个单纯的委托函数（delegating method），或是将旧函数完全移除。</p>
<p><img src="/2019/01/09/refactoring/07 责任重构/1.gif" alt=""></p>
<p><strong>重构原因？</strong></p>
<p>这个方法被另外的对象调用的更多，更适合作为另一个对象具有的功能。</p>
<p><strong>什么时候需要被移动？</strong></p>
<p>使用另一个对象的次数比使用自己所驻对象的次数还多。<br>如果真的很难做出决定，那么或许「移动这个函数与否」并不那么重要。可以先放着，以后总是可以修改的。</p>
<h2 id="Move-Field（搬移值域）"><a href="#Move-Field（搬移值域）" class="headerlink" title="Move Field（搬移值域）"></a>Move Field（搬移值域）</h2><p>problem:某个field（值域〕被其所驻class之外的另一个class更多地用到。<br>solution:在target class 建立一个new field，修改source field的所有用户，令它们改用此new field。</p>
<p><img src="/2019/01/09/refactoring/07 责任重构/2.gif" alt=""></p>
<p><strong>重构原因？</strong></p>
<p>这个字段被另一个类使用的更多，更适合作为另一个类具有的属性。</p>
<h2 id="Extract-Class（提炼类）"><a href="#Extract-Class（提炼类）" class="headerlink" title="Extract Class（提炼类）"></a>Extract Class（提炼类）</h2><p>problem:某个class做了应该由两个classes做的事。<br>solution:建立一个新class，将相关的值域和函数从旧class搬移到新class。</p>
<p><img src="/2019/01/09/refactoring/07 责任重构/3.gif" alt=""></p>
<p><strong>重构原因？</strong></p>
<p>别让一个类做太多的事情，必要的时候分离出一个新的class。</p>
<h2 id="Inline-Class（将类内联化）"><a href="#Inline-Class（将类内联化）" class="headerlink" title="Inline Class（将类内联化）"></a>Inline Class（将类内联化）</h2><p>problem:某个class没有做太多事情（没有承担足够责任）。<br>solution:将class的所有特性搬移到另一个class中，然后移除原class。</p>
<p><img src="/2019/01/09/refactoring/07 责任重构/4.gif" alt=""></p>
<h2 id="Hide-Delegate（隐藏「委托关系」）"><a href="#Hide-Delegate（隐藏「委托关系」）" class="headerlink" title="Hide Delegate（隐藏「委托关系」）"></a>Hide Delegate（隐藏「委托关系」）</h2><p>problem:客户端从对象A的字段或方法获取对象B.然后客户端调用对象B的方法。<br>solution:在类A中创建一个新方法，该方法将调用委托给对象B.现在客户端不知道或依赖于类B.</p>
<p><img src="/2019/01/09/refactoring/07 责任重构/5.gif" alt=""></p>
<p><strong>什么是委托？</strong></p>
<p>客户端调用的对象获取不到信息，只能委托给第三方类来获取，这个第三方对象就叫委托类。<br>这种通过其他类来获取信息的方式就叫委托。</p>
<p><strong>重构原因？</strong></p>
<p>「封装」即使不是对象的最关键特征，也是最关键特征之一。<br>「封装」意味每个对象都应该尽可能少了解系统的其他部分。<br>如此一来，一旦发生变化，需要了解这一变化的对象就会比较少——从而使得变化比较容易进行。</p>
<h2 id="Remove-Middle-Man（移除中间人）"><a href="#Remove-Middle-Man（移除中间人）" class="headerlink" title="Remove Middle Man（移除中间人）"></a>Remove Middle Man（移除中间人）</h2><p>problem:类有太多方法，这些方法都是委托其它对象。<br>solution:删除这些方法并强制客户端直接调用委托类的方法。</p>
<p><img src="/2019/01/09/refactoring/07 责任重构/6.gif" alt=""></p>
<p><strong>重构原因？</strong></p>
<p>封装也是要付出代价的，它的代价就是：每当客户要使用 delegate（受托类）的新特性时，就必须在server端添加一个简单委托函数。随着delegate的特性（功能）愈来愈多，这一过程会让你痛苦不己。server 完全变成了一 个「中间人」，此时你就应该让客户直接调用delegate。</p>
<blockquote>
<p>合适的隐藏程序需要随着系统相应的变化，重构的意义就在于——代码的逻辑永远不会有问题，我们要做的只是不断的修补。</p>
</blockquote>
<h2 id="Introduce-Foreign-Method（引入外加函数）"><a href="#Introduce-Foreign-Method（引入外加函数）" class="headerlink" title="Introduce Foreign Method（引入外加函数）"></a>Introduce Foreign Method（引入外加函数）</h2><p>problem:在调用的库类中，想要增加一个函数，但是并没有代码的访问权。<br>solution:这时，只能再本类中新增一个函数，并把库类作为参数传入，然后实现新的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date newStart = <span class="keyword">new</span> Date (previousEnd.getYear(),previousEnd.getMonth(), previousEnd.getDate() + <span class="number">1</span>);<span class="comment">//被多次使用到</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//======================after refactoring=========================</span></span><br><span class="line"></span><br><span class="line">Date newStart = nextDay(previousEnd);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Date <span class="title">nextDay</span><span class="params">(Date arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date (arg.getYear(),arg.getMonth(), arg.getDate() + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无法修改Date类，就在本类中新增新一个方法，使用Date辅助我们实现。</p>
<p><strong>重构原因？</strong></p>
<ol>
<li>某个功能代码被多次使用到，这时候需要提取成方法来实现复用。</li>
<li>无法直接修改源码<blockquote>
<p>外加函数终归是权宜之计。如果有可能，你仍然应该将这些函数搬移到它们的理想家园。</p>
</blockquote>
</li>
</ol>
<h2 id="Introduce-Local-Extension（引入本地扩展）"><a href="#Introduce-Local-Extension（引入本地扩展）" class="headerlink" title="Introduce Local Extension（引入本地扩展）"></a>Introduce Local Extension（引入本地扩展）</h2><p>当Introduce Foreign Method需要增加的函数过多，就需要建立一个新class，使它包含这些额外函数。<br>让这个扩展类成为source class的subclass（子类〕或wrapper（外覆类——使用组合引入source class）。</p>
<p><img src="/2019/01/09/refactoring/07 责任重构/7.gif" alt=""></p>
<p><strong>重构原因？</strong></p>
<p>如果只需要一两个函数，你可以使用Introduce Foreign Method。但如果你需要的额外函数超过两个，外加函数（foreign methods）就很难控制住它们了。所以，你需要将这些函数组织在一起，放到一个恰当地方去。要达到这一目的，标准对象技术subclassing和wrapping是显而易见的办法。这种情况下我把subclass或wrapper称为local extention（本地扩展〕。</p>
]]></content>
      <categories>
        <category>重构 学习笔记</category>
      </categories>
      <tags>
        <tag>重构</tag>
        <tag>责任重构</tag>
      </tags>
  </entry>
  <entry>
    <title>09 条件表达式重构</title>
    <url>/2019/01/14/refactoring/09%20%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%87%8D%E6%9E%84/</url>
    <content><![CDATA[<h1 id="条件表达式重构"><a href="#条件表达式重构" class="headerlink" title="条件表达式重构"></a>条件表达式重构</h1><p>如何让条件语句看起来更清晰？</p>
<h2 id="Decompose-Conditional（分解条件式）"><a href="#Decompose-Conditional（分解条件式）" class="headerlink" title="Decompose Conditional（分解条件式）"></a>Decompose Conditional（分解条件式）</h2><p>problem:你有一个复杂的条件（if-then-else）语句。<br>solution:从if、then、else 三个段落中分别提炼出独立函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (date.before (SUMMER_START) || date.after(SUMMER_END))</span><br><span class="line">     charge = quantity * _winterRate + _winterServiceCharge;</span><br><span class="line"> <span class="keyword">else</span> charge = quantity * _summerRate;</span><br><span class="line"></span><br><span class="line"><span class="comment">//======================after refactoring=========================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (notSummer(date))</span><br><span class="line">   charge = winterCharge(quantity);</span><br><span class="line"><span class="keyword">else</span> charge = summerCharge (quantity);</span><br></pre></td></tr></table></figure>
<p><strong>重构的原因？</strong></p>
<p>程序之中，【复杂的条件逻辑】是最常导致复杂度上升的地点之一。<br>对于条件逻辑，【将每个分支条件分解，形成新函数】还可以给你带来更多好处：可以突出条件逻辑，更清楚地表明每个分支的作用，并且突出每个分支的原因。</p>
<h2 id="Consolidate-Conditional-Expression（合并条件式）"><a href="#Consolidate-Conditional-Expression（合并条件式）" class="headerlink" title="Consolidate Conditional Expression（合并条件式）"></a>Consolidate Conditional Expression（合并条件式）</h2><p>problem:你有一系列条件测试，都得到【相同结果】。<br>solution:将这些测试合并为一个条件式，并将这个条件式提炼成为一个独立函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">disabilityAmount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_seniority &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (_monthsDisabled &gt; <span class="number">12</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (_isPartTime) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// compute the disability amount</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//======================after refactoring=========================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">disabilityAmount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isNotEligableForDisability()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// compute the disability amount</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isNotEligibleForDisability</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((_seniority &lt; <span class="number">2</span>) || (_monthsDisabled &gt; <span class="number">12</span>) || (_isPartTime));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>重构的原因？</strong></p>
<ol>
<li>合并后的条件代码会告诉你【实际上只有一次条件检查，只不过有数个并列条件需要检查而已】，从而使这一次检查的用意更清晰。</li>
<li>【将检查条件提炼成一个独立函数】对于理解代码意义非常有用，因为它把描述【做什么】的语句换成了【为什么这样做】。</li>
</ol>
<h2 id="Consolidate-Duplicate-Conditional-Fragments（合并重复的条件片段）"><a href="#Consolidate-Duplicate-Conditional-Fragments（合并重复的条件片段）" class="headerlink" title="Consolidate Duplicate Conditional Fragments（合并重复的条件片段）"></a>Consolidate Duplicate Conditional Fragments（合并重复的条件片段）</h2><p>problem:在条件式的每个分支上有着相同的一段代码。<br>solution:将这段重复代码搬移到条件式之外。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isSpecialDeal()) &#123;</span><br><span class="line">       total = price * <span class="number">0.95</span>;</span><br><span class="line">       send();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">       total = price * <span class="number">0.98</span>;</span><br><span class="line">       send();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//======================after refactoring=========================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isSpecialDeal())</span><br><span class="line">   total = price * <span class="number">0.95</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   total = price * <span class="number">0.98</span>;</span><br><span class="line">send();</span><br></pre></td></tr></table></figure>
<p><strong>重构的原因？</strong></p>
<p>代码能更清楚地表明哪些东西随条件的变化而变化、哪些东西保持不变。</p>
<h2 id="Remove-Control-Flag（移除控制标记）"><a href="#Remove-Control-Flag（移除控制标记）" class="headerlink" title="Remove Control Flag（移除控制标记）"></a>Remove Control Flag（移除控制标记）</h2><p>problem:在一系列布尔表达式（boolean expressions）中，某个变量带有【控制标记】（control flag）的作用。<br>solution:以break语句或return的语句取代控制标记。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkSecurity</span><span class="params">(String[] people)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; people.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (! found) &#123;</span><br><span class="line">           <span class="keyword">if</span> (people[i].equals (<span class="string">"Don"</span>))&#123;</span><br><span class="line">             sendAlert();</span><br><span class="line">             found = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//======================after refactoring=========================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkSecurity</span><span class="params">(String[] people)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; people.length; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (people[i].equals (<span class="string">"Don"</span>))&#123;</span><br><span class="line">           sendAlert();</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>重构的原因？</strong></p>
<p>条件语句真正的用途会清晰得多</p>
<h2 id="Replace-Nested-Conditional-with-Guard-Clauses（以卫语句取代嵌套条件式）"><a href="#Replace-Nested-Conditional-with-Guard-Clauses（以卫语句取代嵌套条件式）" class="headerlink" title="Replace Nested Conditional with Guard Clauses（以卫语句取代嵌套条件式）"></a>Replace Nested Conditional with Guard Clauses（以卫语句取代嵌套条件式）</h2><p>problem:函数中的条件逻辑（conditional logic）使人难以看清正常的执行路径。<br>solution:使用卫语句（guard clauses）表现所有特殊情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">double</span> <span class="title">getPayAmount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">double</span> result;</span><br><span class="line">   <span class="keyword">if</span> (_isDead) result = deadAmount();</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (_isSeparated) result = separatedAmount();</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (_isRetired) result = retiredAmount();</span><br><span class="line">           <span class="keyword">else</span> result = normalPayAmount();</span><br><span class="line">       &#125;;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//======================after refactoring=========================</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">double</span> <span class="title">getPayAmount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (_isDead) <span class="keyword">return</span> deadAmount();</span><br><span class="line">   <span class="keyword">if</span> (_isSeparated) <span class="keyword">return</span> separatedAmount();</span><br><span class="line">   <span class="keyword">if</span> (_isRetired) <span class="keyword">return</span> retiredAmount();</span><br><span class="line">   <span class="keyword">return</span> normalPayAmount();</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p><strong>什么是卫语句？</strong></p>
<p>如果某个条件极其罕见，就应该单独检查该条件，并在该条件为真时立刻从函数中返回。<br>这样的单独检查常常被称为【卫语句（guard clauses）】</p>
<p><strong>重构的原因？</strong></p>
<p>如果使用if-then-else 结构，你对if 分支和else 分支的重视是同等的。 这样的代码结构传递给阅读者的消息就是：各个分支有同样的重要性。卫语句（guard clauses）就不同了，它告诉阅读者：【这种情况很罕见，如果它真的发生了，请做 一些必要的整理工作，然后退出。】</p>
<h2 id="Replace-Conditional-with-Polymorphism（以多态取代条件式）"><a href="#Replace-Conditional-with-Polymorphism（以多态取代条件式）" class="headerlink" title="Replace Conditional with Polymorphism（以多态取代条件式）"></a>Replace Conditional with Polymorphism（以多态取代条件式）</h2><p>problem:你手上有个条件式，它根据对象型别的不同而选择不同的行为。<br>solution:将这个条件式的每个分支放进一个subclass内的覆写函数中，然后将原始函数声明为抽象函数（abstract method）。</p>
<blockquote>
<p>该手法在Replace Type Code with State/Strategy中已经使用到。</p>
</blockquote>
<p><strong>重构的原因？</strong></p>
<p>如果你需要根据对象的不同型别而采取不同的行为，多态使你不必编写明显的条件式</p>
<h2 id="Introduce-Null-Object（引入Null对象）"><a href="#Introduce-Null-Object（引入Null对象）" class="headerlink" title="Introduce Null Object（引入Null对象）"></a>Introduce Null Object（引入Null对象）</h2><p>你需要再三检查【某物是否为null value】。<br>将null value（无效值）替换为null object（无效物）。</p>
<p><strong>重构的原因？</strong></p>
<p>你不必再向对象询问「你是什么型别」 而后根据得到的答案调用对象的某个行为——你只管调用该行为就是了，其他的一切多态机制会为你安排妥当。<br>Null Object中需要对所有的行为都作出相应的响应，才不再需要作Null的判断。</p>
]]></content>
      <categories>
        <category>重构 学习笔记</category>
      </categories>
      <tags>
        <tag>重构</tag>
        <tag>条件表达式重构</tag>
      </tags>
  </entry>
  <entry>
    <title>11 处理泛化关系</title>
    <url>/2019/01/15/refactoring/11%20%E5%A4%84%E7%90%86%E6%B3%9B%E5%8C%96%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h1 id="处理泛化关系"><a href="#处理泛化关系" class="headerlink" title="处理泛化关系"></a>处理泛化关系</h1><h2 id="Pull-Up-Field（字段上移）"><a href="#Pull-Up-Field（字段上移）" class="headerlink" title="Pull Up Field（字段上移）"></a>Pull Up Field（字段上移）</h2><p>problem:两个类有相同的字段<br>solution:从子类中删除该字段并将其移动到超类</p>
<p><img src="/2019/01/15/refactoring/11 处理泛化关系/1.png" alt=""></p>
<p><strong>重构原因？</strong></p>
<p>子类分别增长和开发，导致出现相同（或几乎相同）的字段和方法</p>
<h2 id="Pull-Up-Method（方法上移）"><a href="#Pull-Up-Method（方法上移）" class="headerlink" title="Pull Up Method（方法上移）"></a>Pull Up Method（方法上移）</h2><p>problem:子类具有执行类似工作的方法<br>solution:使方法相同，然后将它们移动到相关的超类</p>
<p><img src="/2019/01/15/refactoring/11 处理泛化关系/2.png" alt=""></p>
<p><strong>重构原因？</strong></p>
<p>子类彼此独立地增长和发展，导致相同（或几乎相同）的字段和方法。</p>
<h2 id="Pull-Up-Constructor-Body（构造函数本地上移）"><a href="#Pull-Up-Constructor-Body（构造函数本地上移）" class="headerlink" title="Pull Up Constructor Body（构造函数本地上移）"></a>Pull Up Constructor Body（构造函数本地上移）</h2><p>problem:所有子类具有的构造函数代码大部分相同。<br>solution:创建一个超类构造函数，并将子类中相同的代码移动到它。在子类构造函数中调用超类构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name, String id, <span class="keyword">int</span> grade)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">this</span>.grade = grade;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//======================after refactoring=========================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name, String id, <span class="keyword">int</span> grade)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name, id);</span><br><span class="line">    <span class="keyword">this</span>.grade = grade;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>重构原因？</strong></p>
<p>子类构造器会隐式调用父类的默认构造，如果父类没有默认构造器，需要显示调用。<br>因此我们可以把子类中共有的初始化代码移到父类构造器中。</p>
<h2 id="Push-Down-Method（方法下移）"><a href="#Push-Down-Method（方法下移）" class="headerlink" title="Push Down Method（方法下移）"></a>Push Down Method（方法下移）</h2><p>problem:在父类中实现的方法只被一个（或少数几个）子类使用<br>solution:将这些方法移到子类中。</p>
<p><strong>重构原因？</strong></p>
<p>当初父类设计的通用方法实际上只被一个（少数几个）子类所使用</p>
<h2 id="Push-Down-Field（字段下移）"><a href="#Push-Down-Field（字段下移）" class="headerlink" title="Push Down Field（字段下移）"></a>Push Down Field（字段下移）</h2><p>problem:在父类中的字段只被一个（或少数几个）子类使用<br>solution:将这些字段移到子类中。</p>
<p><strong>重构原因？</strong></p>
<p>当初父类设计的通用字段实际上只被一个（少数几个）子类所使用</p>
<blockquote>
<p>上面的一些重构手法让人感觉有些冲突，实际上何时采用何种手法，并没有明确的界限去规定，根据自己的感觉去判断通用性。</p>
</blockquote>
<blockquote>
<p>下面这些方法感觉彼此冲突，界限不明确，实用性暂时不高，暂时不分析，这里仅仅提供定义。</p>
</blockquote>
<h2 id="Extract-Subclass"><a href="#Extract-Subclass" class="headerlink" title="Extract Subclass"></a>Extract Subclass</h2><p>Problem: 一个类的特性仅仅在某些条件下被使用<br>Solution: 将这些特性移到子类中</p>
<h2 id="Extract-Superclass"><a href="#Extract-Superclass" class="headerlink" title="Extract Superclass"></a>Extract Superclass</h2><p>Problem: 两个类有基本相同的字段和函数<br>Solution: 创建一个父类，把相同的字段和函数移进去</p>
<h2 id="Extract-Interface"><a href="#Extract-Interface" class="headerlink" title="Extract Interface"></a>Extract Interface</h2><p>Problem: 多个客户端使用类接口的相同部分。另一种情况：两个类中的部分接口是相同的<br>Solution: 将此相同部分移动到其自己的接口</p>
<h2 id="Collapse-Hierarchy"><a href="#Collapse-Hierarchy" class="headerlink" title="Collapse Hierarchy"></a>Collapse Hierarchy</h2><p>Problem: 有一个类层次结构，其子类实际上与其超类相同<br>Solution: 合并子类和超类</p>
<h2 id="Form-Template-method"><a href="#Form-Template-method" class="headerlink" title="Form Template method"></a>Form Template method</h2><p>Problem:子类实现的算法包含相同顺序的类似步骤<br>Solution:将算法结构和相同的步骤移动到超类，并在子类中保留不同步骤的实现</p>
<h2 id="Replace-Inheritance-with-Delegation"><a href="#Replace-Inheritance-with-Delegation" class="headerlink" title="Replace Inheritance with Delegation"></a>Replace Inheritance with Delegation</h2><p>Problem: 有一个仅使用其超类的一部分方法的子类（或者它不可能继承超类数据）<br>Solution: 创建一个字段并在其中放置一个超类对象，将方法委托给超类对象，并取消继承</p>
<h2 id="Replace-Delegation-with-Inheritance"><a href="#Replace-Delegation-with-Inheritance" class="headerlink" title="Replace Delegation with Inheritance"></a>Replace Delegation with Inheritance</h2><p>Problem:一个类包含许多简单的方法，这些方法委托给另一个类的所有方法<br>Solution:使该类成为委托继承者，这使得委托方法变得不必要</p>
]]></content>
      <categories>
        <category>重构 学习笔记</category>
      </categories>
      <tags>
        <tag>重构</tag>
        <tag>处理泛化关系</tag>
      </tags>
  </entry>
  <entry>
    <title>10 对函数调用重构</title>
    <url>/2019/01/15/refactoring/10%20%E5%AF%B9%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E9%87%8D%E6%9E%84/</url>
    <content><![CDATA[<h1 id="对函数调用重构"><a href="#对函数调用重构" class="headerlink" title="对函数调用重构"></a>对函数调用重构</h1><h2 id="Rename-Method（函数改名）"><a href="#Rename-Method（函数改名）" class="headerlink" title="Rename Method（函数改名）"></a>Rename Method（函数改名）</h2><p>problem:函数的命名不能解释这个函数做什么<br>solution:重命名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getsnm()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//======================after refactoring=========================</span></span><br><span class="line"></span><br><span class="line">getSecondName()&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>重构原因？</strong></p>
<ol>
<li>第一次创建方法太匆忙以至于没有很好地命名</li>
<li>随着功能的增加，函数名不足以很好的描述。</li>
</ol>
<h2 id="Add-Parameter（增加参数）"><a href="#Add-Parameter（增加参数）" class="headerlink" title="Add Parameter（增加参数）"></a>Add Parameter（增加参数）</h2><p>problem:方法没有足够的数据来执行某些操作。<br>solution:创建一个新参数以传递必要的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getContact();</span><br><span class="line"></span><br><span class="line"><span class="comment">//======================after refactoring=========================</span></span><br><span class="line"></span><br><span class="line">getContact(Date);</span><br></pre></td></tr></table></figure>
<p><strong>重构原因？</strong></p>
<p>函数需要新的数据来工作，相比增加一个私有字段，使用参数来传递数据更加合适。</p>
<h2 id="Remove-Parameter（移除参数）"><a href="#Remove-Parameter（移除参数）" class="headerlink" title="Remove Parameter（移除参数）"></a>Remove Parameter（移除参数）</h2><p>problem:参数未在方法体中使用。<br>solution:删除未使用的参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getContact(Date);</span><br><span class="line"></span><br><span class="line"><span class="comment">//======================after refactoring=========================</span></span><br><span class="line"></span><br><span class="line">getContact();</span><br></pre></td></tr></table></figure>
<p><strong>重构原因？</strong></p>
<p>删除没有被使用到的参数</p>
<h2 id="Separate-Query-from-Modifier（分离查询和修改）"><a href="#Separate-Query-from-Modifier（分离查询和修改）" class="headerlink" title="Separate Query from Modifier（分离查询和修改）"></a>Separate Query from Modifier（分离查询和修改）</h2><p>problem:一个函数既查询又修改<br>solution:将查询和修改的函数拆开</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getTotalOutstandingAndSetReadyForSummaries();</span><br><span class="line"></span><br><span class="line"><span class="comment">//======================after refactoring=========================</span></span><br><span class="line"></span><br><span class="line">getTotalOutstanding();</span><br><span class="line">setReadyForSummaries();</span><br></pre></td></tr></table></figure>
<p><strong>重构原因？</strong></p>
<p>让函数的功能更加明确</p>
<h2 id="Preserve-Whole-Object（传递整个对象）"><a href="#Preserve-Whole-Object（传递整个对象）" class="headerlink" title="Preserve Whole Object（传递整个对象）"></a>Preserve Whole Object（传递整个对象）</h2><p>problem:从对象获取多个值，然后将它们作为参数传递给方法。<br>solution:相反，尝试传递整个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> low = daysTempRange.getLow();</span><br><span class="line"><span class="keyword">int</span> high = daysTempRange.getHigh();</span><br><span class="line"><span class="keyword">boolean</span> withinPlan = plan.withinRange(low, high);</span><br><span class="line"></span><br><span class="line"><span class="comment">//======================after refactoring=========================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> withinPlan = plan.withinRange(daysTempRange);</span><br></pre></td></tr></table></figure>
<p><strong>重构原因？</strong></p>
<p>当方法需要增加参数的时候，不需要修改每个调用它的地方。</p>
<blockquote>
<p>改重构会导致该函数变得不够灵活，二思而后行。</p>
</blockquote>
<h2 id="Replace-Parameter-with-Method-Call（用方法的调用来代替参数）"><a href="#Replace-Parameter-with-Method-Call（用方法的调用来代替参数）" class="headerlink" title="Replace Parameter with Method Call（用方法的调用来代替参数）"></a>Replace Parameter with Method Call（用方法的调用来代替参数）</h2><p>problem:调用查询方法并将其结果作为另一个方法的参数传递，而后者可以直接调用查询。<br>solution:不要通过参数传递值，而是尝试在方法体内放置查询调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> basePrice = quantity * itemPrice;</span><br><span class="line"><span class="keyword">double</span> seasonDiscount = <span class="keyword">this</span>.getSeasonalDiscount();</span><br><span class="line"><span class="keyword">double</span> fees = <span class="keyword">this</span>.getFees();</span><br><span class="line"><span class="keyword">double</span> finalPrice = discountedPrice(basePrice, seasonDiscount, fees);</span><br><span class="line"></span><br><span class="line"><span class="comment">//======================after refactoring=========================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> basePrice = quantity * itemPrice;</span><br><span class="line"><span class="keyword">double</span> finalPrice = discountedPrice(basePrice);</span><br></pre></td></tr></table></figure>
<p><strong>重构原因？</strong></p>
<p>简化函数调用</p>
<blockquote>
<p>这种重构更多是考虑当下，而不是着眼未来。符合设计原则——you are’t not need it</p>
</blockquote>
<h2 id="Introduce-Parameter-Object（引入参数对象）"><a href="#Introduce-Parameter-Object（引入参数对象）" class="headerlink" title="Introduce Parameter Object（引入参数对象）"></a>Introduce Parameter Object（引入参数对象）</h2><p>problem:方法包含重复的参数组。<br>solution:用对象替换这些参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fun1(Date start,Date end);</span><br><span class="line">fun2(Date start,Date end);</span><br><span class="line">fun2(Date start,Date end);</span><br><span class="line"></span><br><span class="line"><span class="comment">//======================after refactoring=========================</span></span><br><span class="line"></span><br><span class="line">fun1(DateRange date);</span><br><span class="line">fun2(DateRange date);</span><br><span class="line">fun2(DateRange date);</span><br></pre></td></tr></table></figure>
<p><strong>重构原因？</strong></p>
<p>多次使用同一组参数列表<br>日后可能还可以对这个重构对象增加一些行为。</p>
<h2 id="Remove-Setting-Method（移除setter方法）"><a href="#Remove-Setting-Method（移除setter方法）" class="headerlink" title="Remove Setting Method（移除setter方法）"></a>Remove Setting Method（移除setter方法）</h2><p>problem:字段的值只应在创建时设置，并且在此之后不能随时更改。<br>solution:删除设置字段值的方法。</p>
<h2 id="Hide-Method（隐藏方法）"><a href="#Hide-Method（隐藏方法）" class="headerlink" title="Hide Method（隐藏方法）"></a>Hide Method（隐藏方法）</h2><p>problem:其他类不使用方法，或仅在其自己的类层次结构中使用该方法。<br>solution:使方法成为私有或受保护。</p>
<p><strong>重构原因？</strong></p>
<p>只让其它类看到具有完整功能的函数，至于如何实现这个函数的过程，不应该暴露出去。</p>
<h2 id="Replace-Constructor-with-Factory-Method（使用简单工厂代替构造器）"><a href="#Replace-Constructor-with-Factory-Method（使用简单工厂代替构造器）" class="headerlink" title="Replace Constructor with Factory Method（使用简单工厂代替构造器）"></a>Replace Constructor with Factory Method（使用简单工厂代替构造器）</h2><p>problem:有一个复杂的构造函数，它不仅仅在对象字段中设置参数值。<br>solution:使用简单工厂来替换构造函数调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  Employee(<span class="keyword">int</span> type) &#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//======================after refactoring=========================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Employee <span class="title">create</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    employee = <span class="keyword">new</span> Employee(type);</span><br><span class="line">    <span class="comment">// do some heavy lifting.</span></span><br><span class="line">    <span class="keyword">return</span> employee;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>重构原因？</strong></p>
<p>使用简单工厂可以再创建对象的同时做更多的事情：</p>
<ol>
<li>可以选择性的创建并返回子类对象</li>
<li>可以返回一个已经存在的对象（单例）</li>
<li>可以对解耦new关键字</li>
</ol>
<h2 id="Replace-Error-Code-with-Exception（用异常代替错误码）"><a href="#Replace-Error-Code-with-Exception（用异常代替错误码）" class="headerlink" title="Replace Error Code with Exception（用异常代替错误码）"></a>Replace Error Code with Exception（用异常代替错误码）</h2><p>problem:方法返回一个指示错误的特殊值<br>solution:应该抛出异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (amount &gt; _balance) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    balance -= amount;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//======================after refactoring=========================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> amount)</span> <span class="keyword">throws</span> BalanceException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (amount &gt; _balance) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BalanceException();</span><br><span class="line">  &#125;</span><br><span class="line">  balance -= amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>重构原因？</strong></p>
<p>异常的出现就是解决不断地校验错误码来辨认调用成功还是失败的繁琐工作</p>
]]></content>
      <categories>
        <category>重构 学习笔记</category>
      </categories>
      <tags>
        <tag>重构</tag>
        <tag>对函数调用重构</tag>
      </tags>
  </entry>
  <entry>
    <title>04 处理器体系结构</title>
    <url>/2019/05/13/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/04%20%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="处理器体系结构"><a href="#处理器体系结构" class="headerlink" title="处理器体系结构"></a>处理器体系结构</h1><p>本节简单的介绍处理器的工作方式</p>
<blockquote>
<p>由于本章节比较接近底层，因此只大致的说明说了些什么内容</p>
</blockquote>
<h2 id="Y86-64指令集体系结构"><a href="#Y86-64指令集体系结构" class="headerlink" title="Y86-64指令集体系结构"></a>Y86-64指令集体系结构</h2><p>Y86指令是不存在的，本书的作者受到IA32指令，也就是“x86”的启发，所假想出来的一种处理器体系结构<br>与 “x86” 相比，Y86指令集的数据类型、指令和寻址方式都要少一些，字节级编码也比较简单。但是它仍然足够完整，能够写一些简单的处理证书的程序，而设计一个Y86处理器要求我们面对许多处理器设计者同样面临的问题。</p>
<p><strong>什么是指令集体系结构？</strong></p>
<p>一个处理器支持的指令和指令的字节编码，称为<em>指令集体系结构（ISA）</em></p>
<p>每条指令都会读取和修改处理器状态的某些部分，被称为<em>程序员可见状态</em></p>
<p><img src="/2019/05/13/系统原理/04 处理器体系结构/01.png" alt="程序员可见状态"></p>
<p>Y86指令集有哪些？<br>指令如何编码？<br>如何使用操作数以及操作数如何编码？<br>状态码Stat有什么用？<br>以”.”开头的词有什么作用？<br>pushq %rsp的特殊性？</p>
<h2 id="逻辑设计和硬件控制语言HCL"><a href="#逻辑设计和硬件控制语言HCL" class="headerlink" title="逻辑设计和硬件控制语言HCL"></a>逻辑设计和硬件控制语言HCL</h2><p>硬件控制语言HCL有什么用？<br>什么是逻辑门？<br>什么是组合电路？<br>如何使用HCL？<br>什么是“字”和“情况表达式”？如何用HCL表示？<br>什么是集合关系？如何用HCL表示？</p>
<h2 id="寄存器和时钟"><a href="#寄存器和时钟" class="headerlink" title="寄存器和时钟"></a>寄存器和时钟</h2><p>什么是时钟？有什么作用？<br>（额外）什么是触发器和锁存器？<br>什么是时钟寄存器？有什么作用？<br>时钟寄存器和随机访问存储器的区别？<br>硬件寄存器和程序寄存器的区别？</p>
<h2 id="Y86-64的顺序-SEQ-实现"><a href="#Y86-64的顺序-SEQ-实现" class="headerlink" title="Y86-64的顺序(SEQ)实现"></a>Y86-64的顺序(SEQ)实现</h2><p><strong>处理器顺序执行一条指令会经历哪些阶段？</strong></p>
<p>取指、译码、执行、访存、回写</p>
<p><strong>每个阶段都处理什么问题？</strong></p>
<ul>
<li>取指：获取指令</li>
<li>译码：获取指令中的寄存器的值</li>
<li>执行：执行各个逻辑单元</li>
<li>访存：访存内存，读写内存</li>
<li>回写：写入寄存器</li>
</ul>
<p>具体的各种案例（OPq,rrmovq,irmovq,pushq,popq,jxx,call,ret）</p>
<p><strong>时钟控制下周期执行的处理器上如何实现顺序？</strong></p>
<p>硬件下各位阶段是同时进行的<br>但是每个阶段产生的结果会作为信号提供给后续阶段使用<br>直到所有阶段达到一个稳定的状态<br>时钟上升，所有的结果被写入中<br>因此，一个时钟周期实现一条指令</p>
<p><strong>哪些结果需要被时钟控制？</strong></p>
<p>需要被后续指令用到的结果：<br>程序计数器，条件码，寄存器，内存</p>
<p>各阶段如何用HCL表示？<br>SEQ的缺陷？</p>
<h2 id="流水线的通用原理"><a href="#流水线的通用原理" class="headerlink" title="流水线的通用原理"></a>流水线的通用原理</h2><p>如何理解流水线？流水线的优点？<br>如何从硬件上实现流水线？<br>流水线的局限？</p>
<p><strong>什么是反馈？</strong></p>
<p>当前指令的结果被后续指令使用</p>
<p>流水线反馈的难题？</p>
<h2 id="Y86-64的流水线实现"><a href="#Y86-64的流水线实现" class="headerlink" title="Y86-64的流水线实现"></a>Y86-64的流水线实现</h2>]]></content>
      <categories>
        <category>计算机系统原理</category>
      </categories>
      <tags>
        <tag>计算机系统原理</tag>
        <tag>处理器体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>05 优化程序性能</title>
    <url>/2019/05/14/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/05%20%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<h1 id="优化程序性能"><a href="#优化程序性能" class="headerlink" title="优化程序性能"></a>优化程序性能</h1><p>程序的目标：</p>
<ol>
<li>清晰简洁</li>
<li>高性能</li>
</ol>
<p>高性能的手段：</p>
<ol>
<li>适当的算法和数据结构</li>
<li>编写易让编译器优化的代码</li>
<li>多线程</li>
</ol>
<p>本章的核心是：</p>
<ol>
<li>编写易让编译器优化的代码</li>
<li>结合处理器来优化代码的执行</li>
</ol>
<h2 id="优化编译器的能力和局限性"><a href="#优化编译器的能力和局限性" class="headerlink" title="优化编译器的能力和局限性"></a>优化编译器的能力和局限性</h2><p><strong>哪些编码方式是编译器不好优化的？</strong></p>
<ol>
<li><code>内存别名使用</code>：编译器无法判断不同的指针是否会指向内存的同一个位置</li>
</ol>
<p>代码案例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void twiddle1(long *xp, long *yp)&#123;</span><br><span class="line">  *xp += *yp;</span><br><span class="line">  *xp += *yp;</span><br><span class="line">&#125;</span><br><span class="line">void twiddle2(long *xp, long *yp)&#123;</span><br><span class="line">  *xp += 2 * *yp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li><code>函数调用</code>：编译器无法判断函数是否存在副作用，如修改了全局变量</li>
</ol>
<p>代码案例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long func();</span><br><span class="line">long func1()&#123;</span><br><span class="line">  return f() + f() + f() + f();</span><br><span class="line">&#125;</span><br><span class="line">long func2()&#123;</span><br><span class="line">  return 4*f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="表示程序性能"><a href="#表示程序性能" class="headerlink" title="表示程序性能"></a>表示程序性能</h2><p>如何衡量程序的性能？什么是<code>每元素的周期数（CPE）</code>？</p>
<p>使用<code>每元素的周期数（CPE）</code>衡量，“元素”理解为需要被处理的数据量。<br><code>每元素的周期数（CPE）</code>理解为处理元素所需的时钟周期</p>
<p><img src="/2019/05/14/系统原理/05 优化程序性能/01.png" alt="每元素的周期数（CPE）"></p>
<p>上图中的斜率就是<code>每元素的周期数（CPE）</code></p>
<p>什么是<code>最小二乘拟合</code>，有什么用？</p>
<p><img src="/2019/05/14/系统原理/05 优化程序性能/02.png" alt="最小二乘拟合"></p>
<h2 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h2><p>示例代码：合并运算</p>
<p><img src="/2019/05/14/系统原理/05 优化程序性能/03.png" alt="合并运算"></p>
<p>优化级别对性能的影响</p>
<p><img src="/2019/05/14/系统原理/05 优化程序性能/04.png" alt="优化级别"></p>
<h2 id="消除循环的低效率"><a href="#消除循环的低效率" class="headerlink" title="消除循环的低效率"></a>消除循环的低效率</h2><p>循环中的低效代码？如何优化？</p>
<p>对上述的示例代码<br>循环中反复调用了一个结果不变得函数</p>
<p>改进：</p>
<p><img src="/2019/05/14/系统原理/05 优化程序性能/05.png" alt="消除循环的低效率"></p>
<p>编译器为何不自动优化？</p>
<p>受<code>函数调用的副作用</code>影响</p>
<h2 id="消除不必要的寄存器消耗"><a href="#消除不必要的寄存器消耗" class="headerlink" title="消除不必要的寄存器消耗"></a>消除不必要的寄存器消耗</h2><p>哪些代码会造成不必要的寄存器消耗？如何优化？</p>
<p>上述案例代码中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*dest = *dest OP val</span><br></pre></td></tr></table></figure>
<p>*dest的结果没有任何作用</p>
<p>但是却造成了寄存器的额外消耗</p>
<p>改进：</p>
<p><img src="/2019/05/14/系统原理/05 优化程序性能/06.png" alt="消除不必要的寄存器消耗"></p>
<p>编译器为何不自动优化？</p>
<p>受<code>内存别名使用</code>的影响</p>
<h2 id="理解现代处理器"><a href="#理解现代处理器" class="headerlink" title="理解现代处理器"></a>理解现代处理器</h2><p>剩下的章节内容：</p>
<ol>
<li>了解现代处理器的乱序执行</li>
<li>利用乱序、并行提高程序性能</li>
</ol>
]]></content>
      <categories>
        <category>计算机系统原理</category>
      </categories>
      <tags>
        <tag>计算机系统原理</tag>
        <tag>优化程序性能</tag>
      </tags>
  </entry>
  <entry>
    <title>06 存储器层次结构</title>
    <url>/2019/05/16/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/06%20%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h1><p>本章的核心是：</p>
<ol>
<li>一些常见的存储技术</li>
<li>存储器的层次结构</li>
<li>高速缓存的工作原理</li>
<li>结合高速缓存，提高程序的<code>局部性</code></li>
</ol>
<h2 id="存储技术"><a href="#存储技术" class="headerlink" title="存储技术"></a>存储技术</h2><p><strong>有哪些与时俱进的存储技术？</strong></p>
<ol>
<li>SRAM：六晶体管电路，只要有电，就永远保持它的值。受干扰影响小。</li>
<li><p>DRAM：电容，易受干扰。</p>
<p><img src="/2019/05/16/系统原理/06 存储器层次结构/02.png" alt="SRAM和DRAM对比"></p>
</li>
<li><p>传统的DRAM</p>
<p><img src="/2019/05/16/系统原理/06 存储器层次结构/03.png" alt="传统的DRAM"></p>
<p>每个超单元都有w个DRAM单元</p>
<p><img src="/2019/05/16/系统原理/06 存储器层次结构/04.png" alt="传统的DRAM"></p>
</li>
<li><p>内存模块</p>
<p><img src="/2019/05/16/系统原理/06 存储器层次结构/05.png" alt="传统的DRAM"></p>
</li>
<li><p>增强的DRAM：对传统的DRAM进行优化，提高访问速度</p>
</li>
<li>非易失性存储器（历史原因，也叫ROM）:断电依然保存信息<ul>
<li>PROM（可编程ROM）：高电流熔断，只可编程一次</li>
<li>EPROM（可擦可编程ROM）：紫外光编程，可编程1000次</li>
<li>EEPROM（电子可擦除ROM）：无需要独立的特殊设备，可编程100000次</li>
<li>闪存：基于EEPROM</li>
</ul>
</li>
</ol>
<p><strong>ROM有什么用？</strong></p>
<p>存放在ROM中的程序被称为<code>固件</code>，比如PC的BIOS程序<br>当计算机通电以后，它会运行ROM中的固件</p>
<p><strong>如何访问主存？</strong></p>
<p>通过总线</p>
<p><img src="/2019/05/16/系统原理/06 存储器层次结构/06.png" alt="总线结构"></p>
<p>I/O桥把系统总线的电子信号翻译成内存总线的电子信号</p>
<p><img src="/2019/05/16/系统原理/06 存储器层次结构/07.png" alt="读内存"></p>
<p><strong>磁盘的构造？磁盘的容量？</strong></p>
<p>使用磁性记录材料来记录信息</p>
<p><img src="/2019/05/16/系统原理/06 存储器层次结构/08.png" alt="磁盘构造"></p>
<p><img src="/2019/05/16/系统原理/06 存储器层次结构/09.png" alt="磁盘容量"></p>
<p><strong>如何操作磁盘？如何连接磁盘？如何访问磁盘？</strong></p>
<p><img src="/2019/05/16/系统原理/06 存储器层次结构/10.png" alt="操作磁盘"></p>
<p>为了对操作系统隐藏这样的复杂性，根据扇区定义<code>逻辑块</code><br>磁盘控制器维护逻辑块号和实际磁盘扇区之间的映射关系</p>
<p>通过I/O总线连接磁盘：</p>
<p><img src="/2019/05/16/系统原理/06 存储器层次结构/11.png" alt="连接磁盘"></p>
<p><img src="/2019/05/16/系统原理/06 存储器层次结构/12.png" alt="访问磁盘"></p>
<p><strong>什么是<code>直接内存访问（DMA）</code>？</strong></p>
<p>设备自己执行读和写总线事务，不需要CPU干涉，称为直接内存访问</p>
<p><strong>固态硬盘的结构？</strong></p>
<p><img src="/2019/05/16/系统原理/06 存储器层次结构/13.png" alt="固态硬盘"></p>
<p>存储技术的趋势？</p>
<p><img src="/2019/05/16/系统原理/06 存储器层次结构/14.png" alt="存储技术的趋势"></p>
<p>现代计算机频繁使用高速缓存来弥补处理器-内存之间的差距<br>程序的局部性能使高速缓存的作用发挥到极致</p>
<h2 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h2><p><strong>什么是局部性？</strong></p>
<ul>
<li>时间局部性：被引用过一次的内存地址，在不久之后多次被引用</li>
<li>空间局部性：被引用过一次的内存地址，在不久之后其附近的位置多次被引用</li>
</ul>
<p><strong>如何简单的运用局部性？</strong></p>
<ul>
<li>重复引用相同的变量具有良好的时间局部性</li>
<li>迭代数组的步长越小，空间局部性越好</li>
<li>循环体具有良好的时间和空间局部性</li>
</ul>
<h2 id="存储器层次结构-1"><a href="#存储器层次结构-1" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h2><p><img src="/2019/05/16/系统原理/06 存储器层次结构/01.png" alt="存储器层次结构"></p>
<p><strong>缓存的基本原理？</strong></p>
<p><img src="/2019/05/16/系统原理/06 存储器层次结构/15.png" alt="存储器层次结构"></p>
<p>层与层之间以相同大小的数据块进行传输<br>不同层之间的块的大小是不一样的</p>
<p><strong>缓存的命中和不命中？</strong></p>
<p>找到了就是命中，没找到就是不命中<br>不命中的情况下需要决定替换块的<code>替换策略</code></p>
<p><strong>不命中的类型？</strong></p>
<ul>
<li>冷缓存：初始状态，什么缓存都没</li>
<li>冲突不命中：请求的缓存交替的发生在相同位置的块上</li>
<li>容量不命中：缓存太小了</li>
</ul>
<p><strong>缓存的管理？</strong></p>
<p>块的划分、块的传送、命中判定、替换策略等等</p>
<p><img src="/2019/05/16/系统原理/06 存储器层次结构/16.png" alt="缓存"></p>
<p>逐步从直接访问变为间接访问</p>
<h2 id="高速缓存存储器"><a href="#高速缓存存储器" class="headerlink" title="高速缓存存储器"></a>高速缓存存储器</h2><p><img src="/2019/05/16/系统原理/06 存储器层次结构/17.png" alt="高速缓存存储器"></p>
<p><strong>如何缓存（如何映射）？</strong></p>
<p>缓存的位置都是根据地址计算得到</p>
<p><img src="/2019/05/16/系统原理/06 存储器层次结构/18.png" alt="缓存的通用原理"></p>
<p>高速缓存的结构可以用元祖（S，E，B，m）描述</p>
<p><strong>缓存类别有？</strong></p>
<ol>
<li><p>直接映射高速缓存</p>
<p>每组只有一行，替换策略简单，冲突不命中易发生</p>
<p><img src="/2019/05/16/系统原理/06 存储器层次结构/19.png" alt="直接映射高速缓存"></p>
</li>
<li><p>组相联高速缓存</p>
<p>每组有多行，最简单的替换策略是随机替换</p>
<p><img src="/2019/05/16/系统原理/06 存储器层次结构/20.png" alt="组相联高速缓存"></p>
</li>
<li><p>全组高速缓存</p>
</li>
</ol>
<p>  <img src="/2019/05/16/系统原理/06 存储器层次结构/21.png" alt="全组高速缓存"></p>
<p><strong>命中如何更新缓存？</strong></p>
<ol>
<li>直写：立即向低层更新数据</li>
<li>写回：等待缓存被替换时才 向低层更新数据</li>
</ol>
<p><strong>不命中如何更新缓存？</strong></p>
<ol>
<li>写分配：先加载到高速缓存中</li>
<li>非写分配：直接更新，避开高速缓存</li>
</ol>
<p><strong>真实的缓存层次结构？</strong></p>
<p><img src="/2019/05/16/系统原理/06 存储器层次结构/22.png" alt="真实的缓存层次结构？"></p>
<p><strong>如何衡量缓存性能？</strong></p>
<ol>
<li>不命中率：不命中数量/引用数量</li>
<li>命中率：</li>
<li>命中时间：命中需要的时间</li>
<li>不命中处罚：不命中需要的额外时间</li>
</ol>
<h2 id="编写高速缓存友好的代码"><a href="#编写高速缓存友好的代码" class="headerlink" title="编写高速缓存友好的代码"></a>编写高速缓存友好的代码</h2><p><strong>确保代码高速缓存友好的方式是？</strong></p>
<ol>
<li>把时间花在核心函数中</li>
<li>尽量减少每个循环内部的缓存不命中率</li>
</ol>
<p>空间局部性和缓存大小有直接关系</p>
<p><strong>对<code>存储器山</code>如何分析？</strong></p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%B1" target="_blank" rel="noopener">维基百科：存储器山</a></p>
]]></content>
      <categories>
        <category>计算机系统原理</category>
      </categories>
      <tags>
        <tag>计算机系统原理</tag>
        <tag>存储器层次结构</tag>
      </tags>
  </entry>
  <entry>
    <title>11网络编程</title>
    <url>/2019/09/12/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/11%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p>本章的核心内容：socket编程</p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>关于网络的基本概念可以跳转到：<a href="https://sunyi720.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/">计算机网络</a></p>
<h2 id="套接字接口"><a href="#套接字接口" class="headerlink" title="套接字接口"></a>套接字接口</h2><p><strong>套接字接口有什么用？</strong></p>
<p>套接字接口是一组函数，和Unix IO函数结合起来，用以创建网络应用</p>
<p><img src="/2019/09/12/系统原理/11网络编程/01.png" alt="套接字接口"></p>
<p><strong>如何使套接字结构地址适用所有协议？</strong></p>
<p><img src="/2019/09/12/系统原理/11网络编程/02.png" alt="套接字地址结构"></p>
<p>将特定协议的套接字结构地址强转成通用的套接字结构地址使用</p>
<p>相关接口：</p>
<ul>
<li>socket() 创建一个新的确定类型的套接字，类型用一个整型数值标识（文件描述符），并为它分配系统资源。</li>
<li>bind() 一般用于服务器端，将一个套接字与一个套接字地址结构相关联，比如，一个指定的本地端口和IP地址。</li>
<li>listen() 用于服务器端，使一个绑定的TCP套接字的tcp状态由CLOSE转至LISTEN；操作系统内核为此监听socket所对应的tcp服务器建立一个pending socket队列和一个established socket队列；参数backlog指定pending socket队列的长度，0表示长度可以无限大。pending socket，就是某客户端三次握手的syn包到达，内核为这个syn包对应的tcp请求生成一个socket（状态为SYN_RECV），但三次握手还没有完成时的socket。</li>
<li>connect() 用于客户端，为一个套接字分配一个自由的本地端口号。 如果是TCP套接字的话，它会试图获得一个新的TCP连接。</li>
<li>accept() 用于服务器端。 它接受一个从远端客户端发出的创建一个新的TCP连接的接入请求，创建一个新的套接字，与该连接相应的套接字地址相关联。</li>
</ul>
<p><strong>为什么要区分监听描述符和已连接描述符？</strong></p>
<p>实现并发服务</p>
<p><strong>getaddinfo函数有什么意义？</strong></p>
<p><img src="/2019/09/12/系统原理/11网络编程/03.png" alt="getaddinfo"></p>
<p><img src="/2019/09/12/系统原理/11网络编程/04.png" alt="addrinfo数据结构"></p>
<p><img src="/2019/09/12/系统原理/11网络编程/05.png" alt="addrinfo数据结构"></p>
<p>IPv4中使用gethostbyname()函数完成主机名到地址解析，这个函数仅仅支持IPv4，<br>且不允许调用者指定所需地址类型的任何信息，返回的结构只包含了用于存储IPv4地址的空间。<br>IPv6中引入了新的API getaddrinfo()，它是协议无关的，既可用于IPv4也可用于IPv6。<br>getaddrinfo() 函数能够处理名字到地址以及服务到端口这两种转换，返回的是一个 struct addrinfo 的结构体(列表)指针而不是一个地址清单。<br>这些 struct addrinfo 结构体随后可由套接口函数直接使用。如此以来，getaddrinfo()函数把协议相关性安全隐藏在这个库函数内部。<br>应用程序只要处理由getaddrinfo()函数填写的套接口地址结构。</p>
<blockquote>
<p>一个主机名可能对应多个地址</p>
</blockquote>
<p>简化getaddinfo函数的使用：</p>
<p><img src="/2019/09/12/系统原理/11网络编程/06.png" alt="简化getaddinfo函数的使用"></p>
<p><img src="/2019/09/12/系统原理/11网络编程/07.png" alt="简化getaddinfo函数的使用"></p>
<h2 id="综合：TINY-Web-服务器"><a href="#综合：TINY-Web-服务器" class="headerlink" title="综合：TINY Web 服务器"></a>综合：TINY Web 服务器</h2><p><strong>使用mmap和io读取文件区别？</strong></p>
<p>总结来说，常规文件操作为了提高读写效率和保护磁盘，使用了页缓存机制（读写同一个文件时采用同一个也缓存），这个缓存在内核虚拟空间中。</p>
<p>这样造成读文件时需要先将文件页从磁盘拷贝到页缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址，所以还需要将页缓存中数据页再次拷贝到内存对应的用户空间中。这样，通过了两次数据拷贝过程，才能完成进程对文件内容的获取任务。写操作也是一样，待写入的buffer在内核空间不能直接访问，必须要先拷贝至内核空间对应的主存，再写回磁盘中（延迟写回），也是需要两次数据拷贝。</p>
<p>而使用mmap操作文件中，创建新的虚拟内存区域和建立文件磁盘地址和虚拟内存区域映射这两步，没有任何文件拷贝操作。而之后访问数据时发现内存中并无数据而发起的缺页异常过程，可以通过已经建立好的映射关系，只使用一次数据拷贝，就从磁盘中将数据传入内存的用户空间中，供进程使用。</p>
<p>总而言之，常规文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝。而mmap操控文件，只需要从磁盘到用户主存的一次数据拷贝过程。说白了，mmap的关键点是实现了用户空间和内核空间的数据直接交互而省去了空间不同数据不通的繁琐过程。</p>
<p>因此，可以想象，在只访问一次的情况下，mmap效率更高。</p>
]]></content>
      <categories>
        <category>计算机系统原理</category>
      </categories>
      <tags>
        <tag>计算机系统原理</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>10系统级IO</title>
    <url>/2019/09/03/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/10%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/</url>
    <content><![CDATA[<h1 id="系统级IO"><a href="#系统级IO" class="headerlink" title="系统级IO"></a>系统级IO</h1><p>本章核心：<br>如何使用IO接口来统一的处理”主存”和”外部设备”的数据转换</p>
<p><strong>为什么要学习Unix I/O？</strong></p>
<ol>
<li>理解其他系统概念：譬如了解I/O和进程（fork）的关系</li>
<li>除了 Unix I/O 外 ，别无选择</li>
</ol>
<h2 id="UNIX-I-O"><a href="#UNIX-I-O" class="headerlink" title="UNIX I/O"></a>UNIX I/O</h2><p><strong>什么是文件</strong></p>
<p>一个Unix文件是一个字节序列，所有的外部IO设备（网络、磁盘、终端）都被映射为文件</p>
<p><strong>什么是Unix I/O？它的定义有什么意义？</strong></p>
<p>Unix I/O是内核提供一系列接口，使得对所有这些设备的访问都是以文件的方式的进行：</p>
<ul>
<li>打开文件：一个应用程序通过要求内核打开相应的文件，内核将返回一个非负整数，称为描述符，记录打开文件的所有信息：标准输入（描述符0）、标准输出（描述符1）、标准错误（描述符2）</li>
<li>改变当前文件位置：内核保持一个文件的位置k，初始为0，表示从文件开始处偏移的字节数。通过seek操作。</li>
<li>读写文件：读操作就是从文件拷贝n个字节到存储器，如果是从k处开始，就是拷贝k+n为止。文件的大小为m，如果k≥m就会触发（EOF），所有就不需要明确的EOF字符了。写操作就是从存储器拷贝n个字节到文件当前位置k处。</li>
<li>关闭文件：内核释放打开文件时创建的数据结构，释放所有的存储器资源。</li>
</ul>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p><strong>如何区分文件在系统中的角色？</strong></p>
<p>type:</p>
<ul>
<li>普通文件：可以分为文本文件和二进制文件。文本文件是只含有ASCII或Unicode的普通文件，其余是二进制文件。</li>
<li>目录：是包含一组链接的文件</li>
<li>套接字：用来与另一个进程进行跨网络通信的文件</li>
</ul>
<p><strong>文件和进程的关系？</strong></p>
<p>进程上下文中都有一个<em>当前工作目录</em></p>
<h2 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h2><p>打开文件：</p>
<p><img src="/2019/09/03/系统原理/10系统级IO/01.png" alt=""></p>
<ul>
<li>filename：是文件名</li>
<li>flags：访问方式，O_RDONLY|O_WRONLY|O_RDWR;</li>
<li>mode：访问权限</li>
</ul>
<p><img src="/2019/09/03/系统原理/10系统级IO/02.png" alt="访问权限"></p>
<p>关闭文件：</p>
<p><img src="/2019/09/03/系统原理/10系统级IO/03.png" alt="关闭文件"></p>
<h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><p>读和写文件：</p>
<p><img src="/2019/09/03/系统原理/10系统级IO/04.png" alt="关闭文件"></p>
<p><strong>什么是不足值？</strong></p>
<p>有时候传送的字节会比要求的少，实际上的传送字节就是不足值</p>
<p><strong>哪些情况会返回不足值？</strong></p>
<ol>
<li>遇到EOF</li>
<li>从终端读文本行，不足值等于输入的文本行</li>
<li>读写套接字，网络延迟导致</li>
</ol>
<p>实际上，除了EOF，当读写取磁盘文件时，将不会遇到不足值，容易出现不足值的情况往往出现在读写网络套接字的时候。</p>
<h2 id="RIO"><a href="#RIO" class="headerlink" title="RIO"></a>RIO</h2><p><strong>什么是RIO？有什么用？</strong></p>
<p>Robust健壮的:Unix IO的包装，增强其功能：</p>
<ol>
<li>处理除EOF和Error之外的不足值（通过不足时循环读写）</li>
<li>使用缓冲来增强读写性能（通过缓存）</li>
</ol>
<p>不带缓冲：</p>
<p><img src="/2019/09/03/系统原理/10系统级IO/04.png" alt="不带缓冲"></p>
<p>带缓冲：</p>
<p><img src="/2019/09/03/系统原理/10系统级IO/21.png" alt="带缓冲"></p>
<p>rio_t是一个结构体：</p>
<p><img src="/2019/09/03/系统原理/10系统级IO/06.png" alt="rio_t结构"></p>
<p>rio_readinitb是初始化：</p>
<p><img src="/2019/09/03/系统原理/10系统级IO/07.png" alt="rio_readinitb"></p>
<h2 id="读取文件的元数据"><a href="#读取文件的元数据" class="headerlink" title="读取文件的元数据"></a>读取文件的元数据</h2><p><strong>什么是元数据？</strong></p>
<p>文件元数据是指文件本身的一些信息，包含：访问模式、大小和创建时间：</p>
<p><img src="/2019/09/03/系统原理/10系统级IO/19.png" alt="元数据"></p>
<p><img src="/2019/09/03/系统原理/10系统级IO/08.png" alt="元数据"></p>
<p>可以通过以下指令来判断类型：</p>
<p><img src="/2019/09/03/系统原理/10系统级IO/09.png" alt="类型判断"></p>
<h2 id="读取目录内容"><a href="#读取目录内容" class="headerlink" title="读取目录内容"></a>读取目录内容</h2><p><img src="/2019/09/03/系统原理/10系统级IO/10.png" alt="打开目录"><br><img src="/2019/09/03/系统原理/10系统级IO/11.png" alt="遍历目录"><br><img src="/2019/09/03/系统原理/10系统级IO/12.png" alt="遍历结果结构体"><br><img src="/2019/09/03/系统原理/10系统级IO/13.png" alt="关闭目录文件资源"><br><img src="/2019/09/03/系统原理/10系统级IO/14.png" alt="案例"></p>
<h2 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h2><p><strong>系统如何记录打开的文件？</strong></p>
<p><img src="/2019/09/03/系统原理/10系统级IO/15.png" alt="文件的内核结构"></p>
<ul>
<li>描述符表：每个独立的进程1张，指向一打开的文件表；</li>
<li>文件表：包括打开文件位置，引用数量，以及一个指向元数据的v-node指针；</li>
<li>v-node表：包含stat结构的大部分信息；</li>
</ul>
<p><strong>文件是如何被共享的？</strong></p>
<p>如果共享文件位置（读写），则指向同一文件表项<br>如果只是共享同一文件，则指向不同文件表项，同一“v-node”表项</p>
<p><img src="/2019/09/03/系统原理/10系统级IO/16.png" alt="文件的共享"></p>
<p><strong>如何理解fork后的文件共享？</strong></p>
<p><img src="/2019/09/03/系统原理/10系统级IO/17.png" alt="父子进程表的共享文件"></p>
<h2 id="I-O重定向"><a href="#I-O重定向" class="headerlink" title="I/O重定向"></a>I/O重定向</h2><p><strong>什么是重定向？</strong></p>
<p>修改描述符表项的指向</p>
<p><img src="/2019/09/03/系统原理/10系统级IO/18.png" alt="父子进程表的共享文件"></p>
<p><strong>如何将磁盘文件和标准输入输出联系起来？</strong></p>
<p>dup2(4,1)<br>描述符1默认是标准输出，描述符4是其他文件</p>
<h2 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h2><p>标准IO是C提供的一套高级输入输出的函数</p>
<p>和RIO、Unix IO的对比</p>
<p>标准I/O是双工，因此在读写转换的时候需要修改文件位置</p>
<h2 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h2><p><img src="/2019/09/03/系统原理/10系统级IO/20.png" alt="IO"></p>
<p><strong>如何选择I/O包？</strong></p>
<p>尽可能使用标准IO</p>
<p>由于标准IO使用lseek来修改文件位置以实现双工，但是由于lseek对套接字是非法的，所以标准IO无法用于套接字IO</p>
]]></content>
      <categories>
        <category>计算机系统原理</category>
      </categories>
      <tags>
        <tag>计算机系统原理</tag>
        <tag>系统级IO</tag>
      </tags>
  </entry>
  <entry>
    <title>（一）JAVA内存区域与内存溢出异常</title>
    <url>/2019/09/29/JVM/%EF%BC%88%E4%B8%80%EF%BC%89JAVA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h1 id="JAVA内存区域与内存溢出异常"><a href="#JAVA内存区域与内存溢出异常" class="headerlink" title="JAVA内存区域与内存溢出异常"></a>JAVA内存区域与内存溢出异常</h1><p>本节主要介绍，</p>
<ol>
<li>JAVA虚拟机的运行时内存模型和功能</li>
<li>各个模型内存溢出的情形和处理</li>
</ol>
<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>JAVA程序要运行时，JVM中的内存区域如下：<br><img src="/2019/09/29/JVM/（一）JAVA内存区域与内存溢出异常/01.png" alt="JVM内存区域"></p>
<p><strong>这些区域都对应什么功能的空间？</strong></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p><strong>程序计数器有什么作用？</strong></p>
<p>当前线程所执行的字节码的行号指示器<br>循环、跳转、异常处理、线程恢复等基础功能都需要</p>
<p><strong>程序计数器在多线程中起什么作用？</strong></p>
<p>JAVA的多线程是通过线程轮流切换并分配处理器执行时间来实现的<br>任何时间，一个处理器内核只会执行一条程序指令<br>为了实现程序切换后能恢复到正常流程<br>每一个线程都需要一个独立的程序计数器<br>因此，程序计数器是<em>线程私用</em>的</p>
<p><strong>程序计数器会出现哪些错误？</strong></p>
<p>当执行native方式是值为空<br>是JVM内存中唯一不会出现OutOfMemoryError错误的</p>
<h3 id="JAVA虚拟机栈"><a href="#JAVA虚拟机栈" class="headerlink" title="JAVA虚拟机栈"></a>JAVA虚拟机栈</h3><p><strong>JAVA虚拟机栈有什么作用？</strong></p>
<p>描述JAVA方法执行的内存模型<br>方法在执行的同时会创建一个帧栈（内存）存储局部变量表、操作数、动态链接、方法出口等<br>方法从调用到执行完成就对应着入栈到出栈的过程<br>JAVA虚拟机栈是<em>线程私用</em>的</p>
<p><strong>局部变量表包含哪些？</strong></p>
<p>各种基本类型数据、对象引用和returnAddress类型<br>long和double占用2个局部变量空间（slot），其余的占1个<br>进入方法后，局部变量表大小就确定了，之后都不会再变</p>
<p><strong>虚拟机栈会出现哪些错误？</strong></p>
<ul>
<li>StackOverflowError：虚拟机栈长度固定，栈深度大于了虚拟机所允许的深度</li>
<li>OutOfMemoryError：虚拟机栈长度可以动态扩展，但是无法申请到足够的内存</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p><strong>本地方法栈有什么作用？</strong></p>
<p>和JAVA虚拟机栈功能类似，区别是：虚拟机栈执行JAVA方法服务，本地方法栈执行Native方法服务。<br>本地方法栈是<em>线程私用</em>的</p>
<h3 id="JAVA堆"><a href="#JAVA堆" class="headerlink" title="JAVA堆"></a>JAVA堆</h3><p><strong>JAVA堆有什么作用？</strong></p>
<p>堆内存的唯一目的是存放对象实例和数组。同时Java堆也是GC管理的主要区域。</p>
<blockquote>
<p>并不绝对</p>
</blockquote>
<p>是垃圾回收的主要区域，也称为”GC堆”<br>回收的细节以后再说</p>
<p><strong>JAVA堆会出现哪些错误？</strong></p>
<p>虽然堆的内存是最大的，也是可实现可扩展的<br>但是如果没有空间无法再扩展时，就会抛出OutOfMemoryError错误</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p><strong>方法区有什么作用？</strong></p>
<p>方法区是<em>线程共享</em>的<br>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>方法区的内存管理在HotSpot中作为堆的一个“特例”来对待，免去额外的管理方法，但这样是有问题的——方法区的内存一般是不会被GC回收，受堆的内存限制影响，方法去也更容易遇到内存溢出的问题。<br>对方法区的实现不受虚拟机的规范</p>
<blockquote>
<p>java7把字符串常量池移出到堆中</p>
</blockquote>
<p><strong>方法区会出现哪些错误？</strong></p>
<p>当方法区无法满足类的存储时，抛出OutOfMemoryError错误</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>属于方法区的一部分</p>
<p>class文件中除了类的版本、字段、方法、接口等描述信息外，还有一项信息是运行时常量池，用于存放编译时期生成的字面量和符号常量引用。</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p><strong>什么是直接内存？</strong></p>
<p>直接内存并不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域。但是这部分内存也被频繁的使用，而且也可能导致OutOfMemoryError异常出现。</p>
<p>实际上这部分是属于jvm堆的一部分</p>
<p><strong>为什么需要直接内存？</strong></p>
<p>java IO 过程：内核内存 → jvm 本地堆空间 → java堆<br>直接内存是jvm代码和java代码都可以访问的空间，可以减少一次从jvm到java的拷贝过程（后面一次）</p>
<p><strong>直接内存的内存限制？</strong></p>
<p>受用户空间堆大小的影响</p>
<h2 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h2><p>本节的目的：<br>JVM内存区域是如何创建、如何布局以及如何访问的？</p>
<h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p><strong>对象的创建过程？</strong></p>
<ol>
<li>定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载，解析和初始化过。如果没有，那必须先执行相应的类加载过程。</li>
<li>为新生对象分配内存，对象所需内存的大小在类加载完成后便可完全确定</li>
<li>将分配到的内存空间都初始化为零值，这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li>
<li>对对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息，对象的哈希码，对象的GC分代年龄等信息。</li>
</ol>
<p><strong>什么是指针碰撞？什么是空闲列表？如何选择？</strong></p>
<p>上面第二部分配内存的两种方式：</p>
<ol>
<li>指针碰撞：假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离</li>
<li>空闲列表：如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录</li>
</ol>
<p>选择哪种分配方式是由Java堆是否规整决定，而Java堆是否规整又由采用的垃圾收集器是否带有压缩整理功能决定。</p>
<p><strong>如何解决堆空间分配时的并发问题？</strong></p>
<p>问题：正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存<br>解决：一种是对分配内存空间的动作进行同步处理，另一种是把内存分配的动作按照线程划分在不同的空间之中进行</p>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p><strong>对象在内存中是如何布局的的？</strong></p>
<p>对象在内存中存储的布局可以分为3块区域：对象头（Header），实例数据（Instance Data）和对齐补充（Padding）。</p>
<p><strong>对象头中有哪些信息？</strong></p>
<ol>
<li>自身的运行时数据，如哈希码（HashCode），GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等</li>
<li>类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li>
</ol>
<p><strong>实例数据中有哪些信息？存储的顺序如何？</strong></p>
<p>对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内存。<br>无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。</p>
<p><strong>对齐填充有什么意义？</strong></p>
<p>不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。</p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p><strong>什么是reference类型？</strong></p>
<p>建立了对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。</p>
<blockquote>
<p>由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位，访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。目前主流的方式有使用句柄和直接指针两种。</p>
</blockquote>
<p><strong>对象的访问方式：句柄访问和直接指针？有何区别？</strong></p>
<ul>
<li>句柄访问：Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息</li>
<li>直接指针：使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址</li>
</ul>
<p><img src="/2019/09/29/JVM/（一）JAVA内存区域与内存溢出异常/02.png" alt="句柄访问"></p>
<p><img src="/2019/09/29/JVM/（一）JAVA内存区域与内存溢出异常/03.png" alt="直接指针"></p>
<p>区别：</p>
<ol>
<li>使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。</li>
<li>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。</li>
</ol>
<h2 id="实战：OutOfMemoryError异常"><a href="#实战：OutOfMemoryError异常" class="headerlink" title="实战：OutOfMemoryError异常"></a>实战：OutOfMemoryError异常</h2><p>本节的目的：</p>
<ol>
<li>通过代码验证jvm中各个运行时区域存储的内容</li>
<li>能根据异常的信息快速判断是哪个区域的内存溢出，以及如何处理</li>
</ol>
<h3 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h3><p>堆溢出情形:<br>Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.king.oom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">		List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如何解除堆溢出？</strong></p>
<p>一般的手段是先通过内存映像分析工具对Dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄露（Memory Leak）还是内存溢出（Memory Overflow）。</p>
<p>如果是内存泄露，可进一步通过工具查看泄露对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。<br>如果是内存溢出，换句话说，就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的参数（-Xmx与-Xms）</p>
<h3 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h3><p>由于HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此，对于HotSpot来说，虽然-Xoss参数（设置本地方法栈大小）存在，但实际上是无效的，栈容量只由-Xss参数设定。</p>
<p>栈溢出情形：</p>
<ol>
<li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。</li>
<li>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.king.oom;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args: -Xss228k</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(stackLength ++);</span><br><span class="line">		stackLeak();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">		JavaVMStackSOF sof = <span class="keyword">new</span> JavaVMStackSOF();</span><br><span class="line">		sof.stackLeak();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.king.oom;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args:-Xss2M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dontStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeakByThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					dontStop();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">		JavaVMStackOOM oom = <span class="keyword">new</span> JavaVMStackOOM();</span><br><span class="line">		oom.stackLeakByThread();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决方案：<br>如果使用虚拟机默认参数，栈深度在大多数情况下（因为每个方法压入栈的栈帧大小并不是一样的，所以只能说在大多数情况下）达到1000~2000完全没问题，对于正常的方法调用（包括递归），这个深度应该完全够用了。但是，如果是建立过多线程导致的内存溢出，在不能减少线程数或者更换64位虚拟机的情况下，就只能通过减少最大堆，减少栈容量和减少最大方法区容量来换取更多的线程。</p>
<h3 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h3><p><strong>intern在java6和java7中的区别？</strong></p>
<p>String.intern()是一个Native方法，它的作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。</p>
<p>运行时常量池的溢出情形：</p>
<p>在JDK 1.6及之前的版本中，由于常量池分配在永久代内，可以通过-XX:PermSize和-XX:MaxPermSize限制方法区大小，从而间接限制常量池的容量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.king.oom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args:-XX:PermSize=10M -XX:MaxPermSize=10M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 使用List保持着常量池引用 避免Full GC回收常量池行为</span></span><br><span class="line">		List&lt;String&gt; list = Lists.newArrayList();</span><br><span class="line">		<span class="comment">// 10MB的PermSize在integer范围内足够产生OOM了</span></span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			list.add(String.valueOf(i++).intern());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法区的溢出情形：<br>基本的思路是运行时产生大量的类去填满方法区，直到溢出。下面通过CGLIB实现方法区溢出：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.king.oom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMethodAreaOOM</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">			enhancer.setSuperclass(OOMObject.class);</span><br><span class="line">			enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">			enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">					<span class="keyword">return</span> proxy.invoke(obj, args);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			enhancer.create();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法区溢出也是一种常见的内存溢出异常，一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。</p>
<h3 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h3><p>DirectMemory容量可以通过-XX:MaxDirectMemorySize指定，如果不指定，则默认与Java堆最大值（-Xmx指定）一样。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>（三）虚拟机性能监控与故障处理工具</title>
    <url>/2019/10/16/JVM/%EF%BC%88%E4%B8%89%EF%BC%89%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="虚拟机性能监控与故障处理工具"><a href="#虚拟机性能监控与故障处理工具" class="headerlink" title="虚拟机性能监控与故障处理工具"></a>虚拟机性能监控与故障处理工具</h1><p>本节主要介绍：虚拟机性能监控与故障处理的一些工具</p>
<h2 id="JDK的命令行工具"><a href="#JDK的命令行工具" class="headerlink" title="JDK的命令行工具"></a>JDK的命令行工具</h2><p>JDK中已经提供了大量的工具让开发人员去使用，这些工具都在bin中，基本很小，主要是对tool.jar的一层封装，而tool.jar是用java代码来实现的。</p>
<p><strong>为什么使用java代码来实现监控工具？</strong></p>
<p>当服务器部署后，无论直接操作服务器主机还是远程连接，都会变得比较麻烦。<br>而tool.jar可以直接实现在代码中无缝的使用</p>
<h2 id="常用的工具"><a href="#常用的工具" class="headerlink" title="常用的工具"></a>常用的工具</h2><p>研究常见的工具的使用。主要有下面工具:</p>
<ul>
<li>jps—JVM Process Status tool,显示指定系统内所有的HotSpot虚拟机进程</li>
<li>jstat—JVM Statistics Monitoring tool，用于收集HotSpot虚拟机各方面的运行数据</li>
<li>jinfo—Configuration Info For Java,显示虚拟机配置信息</li>
<li>jmap—Memory Map for Java,生成虚拟机的内存转储快照(heapdump文件)</li>
<li>jhat—JVM Heap Dump Browser，用于分析heapdump文件，它会建立一个http/html服务器。让用于可以在浏览器上查看分析结果</li>
<li>jstack—Stack Trace For Java，显示虚拟机的线程快照。</li>
</ul>
<h3 id="jps-虚拟机进程状况工具"><a href="#jps-虚拟机进程状况工具" class="headerlink" title="jps:虚拟机进程状况工具"></a>jps:虚拟机进程状况工具</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jps [option] [hostid]</span><br><span class="line"></span><br><span class="line">-q   只输出LVMID，省略主类的名称</span><br><span class="line">-m   输出虚拟机进程启动时传递给主类main函数的参数</span><br><span class="line">-l  输出主类的全名，如果进程执行的是jar包，输出Jar路径</span><br><span class="line">-v  输出虚拟机进程启动时JVM参数</span><br><span class="line"></span><br><span class="line">jps -l</span><br><span class="line">16208 sun.tools.jps.Jps</span><br><span class="line">10244 org.jetbrains.jps.cmdline.Launcher</span><br><span class="line">12728 org/netbeans/Main</span><br><span class="line">19608 org.jetbrains.jps.cmdline.Launcher</span><br><span class="line">7756</span><br></pre></td></tr></table></figure>
<h3 id="jstat-虚拟机统计信息监视工具"><a href="#jstat-虚拟机统计信息监视工具" class="headerlink" title="jstat:虚拟机统计信息监视工具"></a>jstat:虚拟机统计信息监视工具</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</span><br><span class="line"></span><br><span class="line">-class　　监视类装载、卸载数量、总空间以及类装载所耗费的时间</span><br><span class="line">-gc　　监视java堆状况，包括Eden区、两个suprivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息(实际在hotspot虚拟机中，永久代不属于堆内存，而且在JDK8已经被元空间MetaSpace所取代)</span><br><span class="line">-gccapacity　　监视内容与-gc基本相同，但是输出主要关注的是Java堆各个区域使用的最大、最小空间</span><br><span class="line">-gcutil　　监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的比例</span><br><span class="line">-gccause　　监视内容与-gc基本相同，但是会额外输出导致上一致gc的原因。</span><br><span class="line">-gcnew　　监视新生代GC状况</span><br><span class="line">-gcnewcapacity　　监视内容与-gcnew基本相同，但是输出主要关注的是使用的最大、最小空间</span><br><span class="line">-gcold　　监视老年代GC状况</span><br><span class="line">-gcoldcapacity　　监视内容与-gcold基本相同，但是输出主要关注的是使用的最大、最小空间</span><br><span class="line">-gcpermcapacity　　输出永久代最大、最小空间</span><br><span class="line">-compiler　　输出JIT编译过的方法、耗时等信息</span><br><span class="line">-printcompilation　　输出已经被JIT编译的方法</span><br><span class="line"></span><br><span class="line">jstat -gcutil 2204</span><br><span class="line">  S0     S1     E      O      P     YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">  0.00   0.00  33.52  54.34  55.99     15    0.322     1    0.282    0.604</span><br><span class="line"></span><br><span class="line">S0C：年轻代中第一个survivor（幸存区）的容量 (字节)</span><br><span class="line">S1C：年轻代中第二个survivor（幸存区）的容量 (字节)</span><br><span class="line">S0U：年轻代中第一个survivor（幸存区）目前已使用空间 (字节)</span><br><span class="line">S1U：年轻代中第二个survivor（幸存区）目前已使用空间 (字节)</span><br><span class="line">EC：年轻代中Eden（伊甸园）的容量 (字节)</span><br><span class="line">EU：年轻代中Eden（伊甸园）目前已使用空间 (字节)</span><br><span class="line">OC：Old代的容量 (字节)</span><br><span class="line">OU：Old代目前已使用空间 (字节)</span><br><span class="line">PC：Perm(持久代)的容量 (字节)</span><br><span class="line">PU：Perm(持久代)目前已使用空间 (字节)</span><br><span class="line">YGC：从应用程序启动到采样时年轻代中gc次数</span><br><span class="line">YGCT：从应用程序启动到采样时年轻代中gc所用时间(s)</span><br><span class="line">FGC：从应用程序启动到采样时old代(全gc)gc次数</span><br><span class="line">FGCT：从应用程序启动到采样时old代(全gc)gc所用时间(s)</span><br><span class="line">GCT：从应用程序启动到采样时gc用的总时间(s)</span><br><span class="line">NGCMN：年轻代(young)中初始化(最小)的大小 (字节)</span><br><span class="line">NGCMX：年轻代(young)的最大容量 (字节)</span><br><span class="line">NGC：年轻代(young)中当前的容量 (字节)</span><br><span class="line">OGCMN：old代中初始化(最小)的大小 (字节)</span><br><span class="line">OGCMX：old代的最大容量 (字节)</span><br><span class="line">OGC：old代当前新生成的容量 (字节)</span><br><span class="line">PGCMN：perm代中初始化(最小)的大小 (字节)</span><br><span class="line">PGCMX：perm代的最大容量 (字节)</span><br><span class="line">PGC：perm代当前新生成的容量 (字节)</span><br><span class="line">S0：年轻代中第一个survivor（幸存区）已使用的占当前容量百分比</span><br><span class="line">S1：年轻代中第二个survivor（幸存区）已使用的占当前容量百分比</span><br><span class="line">E：年轻代中Eden（伊甸园）已使用的占当前容量百分比</span><br><span class="line">O：old代已使用的占当前容量百分比</span><br><span class="line">P：perm代已使用的占当前容量百分比</span><br><span class="line">S0CMX：年轻代中第一个survivor（幸存区）的最大容量 (字节)</span><br><span class="line">S1CMX ：年轻代中第二个survivor（幸存区）的最大容量 (字节)</span><br><span class="line">ECMX：年轻代中Eden（伊甸园）的最大容量 (字节)</span><br><span class="line">DSS：当前需要survivor（幸存区）的容量 (字节)（Eden区已满）</span><br><span class="line">TT： 持有次数限制</span><br><span class="line">MTT ： 最大持有次数限制</span><br></pre></td></tr></table></figure>
<h3 id="jinfo-Java配置信息工具"><a href="#jinfo-Java配置信息工具" class="headerlink" title="jinfo:Java配置信息工具"></a>jinfo:Java配置信息工具</h3><p>作用是 实时查看和调整虚拟机的各项参数</p>
<p>使用jps -v 可以查看虚拟器启动时候显示指定的参数列表，但是如果想查找未被显示指定的参数的系统的默认值，除了去查阅资料，就只能使用jinfo的 -flag选项进行查询了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jinfo -help</span><br><span class="line">Usage:</span><br><span class="line">    jinfo [option] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jinfo [option] &lt;executable &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jinfo [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to remote debug server)</span><br><span class="line"></span><br><span class="line">where &lt;option&gt; is one of:</span><br><span class="line">    -flag &lt;name&gt;         to print the value of the named VM flag</span><br><span class="line">    -flag [+|-]&lt;name&gt;    to enable or disable the named VM flag</span><br><span class="line">    -flag &lt;name&gt;=&lt;value&gt; to set the named VM flag to the given value</span><br><span class="line">    -flags               to print VM flags</span><br><span class="line">    -sysprops            to print Java system properties</span><br><span class="line">    &lt;no option&gt;          to print both of the above</span><br><span class="line">    -h | -help           to print this help message</span><br><span class="line"></span><br><span class="line">jinfo 2084</span><br><span class="line">Attaching to process ID 2084, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 24.80-b11</span><br><span class="line">Java System Properties:</span><br><span class="line"></span><br><span class="line">java.vendor = Oracle Corporation</span><br><span class="line">osgi.bundles.defaultStartLevel = 4</span><br><span class="line">org.eclipse.debug.ui.breakpoints.toggleFactoriesUsed = false</span><br><span class="line">org.osgi.supports.framework.extension = true</span><br><span class="line">sun.management.compiler = HotSpot 64-Bit Tiered Compilers</span><br><span class="line">eclipse.p2.profile = epp.package.jee</span><br><span class="line">os.name = Windows 8</span><br></pre></td></tr></table></figure>
<h3 id="jmap-Java内存映像工具"><a href="#jmap-Java内存映像工具" class="headerlink" title="jmap:Java内存映像工具"></a>jmap:Java内存映像工具</h3><ol>
<li>用于生成堆转储快照(一般称为heapdump或dump文件)</li>
<li>还可以查询finalize执行队列、Java堆和永久代的详细信息，如空间使用率、当前使用的是哪种收集器等。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jmap -help</span><br><span class="line">Usage:</span><br><span class="line">    jmap [option] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jmap [option] &lt;executable &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jmap [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to remote debug server)</span><br><span class="line"></span><br><span class="line">where &lt;option&gt; is one of:</span><br><span class="line">    &lt;none&gt;               to print same info as Solaris pmap</span><br><span class="line">    -heap                to print java heap summary</span><br><span class="line">    -histo[:live]        to print histogram of java object heap; if the &quot;live&quot;</span><br><span class="line">                         suboption is specified, only count live objects</span><br><span class="line">    -clstats             to print class loader statistics</span><br><span class="line">    -finalizerinfo       to print information on objects awaiting finalization</span><br><span class="line">    -dump:&lt;dump-options&gt; to dump java heap in hprof binary format</span><br><span class="line">                         dump-options:</span><br><span class="line">                           live         dump only live objects; if not specified,</span><br><span class="line">                                        all objects in the heap are dumped.</span><br><span class="line">                           format=b     binary format</span><br><span class="line">                           file=&lt;file&gt;  dump heap to &lt;file&gt;</span><br><span class="line">                         Example: jmap -dump:live,format=b,file=heap.bin &lt;pid&gt;</span><br><span class="line">    -F                   force. Use with -dump:&lt;dump-options&gt; &lt;pid&gt; or -histo</span><br><span class="line">                         to force a heap dump or histogram when &lt;pid&gt; does not</span><br><span class="line">                         respond. The &quot;live&quot; suboption is not supported</span><br><span class="line">                         in this mode.</span><br><span class="line">    -h | -help           to print this help message</span><br><span class="line">    -J&lt;flag&gt;             to pass &lt;flag&gt; directly to the runtime system</span><br><span class="line"></span><br><span class="line">jmap -dump:live,format=b,file=heap.bin  2204</span><br><span class="line">Dumping heap to C:\Users\Administrator\heap.bin ...</span><br><span class="line">Heap dump file created</span><br><span class="line"></span><br><span class="line">jmap -heap 2084　　#查看堆内存</span><br><span class="line">Attaching to process ID 2084, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 24.80-b11</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 4 thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio = 0</span><br><span class="line">   .......</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">    .......</span><br></pre></td></tr></table></figure>
<h3 id="jhat-虚拟机堆转储快照分析工具"><a href="#jhat-虚拟机堆转储快照分析工具" class="headerlink" title="jhat:虚拟机堆转储快照分析工具"></a>jhat:虚拟机堆转储快照分析工具</h3><p>jhat(JVM Heap Analysis Tool)命令与jmap搭配使用，来分析jmap生成的堆转储快照。jhat内置了一个小型的HTTP/HTML分析器，生成dump文件的分析结果之后，可以在浏览器查看。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jhat heap.bin</span><br><span class="line">Reading from heap.bin...</span><br><span class="line">Dump file created Mon Dec 03 15:04:02 CST 2018</span><br><span class="line">Snapshot read, resolving...</span><br><span class="line">Resolving 816411 objects...</span><br><span class="line">Chasing references, expect 163 dots...................................................................................................................................................................</span><br><span class="line">Eliminating duplicate references...................................................................................................................................................................</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port 7000</span><br><span class="line">Server is ready.</span><br></pre></td></tr></table></figure>
<p>输入<a href="http://localhost:7000/" target="_blank" rel="noopener">http://localhost:7000/</a> 即可查看分析信息</p>
<h3 id="jstack-java堆栈跟踪工具"><a href="#jstack-java堆栈跟踪工具" class="headerlink" title="jstack:java堆栈跟踪工具"></a>jstack:java堆栈跟踪工具</h3><p>jstack(Stack Trace For Java)命令用于生成虚拟机当前时刻的线程快照(一般成为threaddump或者javacore文件)。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的目的是为了定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源等待的时间过长等原因。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jstack</span><br><span class="line">Usage:</span><br><span class="line">    jstack [-l] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jstack -F [-m] [-l] &lt;pid&gt;</span><br><span class="line">        (to connect to a hung process)</span><br><span class="line">    jstack [-m] [-l] &lt;executable&gt; &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jstack [-m] [-l] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to a remote debug server)</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">    -F  to force a thread dump. Use when jstack &lt;pid&gt; does not respond (process is hung)</span><br><span class="line">    -m  to print both java and native frames (mixed mode)</span><br><span class="line">    -l  long listing. Prints additional information about locks</span><br><span class="line">    -h or -help to print this help message</span><br><span class="line"></span><br><span class="line">jstack -l 2204</span><br></pre></td></tr></table></figure>
<p>在JDK1.5中，java.lang.Thread类新增了一个getAllStackTraces()方法用于获取虚拟机中所有线程的StackTraceElement对象。使用这个对象可以通过简单的几行代码就完成jstack的大部分功能，在实际项目中可以用这个做管理界面，可随时查看线程堆栈。</p>
<h2 id="可视化工具的使用"><a href="#可视化工具的使用" class="headerlink" title="可视化工具的使用"></a>可视化工具的使用</h2><p>JDK除了上面的大量的命令行工具，还提供了两个可视化工具，JConsole和Visual VM。JConsole是JDL5才有的，而Visual VM是JDK6的Update7中首次发布的，现在已经成为主流的多合一故障处理工具。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>（九）晚期（编译器）优化</title>
    <url>/2019/12/12/JVM/%EF%BC%88%E4%B9%9D%EF%BC%89%E6%99%9A%E6%9C%9F%EF%BC%88%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%89%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="晚期（编译器）优化"><a href="#晚期（编译器）优化" class="headerlink" title="晚期（编译器）优化"></a>晚期（编译器）优化</h1><p>本章主要内容：</p>
<ol>
<li>了解虚拟机热点探测方法</li>
<li>了解HotSpot的即时编译器触发条件</li>
<li>从虚拟机外部观察和分析JIT编译的数据和结果</li>
<li>了解几种常见的编译期优化技术</li>
</ol>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>什么是JIT编译（Just In Time Compiler）？</strong></p>
<p>Java程序最初是由解释器解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些“热点代码”编译成机器码，提高运行效率。</p>
<h2 id="HotSpot虚拟机的即时编译器"><a href="#HotSpot虚拟机的即时编译器" class="headerlink" title="HotSpot虚拟机的即时编译器"></a>HotSpot虚拟机的即时编译器</h2><p><strong>为何HotSpot虚拟机要使用解释器和编译器并存的架构？</strong></p>
<p><img src="/2019/12/12/JVM/（九）晚期（编译器）优化/01.png" alt="解释器和编译器并存"></p>
<ol>
<li>当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行；在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率。</li>
<li>当程序运行环境中内存资源限制较大，可以使用解释执行节约内存，反之可以使用编译执行来提升效率。</li>
<li>解释器还可以作为编译器激进优化时的一个“逃生门”，让编译器根据概率选择一些大多数时候都能提升运行速度的优化手段。</li>
</ol>
<p><strong>为何HotSpot虚拟机要实现两个不同的即使编译器？</strong></p>
<p>HotSpot编译器中出现两个编译器Client Compiler称为C1编译器，Server Compiler称为C2编译器。JVM默认采用解释器与其中一个编译器直接配合的方法工作，程序使用哪个编译器，取决于虚拟机运行的模式（Client模式还是Server模式）。</p>
<p>用Client Compiler获取更高的编译速度，用Server Compiler来获取更好的编译质量，在解释执行的时候也无须再承担收集性能监控信息的任务。</p>
<p><strong>程序何时使用解释器？何时使用编译器？</strong></p>
<p>为了在程序启动响应速度与运行效率之间达到最佳平衡，HotSpot虚拟机还会逐渐启动分层编译的策略，分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次，其中包括：</p>
<ol>
<li>第0层，程序解释执行，解释器不开启性能监控功能，可触发第1层编译。</li>
<li>第1层，也成为C1编译，将字节码编译为本地代码，进行简单、可靠的优化，如有必要时将加入性能监控的逻辑。</li>
<li>第2层（或2层以上）：也成为C2编译，也是将字节码编译为本地代码，但是会启动一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。</li>
</ol>
<p><strong>哪些程序代码会被编译成本地代码？</strong></p>
<p>在运行过程中会被即时编译器编译的“热点代码”有两类：</p>
<ol>
<li>被多次调用的方法。</li>
<li>被多次执行的循环体。</li>
</ol>
<p>对于第一种情况，由于是由方法调用触发的编译，因此编译器会以整个方法作为编译对象，这种编译也是虚拟机中标准的JIT编译方式。而对第二种情况，尽管编译动作是由循环体所触发的，但编译器依然会以整个方法作为编译对象，这种编译方式因为编译发生在方法执行过程之中，因此形象地被称为栈上替换，简称为OSR编译，即方法栈帧还在栈上（未离开），方法就被替换了。</p>
<p><strong>如何判断是不是热点代码？</strong></p>
<p>判断一段代码是不是为热点代码，是不是需要触发即时编译，这样的行为称为热点探测，但进行热点探测也是不一定要知道方法具体被调用了多少次，目前主要的热点探测判定方法有两种：</p>
<ol>
<li>基于采样的热点探测：虚拟机会周期性地检查各种线程的栈顶，如果发现某个或者某些方法经常出现在栈顶，那这个方法就是“热点方法”。<br>优点：实现简单、高效，还可以很容易地获取方法调用方法。<br>缺点：很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。</li>
<li>基于计数器的热点探测：虚拟机会为每个方法尽力计数器，统计方法的执行次数，如果执行次数超过一定的阙值就认为它是热点方法。<br>优点：统计结构相对来说更加精确与严谨。<br>缺点：实现起来麻烦，需要为每个方法及建立并维护计数器，而且不能直接获取到方法的调用关系。</li>
</ol>
<p>在HotSpot中使用的是第二种方法，基于计数器的热点探测法，因此它为每个方法准备了两类计数器：</p>
<ol>
<li>方法调用计数器：当一个方法被调用时，会先检查该方法是否存在被JIT 编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法计数器的阈值。若超过了，则将会向即时编译器提交一个该方法的代码编译请求。</li>
</ol>
<p><img src="/2019/12/12/JVM/（九）晚期（编译器）优化/02.png" alt="方法调用计数器"></p>
<ol start="2">
<li>回边计数器：当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否有已经编译好的version，如果有，他将会优先执行已编译的代码，否则就把回边计数器的值加1，然后判断方法调用计数器与回边计数器之和是否超过回边计数器的阈值。当超过阈值的时候，将会提交一个OSR编译请求，并且把回边计数器的值降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果。</li>
</ol>
<p><img src="/2019/12/12/JVM/（九）晚期（编译器）优化/03.png" alt="回边计数器"></p>
<p>如何从外部观察即使编译器的编译过程和结果？</p>
<h2 id="编译优化技术"><a href="#编译优化技术" class="headerlink" title="编译优化技术"></a>编译优化技术</h2><p>常见的编译期优化技术:</p>
<ul>
<li>语言无关的经典优化技术之一：公共子表达式消除。</li>
<li>语言相关的经典优化技术之一：数组范围检查消除。</li>
<li>最重要的优化技术之一：方法内联。</li>
<li>最前沿的优化技术之一：逃逸分析。</li>
</ul>
<p>首先要明确的是，JVM的这些优化的技术基本都是用于即时编译器上，都是建立在某种中间表示或者机器码上的，绝不是建立在JAVA源码之上，也就是说，至少是发生class文件之后。</p>
<p><strong>公共子表达式消除？</strong></p>
<p>如果一个表达式E已经计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就成为了公共子表达式。对于这种表达式，没有必要花时间在对它进行计算，只需要直接用前面计算过的表达式结果代替E就可以了。如果这种优化仅限于程序的基本块内，便称为局部公共子表达式消除，如果这种优化的范围涵盖了多个基本块，那就称为全局公共子表达式消除</p>
<p><strong>数组边界检查消除？</strong></p>
<p>Java语言是一门动态安全的语言，数组边界检查是必须做的，但数组边界检查是不是必须在运行期间一次不漏地检查则是可以商量的事情。比如，数组下标是一个常量，如foo[3]，只要在编译期根据数据流分析来确定foo.length的值，并判断下标3没有越界，执行的时候就无须判断了。数组访问发生在循环之中，并且使用循环变量来进行数组访问，如果编译器只要通过数据流分析就可以判定循环变量的取值范围永远在区间[0,foo.length)之内，那在整个循环中就可以把数组的上下界检查消除，这可以节省很多次的条件判断操作</p>
<p>类似的安全检查还有很多，譬如空指针异常，除数为零，这种大量的安全检查代码，也是导致JAVA要比C/C++做更多事情的原因，成为一种隐性开销，要消除这些隐性开销，还得和C/C++一样，使用<code>应用层异常</code>（详细可参考操作系统中的<code>异常</code>章节）来处理，譬如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//JVM中空指针处理的伪代码</span><br><span class="line">if (foo != null) &#123;</span><br><span class="line">  return foo.value;</span><br><span class="line">else &#123;</span><br><span class="line">  throw new NullPointException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//优化后的伪代码</span><br><span class="line">if (foo != null) &#123;</span><br><span class="line">  return foo.value;</span><br><span class="line">else &#123;</span><br><span class="line">  throw new NullPointException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法内联？</strong></p>
<p>方法内联，是指JVM在运行时将调用次数达到一定阈值的方法调用替换为方法体本身，从而消除调用成本，并为接下来进一步的代码性能优化提供基础，是JVM的一个重要优化手段之一。</p>
<p><strong>何时进行方法内联？</strong></p>
<p>方法内联是由JIT编译器在运行时完成的。JIT根据以下信息决定是否进行内联：</p>
<ol>
<li>被调用方法是否足够hot。这个取决于该方法被调用的次数，次数阈值默认值为10,000。即运行时被调用次数超过10,000的方法，可以被认为是hot。</li>
<li>被调用方法大小是否合适。对于过大的方法，JIT认为它是不适合做内联的。这个方法大小阈值由-XX:FreqInlineSize指定，不建议修改。即大于这个阈值size的方法，不考虑进行内联</li>
<li>被调用方法运行时其实现是否可以唯一确定。即必须是非虚方法</li>
</ol>
<p><strong>java的内联的复杂性？如何解决？</strong></p>
<p>虚方法在JAVA占大比，方法内联无法判断方法具体的版本，会使方法内联功能大打折扣。<br>为此，引入<code>类型继承方法分析</code>，分析虚方法是否有唯一确定的实现版本，如果有，则选其进行方法内联，不过该手段属于<code>激进优化</code>，一旦在运行的过程中继承关系发生变化，则需要回到解释状态执行。这也是解释器作为<code>逃生门</code>的一个作用。</p>
<p><strong>逃逸分析？分析结果对优化有什么意义？</strong></p>
<p>逃逸分析：分析对象的动态作用域。不是代码优化手段，而是为其它手段提供依据。</p>
<ul>
<li>方法逃逸：一个对象被外部方法引用，如传参。</li>
<li>线程逃逸：对象被外部线程访问到，如赋值给类变量。</li>
</ul>
<p>如果证明一个对象不会逃逸，那么可以进行一些高效的优化：</p>
<ul>
<li>栈上分配：一般对象都在堆上分配，各个线程共享，GC回收内存需要耗费时间。如果一个对象确定不会逃逸出方法，比如局部变量，那么分配在栈上就很舒服，可以随栈帧出栈而销毁。GC压力减小。</li>
<li>同步消除：如果一个对象确定不是线程逃逸，那么就不会被其它线程访问，就不存在竞争，完全可以消除同步处理。</li>
<li>标量替换：如果一个对象确定不会被外部访问，那么真正执行的时候就不需要创建这个对象，改为在栈上创建对象拆散后的标量。</li>
</ul>
<h2 id="JAVA与C-C-编译器对比"><a href="#JAVA与C-C-编译器对比" class="headerlink" title="JAVA与C/C++编译器对比"></a>JAVA与C/C++编译器对比</h2><p>java即时编译器的劣势：</p>
<ol>
<li>即时编译器运行占用的是用户程序的运行时间，具有很大的时间压力，能提供的优化手段也严重受制于编译成本。</li>
<li>jvm会有大量的安全检查代码，这些都是隐性开销</li>
<li>jvm中虚方法占比高，优化难度也会因此增加</li>
<li>java是动态扩展语言，在运行时新加载的类可能会使继承关系发生变化，因此全局性的优化技术往往无法很好的工作（激进优化）。</li>
<li>java对象分配在堆上，局部变量在栈上，而C/C++可自由的分配堆和栈，也不需要使用GC去回收内存</li>
</ol>
<p>java即时编译器的优势：</p>
<ol>
<li>开发效率换取性能效率</li>
<li>C/C++中的别名分离难度要高</li>
<li>java的动态编译性使其可以实施以运行期性能监控为基础的优化措施（C/C++所有的优化都在编译器完成）</li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>（六）虚拟机类加载机制</title>
    <url>/2019/11/04/JVM/%EF%BC%88%E5%85%AD%EF%BC%89%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h1><p>本节主要内容：</p>
<ol>
<li>介绍了类加载过程中：“加载”、“验证”、“准备”、“解析”、“初始化”这5个阶段中虚拟机进行了了那些动作，</li>
<li>介绍了类加载器的工作原理及对虚拟机的意义。</li>
</ol>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>两个约定：</p>
<ol>
<li>后面的类泛指类和接口，需要区别对待的地方会特别指出</li>
<li>class文件并非指硬盘上真实的文件，而泛指一串二进制字节码</li>
</ol>
<h2 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h2><p><strong>类加载——类的生命周期？</strong></p>
<p><img src="/2019/11/04/JVM/（六）虚拟机类加载机制/01.png" alt="类的生命周期"></p>
<p><strong>类加载的过程是按部就班？</strong></p>
<p>类加载的过程是交叉的，之力只是指开始的时机是按部就班的。<br>比如在加载阶段未结束就会进行第二阶段的验证</p>
<p><strong>什么时候开始加载阶段？</strong></p>
<p>类的加载阶段的启动条件“有且仅有”下面5个：</p>
<ol>
<li>遇到new（对应新建对象）、getstatic（对应访问类变量、static final除外）、putstatic（对应设置类变量、static final除外）、invokestatic（调用类方法即静态方法）这4条指令时，如果类没有加载，则需要先触发其加载。</li>
<li>对类进行反射调用时，如果类没有加载，则必须触发加载</li>
<li>当初始化一个类时，如果其父类没有加载，则必须先加载他的父类</li>
<li>虚拟机执行的main方法入口，这个类必须加载</li>
<li>JDK1.7.动态语言支持时，如果java.lang.invoke.MethodHandler指向的是REF_getstatic,REF_putstatic、REF_invokestatic的方法句柄时，必须先加载这个类</li>
</ol>
<p><strong>如何理解有且仅有？</strong></p>
<p>比如下面的情况是不会触发加载的：</p>
<ol>
<li>通过子类访问到父类中的静态字段，只会触发父类的初始化，不会触发子类的加载</li>
<li>new一个数组对象(newarray指令)，只会触发数组对象的加载，并不会触发数组元素类的加载</li>
<li>getstatic（对应访问类变量、static final除外），意思是调用常量并不会触发被调用类的加载，因为常量会存储在调用类的常量池中</li>
</ol>
<p><strong>接口和类加载阶段的区别？</strong></p>
<p>第三点有区别，当初始化一个接口时，并不要求父接口也初始化，当使用父接口时初始化</p>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p><strong>加载的目标？</strong></p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口<blockquote>
<p>对于HotSpot虚拟机而言，Class对象比较特殊，它虽是对象，但存放在方法区里</p>
</blockquote>
</li>
</ol>
<p>详细推荐参考<a href="https://blog.csdn.net/luanlouis/article/details/50529868" target="_blank" rel="noopener">https://blog.csdn.net/luanlouis/article/details/50529868</a></p>
<p><strong>加载阶段的可控性体现在？</strong></p>
<p>对于字节流的获取，jvm并没有明确的限制，比如：</p>
<ul>
<li>从ZIP包中读取</li>
<li>从网络中获取</li>
<li>运行时计算生成</li>
<li>从其他文件生成，如JSP技术</li>
</ul>
<p><strong>数组类加载阶段的有什么不同？</strong></p>
<p>数组类本身不由加载器创建，而是用JVM虚拟机创建。而对于数据元素，按一下规则：</p>
<ul>
<li>如果数组元素是引用类型，则用该引用类型的类加载器去加载</li>
<li>如果数组元素是基础类型，则用引导类加载器去加载</li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p><strong>验证开始时机？</strong></p>
<p>在加载阶段的第二步之前</p>
<p><strong>验证的目的？</strong></p>
<p>确保输入的Class文件的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求，并且不会危害虚拟机自身的安全。</p>
<p><strong>为什么需要验证？</strong></p>
<p>java语言本身是安全的（在编译时会进行安全验证），但是Class文件并不要求用JAVA编译而来，对于从其他渠道获取的二进制字节流，有必要验证器安全性</p>
<p><strong>验证的过程：</strong></p>
<p>从整体上看，验证阶段大致上会完成下面四个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。</p>
<ul>
<li><p>文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。</p>
<ul>
<li>是否以魔数0xCAFEBABE开头。</li>
<li>主次版本号是否在当前虚拟机的处理范围之内</li>
<li>常量池的常量中是否有不被支持的常量类型（tag标志）。</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li>
<li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。</li>
<li>……</li>
</ul>
<blockquote>
<p>只有通过了这个阶段的验证后，字节流才会进入方法区中进行存储，所以后面的3个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流。</p>
</blockquote>
</li>
<li><p>元数据验证：对字节码描述的信息（即类的元数据信息）进行语义分析，以保证其描述的信息符合Java语言规范的要求。</p>
<ul>
<li>该类是否有父类（除了java.lang.Object之外，所有的类都应有父类）</li>
<li>该类的父类是否继承了不允许被继承的类（final修饰的类）</li>
<li>若此类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法</li>
<li>……</li>
</ul>
</li>
<li><p>字节码验证：进行数据流和控制流分析（主要在Code属性），确定程序语义是合法的、符合逻辑的。</p>
<ul>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作。</li>
<li>保证跳转指令不会跳转到方法体以外的字节码指令上。</li>
<li>保证方法体中类型转换是有效的，例如子类对象可以赋值给父类数据类型，但父类对象赋值给子类数据类型是危险和不合法的。</li>
<li>……</li>
</ul>
</li>
<li><p>符号引用验证：对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，确保第三阶段——解析阶段的动作能正常执行。</p>
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li>
<li>指定的类中是否存在符合描述符与简单名称描述的方法与字段。</li>
<li>符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问。</li>
</ul>
</li>
</ul>
<p><strong>更多说明：</strong></p>
<p>验证阶段是一个非常重要但不是一定必要（因为对运行期没有影响）的阶段。如果所运行的全部代码都已经被反复验证过，那么在实施阶段就可以考虑使用<code>-Xverify:none</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p><strong>准备的目的？</strong></p>
<ul>
<li>为类变量分配内存(方法区)</li>
<li>设置类变量初始值</li>
</ul>
<p><strong>两个容易混淆的概念？</strong></p>
<ol>
<li>在准备阶段进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</li>
<li>这里的初始值仅仅是数据类型对应的零值（被final修饰的常量除外）<br><img src="/2019/11/04/JVM/（六）虚拟机类加载机制/02.png" alt="类的生命周期"></li>
</ol>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p><strong>解析的目的？</strong></p>
<p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<p><strong>符号引用和直接引用的关系？</strong></p>
<ul>
<li>符号引用（Symbol References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。</li>
<li>直接引用（Direct References）：直接引用可以是直接内存中目标的指针、相对偏移量或是一个能间接定位到目标的句柄。</li>
</ul>
<p><strong>解析的时间？</strong></p>
<p>虚拟机规范并未规定解析动作发生的具体时间，仅要求在执行anewarray、checkcast、getfield、getstatic、instanceof、invokeinterface、invokespecial、invokestatic、invokevirtual、multianewarray、new、putfield和putstatic这13个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。所以虚拟机实现可以根据需要来判断到底是在类被加载器加载时就对常量池中的符号进行解析，还是等到一个符号引用将要被使用前才去解析它。</p>
<blockquote>
<p>加载的启动指令有且只有4个，而解析有13个，实际上是不矛盾的，我的认为是，一开始只有main方法所在类会被加载，之后都是在符号引用被解析的时候被加载的，而已经被加载过的再次被解析时，可以直接从缓存中拿到直接引用。</p>
</blockquote>
<p><strong>对一个符号进行多次解析是什么结果？</strong></p>
<p>对同一个符号引用进行多次解析请求是很常见的，除 invokedynamic 指令外（ invokedynamic指令是用于动态语言支持的，它所对应的引用称为“动态调用点限定符”，必须等到程序实际运行到这条指令的时候，解析动作才能进行）虚拟机实现可能会对第一次解析的结果进行缓存（将直接引用保存在运行时常量池中），无论是否真正执行了多次解析动作，虚拟机实现必须保证在同一个实体中，如果一个符号引用之前已经被成功解析过，后续的引用解析请求就应当一直成功，反之亦然。</p>
<p>类或接口解析步骤？<br>字段解析步骤？<br>类方法解析步骤？<br>接口方法解析？</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>除了加载阶段可以通过自定义的类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正执行类中定义的JAVA代码（字节码）</p>
<p><strong>准备阶段和初始化阶段的区别？</strong></p>
<p>在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源，简单说，初始化阶段即虚拟机执行类构造器<clinit>()方法的过程。</clinit></p>
<p><strong>类构造器<clinit>的运行特点？</clinit></strong></p>
<ul>
<li><clinit>()方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块（static{} 块）中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定，特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。</clinit></li>
<li><clinit>()方法与类的构造函数（或者说实例构造器<init>() 方法）不同，不需要显式的调用父类的()方法。虚拟机会自动保证在子类的<clinit>()方法运行之前，父类的<clinit>()方法已经执行结束。</clinit></clinit></init></clinit></li>
<li>由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优于子类的变量赋值操作。</clinit></li>
<li><clinit>()方法对于类或接口不是必须的，如果一个类中不包含静态语句块，也没有对类变量的赋值操作，编译器可以不为该类生成<clinit>()方法。</clinit></clinit></li>
<li>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。</clinit></clinit></clinit></li>
<li>虚拟机会保证一个类的<clinit>()方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的<clinit>()方法，其它线程都会阻塞等待，直到活动线程执行<clinit>()方法完毕。</clinit></clinit></clinit></li>
</ul>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p><strong>类加载器对类“相等”的影响？</strong></p>
<p>Class文件和类加载器一同决定了一个类的唯一性<br>意味着同一个Class文件，如果是不同的类加载器加载的，那么他们就是不同的类</p>
<p><strong>类加载器的分类？</strong></p>
<p>从Java虚拟机的角度分为两种不同的类加载器：启动类加载器（Bootstrap ClassLoader）和其他类加载器。其中启动类加载器，使用C++语言实现，是虚拟机自身的一部分；其余的类加载器都由Java语言实现，独立于虚拟机之外，并且全都继承自java.lang.ClassLoader类。（这里只限于HotSpot虚拟机）</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）：这个类加载器负责将存放在<code>&lt;JAVA_HOME&gt;\lib</code>目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。</li>
<li>扩展类加载器（Extension ClassLoader）：这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</li>
<li>应用程序类加载器（Application ClassLoader）：这个类加载器由sun.misc.Launcher$AppClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
<p><strong>什么是双亲委托模型？为什么使用双亲委托模型？</strong></p>
<p>双亲委派模型（Pattern Delegation Model）,要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器。这里父子关系通常是子类通过组合关系而不是继承关系来复用父加载器的代码。</p>
<p>双亲委派模型的工作过程： 如果一个类加载器收到了类加载的请求，先把这个请求委派给父类加载器去完成（所以所有的加载请求最终都应该传送到顶层的启动类加载器中），只有当父加载器反馈自己无法完成加载请求时，子加载器才会尝试自己去加载。</p>
<p>使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是java类随着它的类加载器一起具备了一种带有优先级的层次关系。</p>
<p><strong>双亲委托模型为什么会被3次大规模的破坏？</strong></p>
<ul>
<li><p>第一次破坏是因为类加载器和抽象类java.lang.ClassLoader在JDK1.0就存在的，而双亲委派模型在JDK1.2之后才被引入，所以对于之前已经存在的用户自定义类加载器，是不符合双亲委托模型的，因此，为了引入双亲委派模型时做了一定的妥协：在java.lang.ClassLoader中引入了一个findClass()方法，DK1.2之后不提倡用户去覆盖loadClass()方法，而是把自己的类加载逻辑写到findClass()方法中。</p>
</li>
<li><p>第二次破坏是因为模型自身的缺陷，现实中存在这样的场景：基础的类加载器需要求调用用户的代码，而基础的类加载器可能不认识用户的代码。为此，Java设计团队引入的设计时“线程上下文类加载器（Thread Context ClassLoader）”。这样可以通过父类加载器请求子类加载器去完成类加载动作。已经违背了双亲委派模型的一般性原则。</p>
</li>
<li><p>第三次破坏 是由于用户对程序动态性的追求导致的。这里所说的动态性是指：“代码热替换”、“模块热部署”等等比较热门的词。说白了就是希望应用程序能够像我们的计算机外设一样，接上鼠标、U盘不用重启机器就能立即使用。OSGi是当前业界“事实上”的Java模块化标准，OSGi实现模块化热部署的关键是它自定义的类加载器机制的实现。每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>（八）早期（编译器）优化</title>
    <url>/2019/12/04/JVM/%EF%BC%88%E5%85%AB%EF%BC%89%E6%97%A9%E6%9C%9F%EF%BC%88%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%89%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="早期（编译器）优化"><a href="#早期（编译器）优化" class="headerlink" title="早期（编译器）优化"></a>早期（编译器）优化</h1><p>本章主要内容：</p>
<ol>
<li>从编译器源码实现的层次上了解JAVA源代码编译为字节码的过程</li>
<li>分析了JAVA语言中泛型、主动装箱/拆箱、条件编译等多种语法糖的前因后果</li>
<li>实战练习如何使用插入式注解处理器来完成一个检查程序命名规范的编译器插件</li>
</ol>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>java的有哪些“编译期”？前端编译器和后端编译器的职能？</strong></p>
<p> java语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个<br> 前端编译器（其实叫“编译器的前端”更准确点）把<em>.java文件转化为</em>.class文件的过程；<br> 也可能是指虚拟机的后端运行期编译器（JIT编译器，Just In Time Compiler）把字节码转化为机器码的过程；<br> 还可能是指使用静态提前编译器（AOT编译器，Ahead Of Time Compiler）直接把*.java文件编译成本地机器代码的过程。</p>
<p>1，前端编译器：Sun的Javac、Eclipse JDT中的增量式编译器（ECJ）；<br>2，JIT编译器：HotSpot VM的C1、C2编译器；<br>3，AOT编译器：GNU Compiler for the Java（GCJ）、Excelsior JET；</p>
<p><strong>前端编译器和后端编译器的职能？</strong></p>
<p>前端编译器对代码的运行效率几乎没有任何优化措施。虚拟机设计团队把对性能的优化集中到了后端的即时编译器中，这样可以让那些不是由Javac产生的Class文件（如JRuby、Groovy等语言的Class文件）也同样能享受到编译器优化所带来的好处。</p>
<p>前端处理器如javac，做了许多针对Java语言编码过程的优化措施来改善程序员的编码风格和提高编码效率。相当多新生的Java语法特性，都是靠编译器的“语法糖”来实现。</p>
<h2 id="javac编译器"><a href="#javac编译器" class="headerlink" title="javac编译器"></a>javac编译器</h2><p><strong>Javac为什么是由java写的？</strong></p>
<p>用术语来描述，这便是一个语言的<code>自举</code>，自举的意思是说，一种编程语言的程序可以用这种语言本身编写的编译器来编译。</p>
<p>知乎上的轮子哥是这样简要地描述自举的过程的：</p>
<blockquote>
<p>你想创造一门V语言而且用V语言来写V编译器的话，你得按照下面的方法做：<br>1、用C++把那个编译器（A）写出来，顺便留下很多测试用例。<br>2、用V语言把那个编译器写（B）出来，用A.exe来编译B，修改直到所有测试用例都通过为止。<br>3、B.exe来编译B自己得到B2.exe，修改直到B2.exe所有测试用例都通过为止。这是为了保证，就算B本身有很多bug，至少编译自己是没有bug的，从而你就可以走到第四步。<br>4、当你觉得有信心了，用A.exe把B编译一遍，就得到了B.exe。然后A的代码和A.exe都在也不需要存在了，删掉他们。以后你就不断的用B.exe来编译下一个版本的B就好了。就自举了。<br>作者：vczh<br>链接：<a href="https://www.zhihu.com/question/28513473/answer/41094452" target="_blank" rel="noopener">https://www.zhihu.com/question/28513473/answer/41094452</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p>完成自举有如下的优点：</p>
<ol>
<li>这是一种对该语言的极好的测试；</li>
<li>编译器的开发者只需掌握这一门语言即可，不需要再掌握其它语言；</li>
<li>开发编译器的环境和使用这门语言开发的所有其它程序一致；</li>
<li>对编译器后端的优化不仅会优化以后所有编译出来的其它程序的效率，也会优化编译器本身的效率。</li>
</ol>
<p><strong>javac的过程？</strong></p>
<ol>
<li>解析与填充符合表过程</li>
<li>插入式注解处理器的注解处理过程</li>
<li>分析与字节码生成过程</li>
</ol>
<p><img src="/2019/12/04/JVM/（八）早期（编译器）优化/01.png" alt="javac的过程"></p>
<p><img src="/2019/12/04/JVM/（八）早期（编译器）优化/02.png" alt="javac的主体代码"></p>
<h3 id="解析与填充符号表"><a href="#解析与填充符号表" class="headerlink" title="解析与填充符号表"></a>解析与填充符号表</h3><ol>
<li><p>词法、语法分析</p>
<p>词法分析是将源代码的字符流转变为标记（Token）集合，单个字符是程序编写过程的最小元素，而标记则是编译过程的最小元素，关键字、变量名、字面量、运算符都可以成为标记，如“int a = b + 2”这句代码包含了6个标记，分别是int、a、=、b、+、2，虽然关键字int由3个字符构成，但是它只是一个Token，不可再拆分。</p>
<p>语法分析是根据Token序列构造抽象语法树的过程，抽象语法树（Abstract Syntax Tree，AST）是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个阶段都代表着程序代码中的一个语法结构（Construct），例如包、类型、修饰符、运算符、接口、返回值甚至代码注释等都可以是一个语法结构。</p>
<p>在这之后，编译器就基本不会再对源码文件进行操作了，后续的操作都建立在抽象语法树之上。</p>
</li>
<li><p>填充符号表</p>
<p>符号表（Symbol Table）是由一组符号地址和符号信息构成的表格，读者可以把它想象成哈希表中K-V值对的形式（实际上符号表不一定是哈希表实现，可以是有序号表、树状符号表、栈结构符号表等）。符号表中所登记的信息在编译的不同阶段都要用到。在语义分析中，符号表所登记的内容将用于语义检查（如检查一个名字的使用和原先的说明是否一致）和产生中间代码。在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的依据。</p>
</li>
</ol>
<h3 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h3><p><strong>注解处理器的类别和作用？</strong></p>
<p>在JDK1.5之后，Java语言提供了对注解的支持，这些注解与普通的Java代码一样，是在运行期间发挥作用的。在JDK1.6中提供了一组插入式注解处理器的标准API在编译期间对注解进行处理，我们可以把它看做是一组编译器的插件，在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语<br>法树进行修改为止，每一次循环称为一个Round。</p>
<p>有了编译器注解处理的标准API后，我们的代码才有可能干涉编译器的行为，由于语法树中的任意元素，甚至包括代码注释都可以在插件之中访问到，所以通过插入式注解处理器实现的插件在功能上有很大的发挥空间。只要有足够的创意，程序员可以使用插入式注解处理器来实现许多原本只能在编码中完成的事情，最后会给出一个使用插入式注解处理器的简单实战。</p>
<h3 id="语义分析与字节码生成"><a href="#语义分析与字节码生成" class="headerlink" title="语义分析与字节码生成"></a>语义分析与字节码生成</h3><p><strong>语义分析的作用？</strong></p>
<p>语义分析的主要任务是对语法树结构上正确的源程序进行上下文有关性质的审查，如进行类型审查。</p>
<ol>
<li>标注检查：变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等。</li>
<li>数据及控制流分析：对程序上下文逻辑更进一步的验证，如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等</li>
</ol>
<blockquote>
<p>通过第六章的讲解我们已经知道，局部变量与字段（实例变量、类变量）是有区别的，它在常量池中没有CONSTANT_Fieldref_info的符号引用，自然就没有访问标志（Access_Flags）的信息，甚至可能连名称都不会保留下来（取决于编译时的选项），自然在Class文件中不可能知道一个局部变量是不是声明为final了。因此，将局部变量声明为final，对运行期是没有影响的，变量的不变性仅仅由编译器在编译期间保障。</p>
</blockquote>
<h3 id="解语法糖"><a href="#解语法糖" class="headerlink" title="解语法糖"></a>解语法糖</h3><p>指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说，使用语法糖能够增加程序的可读性，从而减少程序代码出粗的机会。</p>
<h3 id="字节码生成"><a href="#字节码生成" class="headerlink" title="字节码生成"></a>字节码生成</h3><p><strong>该阶段的作用？</strong></p>
<p>字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。例如，前面章节中多次提到的实例构造器<init>（）方法和类构造器<clinit>（）方法就是在这个阶段添加到语法树之中的。</clinit></init></p>
<h2 id="JAVA语法糖的味道"><a href="#JAVA语法糖的味道" class="headerlink" title="JAVA语法糖的味道"></a>JAVA语法糖的味道</h2><p><strong>语法糖的利与弊？</strong></p>
<p>利：几乎各种语言或多或少都提供过一些语法糖来方便程序员的代码开发，这些语法糖虽然不会提供实质性的功能改进，但是它们或能提高效率，或能提升语法的严谨性，或能较少编码出错的机会。</p>
<p>弊：不过也有一种观点认为语法糖并不一定都是有益的，大量添加和使用“含糖”的语法，容易让程序员产生依赖，无法看清语法糖的躺椅背后，程序代码的真实面目，如泛型就是一个例子。</p>
<p>常见语法糖：</p>
<ol>
<li>泛型</li>
<li>自动装箱、拆箱与遍历循环</li>
<li>条件编译</li>
</ol>
<h2 id="插入式注解处理器实战"><a href="#插入式注解处理器实战" class="headerlink" title="插入式注解处理器实战"></a>插入式注解处理器实战</h2>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>（五）类文件结构</title>
    <url>/2019/10/28/JVM/%EF%BC%88%E4%BA%94%EF%BC%89%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><p>本节主要介绍：</p>
<ol>
<li>class文件结构</li>
<li>jvm指令集</li>
</ol>
<h2 id="无关性的基石"><a href="#无关性的基石" class="headerlink" title="无关性的基石"></a>无关性的基石</h2><p><strong>如何理解JAVA的平台无关性？</strong></p>
<p>JVM处理的实际上是class文件，只要实现在不同机器上的JVM，使得具有处理class文件的能力，就具有了平台无关性</p>
<p>java和class是分离的，java只是可以编译成class的一种语言，于此类似的还有Jython,JRuby,Groovy等语言。</p>
<p><img src="/2019/10/28/JVM/（五）类文件结构/01.png" alt="语言无关性"></p>
<h2 id="Class文件的结构"><a href="#Class文件的结构" class="headerlink" title="Class文件的结构"></a>Class文件的结构</h2><p><strong>class文件的结构？</strong></p>
<p>Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部都是程序运行的必要数据。</p>
<p>根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储，这种伪结构中只有两种数据类型：无符号数和表：</p>
<ul>
<li>无符号数属于基本数据类型，以u1、u2、u4、u8来分别代表1、2、4、8个字节的无符号数。</li>
<li>表是由多个无符号数或其他表作为数据项构成的符合数据类型，所有的表都习惯性地以“_info”结尾。</li>
</ul>
<p>整个 Class 文件就是一张表，它由下表中所示的数据项构成：</p>
<p><img src="/2019/10/28/JVM/（五）类文件结构/02.png" alt="Class表结构"></p>
<p>下面按照这个表的顺序一一说明</p>
<h3 id="魔数和版本"><a href="#魔数和版本" class="headerlink" title="魔数和版本"></a>魔数和版本</h3><p><strong>什么是魔数？</strong></p>
<p>Class文件的头4个字节，唯一作用是确定文件是否为一个可被虚拟机接受的Class文件，固定为“0xCAFEBABE”。</p>
<p>紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6两个字节是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version）。</p>
<p><strong>class文件和类、接口的关系？</strong></p>
<p>class文件一定对应着一个类或者接口<br>但是生成class文件的方式很多，甚至可以不作为一个文件存在</p>
<p><strong>class文件版本兼容的问题？</strong></p>
<p>高版本的JDK能够向下兼容低版本的Class文件，虚拟机会拒绝执行超过其版本号的Class文件。</p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p><strong>什么是常量池？</strong></p>
<p>主版本号之后是常量池入口，常量池可以理解为 Class 文件之中的资源仓库，它是 Class 文件结构中与其他项目关联最多的数据类型，也是占用 Class 文件空间最大的数据项目之一，同是它还是 Class 文件中第一个出现的表类型数据项目。</p>
<p>因为常量池中常量的数量是不固定的，所以在常量池入口需要放置一个 u2 类型的数据来表示常量池的容量「constant_pool_count」</p>
<p><strong>为什么要把第0项常量空出来？</strong></p>
<p>之所以将第 0 项常量空出来是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达「不引用任何一个常量池项目」的含义，这种情况可以把索引值置为 0 来表示。</p>
<p><strong>常量池中主要存放什么？</strong></p>
<p>常量池中主要存放两大类常量：字面量和符号引用。</p>
<ul>
<li>字面量比较接近 Java 语言层面的常量概念，如字符串、声明为 final 的常量值等。</li>
<li>符号引用属于编译原理方面的概念，包括了以下三类常量：<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
</li>
</ul>
<p><strong>全限定名？简单名称？描述符？</strong></p>
<ul>
<li>全限定名：用来描述类或接口名，和java中的全限定名有些区别，如java.lang.Object在class中的全限定名是java/lang/Object</li>
<li>简单名称：用来描述字段或者方法，如toString()，的简单名就是toString</li>
<li>描述符：用来描述字段的数据类型，方法的参数和返回。</li>
</ul>
<p><strong>描述符的具体描述规则？</strong></p>
<p><img src="/2019/10/28/JVM/（五）类文件结构/03.png" alt="描述符"></p>
<ol>
<li><p>字段</p>
<p>如：<br>基本类型：int ==&gt; I<br>对象类型：String ==&gt; Ljava/lang/String;<br>数组类型：long[] ==&gt; [J</p>
</li>
<li><p>方法</p>
<p>如：<br>Object m(int i, double d, Thread t) {..} ==&gt; (IDLjava/lang/Thread)Ljava/lang/Object</p>
</li>
</ol>
<p><strong>什么是特征签名？</strong></p>
<ol>
<li>Java语言层面的方法特征签名：特征签名 = 方法名 + 参数类型 + 参数顺序；</li>
<li>JVM层面的方法特征签名：特征签名 = 方法名 + 参数类型 + 参数顺序 + 返回值类型</li>
</ol>
<p><strong>javac编译和C编译的区别?</strong></p>
<p>javac没有“链接”这一阶段，走的是运行时动态链接</p>
<p>常量池表结构：</p>
<p><img src="/2019/10/28/JVM/（五）类文件结构/04.png" alt="常量池表结构"></p>
<p>分析Class字节码的工具：Class文件都是二进制格式，可通过Jdk/bin/javap.exe工具，分析Class文件字节码。关于javap用法，可通过javap –help来查看。</p>
<p>详情可以参考：<a href="https://blog.csdn.net/luanlouis/article/details/40301985" target="_blank" rel="noopener">https://blog.csdn.net/luanlouis/article/details/40301985</a></p>
<h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>2个字节代表，标示用于识别一些类或者接口层次的访问信息.</p>
<p><img src="/2019/10/28/JVM/（五）类文件结构/05.png" alt="访问标志"></p>
<h3 id="类索引、父类索引、接口索引集合"><a href="#类索引、父类索引、接口索引集合" class="headerlink" title="类索引、父类索引、接口索引集合"></a>类索引、父类索引、接口索引集合</h3><ul>
<li>类索引：u2，确定该类的全限定名</li>
<li>父类索引：u2，确定该类的父类的全限定名</li>
<li>接口索引：u2（接口数）+u2[]（接口的全限定名），确定实现了哪些接口</li>
</ul>
<p>索引都会指向常量池中CONSTANT_Class_info类型的常量</p>
<h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><p>字段表用于描述类或接口中声明的变量，格式如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">field_info &#123;</span><br><span class="line">    u2             access_flags; //访问标识</span><br><span class="line">    u2             name_index;  //名称索引</span><br><span class="line">    u2             descriptor_index; //描述符索引</span><br><span class="line">    u2             attributes_count; //属性个数</span><br><span class="line">    attribute_info attributes[attributes_count];  //属性表的具体内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>字段访问标识如下：(表中加粗项是字段独有的)</p>
<p><img src="/2019/10/28/JVM/（五）类文件结构/06.png" alt="字段访问标志"></p>
<p>什么是类型签名？</p>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><p>方法表用于描述类或接口中声明的方法，格式如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">method_info &#123;</span><br><span class="line">    u2             access_flags; //访问标识</span><br><span class="line">    u2             name_index;  //名称索引</span><br><span class="line">    u2             descriptor_index;  //描述符索引</span><br><span class="line">    u2             attributes_count;  //属性个数</span><br><span class="line">    attribute_info attributes[attributes_count]; //属性表的具体内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法访问标识如下：(表中加粗项是方法独有的)</p>
<p><img src="/2019/10/28/JVM/（五）类文件结构/07.png" alt="方法访问标志"></p>
<p><strong>方法中的代码在哪？</strong></p>
<p>对于方法里的Java代码，进过编译器编译成字节码指令后，存放在方法属性表集合中“code”的属性内（属性表见后文介绍）。</p>
<p><strong>父类中的方法需要展示吗？</strong></p>
<p>如果没有覆盖，则不展示</p>
<p><strong>如何区别重载的方法？</strong></p>
<p>根据特征签名：指方法中各个参数在常量池的字段符号引用的集合，不包括返回值。</p>
<blockquote>
<p>上述是java中的，Class文件格式中，特征签名范围更广，包括了返回值</p>
</blockquote>
<h3 id="属性表"><a href="#属性表" class="headerlink" title="属性表"></a>属性表</h3><p>属性表格式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">attribute_info &#123;</span><br><span class="line">    u2 attribute_name_index;   //属性名索引</span><br><span class="line">    u4 attribute_length;       //属性长度</span><br><span class="line">    u1 info[attribute_length]; //属性的具体内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>属性表的限制相对宽松，不需要各个属性表有严格的顺序，只有不与已有的属性名重复，任何自定义的编译器都可以向属性表中写入自定义的属性信息，Java虚拟机运行时会忽略掉无法识别的属性。 关于虚拟机规范中预定义的属性，这里不展开讲了，列举几个常用的。</p>
<p>常用的几个：</p>
<p><img src="/2019/10/28/JVM/（五）类文件结构/08.png" alt="常用属性"></p>
<h4 id="Code属性表"><a href="#Code属性表" class="headerlink" title="Code属性表"></a>Code属性表</h4><p> java程序方法体中的代码，经编译后得到的字节码指令存储在Code属性内，Code属性位于方法表的属性集合中。但与native或者abstract的方法则不会存在Code属性中。</p>
<p>Code是class中非常重要的属性，并可以以此分为两个部分：代码（Code）和元数据（其他）</p>
<p>Code属性的格式如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Code_attribute &#123;</span><br><span class="line">    u2 attribute_name_index; //常量池中的uft8类型的索引，值固定为”Code“</span><br><span class="line">    u4 attribute_length; //属性值长度，为整个属性表长度-6</span><br><span class="line">    u2 max_stack;   //操作数栈的最大深度值，jvm运行时根据该值配置栈帧</span><br><span class="line">    u2 max_locals;  //局部变量栈最大存储空间，单位是slot</span><br><span class="line">    u4 code_length; // 字节码指令的个数</span><br><span class="line">    u1 code[code_length]; // 具体的字节码指令</span><br><span class="line">    u2 exception_table_length; //异常的个数</span><br><span class="line">    &#123;   u2 start_pc;</span><br><span class="line">        u2 end_pc;</span><br><span class="line">        u2 handler_pc; //当字节码在[start_pc, end_pc)区间出现catch_type或子类，则转到handler_pc行继续处理。</span><br><span class="line">        u2 catch_type; //当catch_type=0，则任意异常都需转到handler_pc处理</span><br><span class="line">    &#125; exception_table[exception_table_length]; //具体的异常内容</span><br><span class="line">    u2 attributes_count;     //属性的个数</span><br><span class="line">    attribute_info attributes[attributes_count]; //具体的属性内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>本地局部变量表中存储哪些信息？</strong></p>
<p>入参，局部变量，异常处理器的参数（catch中定义的异常）</p>
<p><strong>为什么没有任何局部变量Locals会等于1？</strong></p>
<p>实例方法中有隐藏参数this, 显式异常处理器的参数，方法体定义的局部变量都使用局部变量表来存放。</p>
<p>另外：max_locals不等于所有局部变量所占Slot之和，因为Slot可以重用，javac编译器会根据变量的作用域来分配Slot给各个变量使用，从而计算出max_locals大小。</p>
<h4 id="异常属性表"><a href="#异常属性表" class="headerlink" title="异常属性表"></a>异常属性表</h4><p>格式如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exceptions_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;//&quot;Exceptions&quot;</span><br><span class="line">    u4 attribute_length;//属性长度，不包括开头6字节</span><br><span class="line">    u2 number_of_exceptions;//异常数</span><br><span class="line">    u2 exception_index_table[number_of_exceptions];//CONSTANT_Class_info索引</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>异常属性表和Code中的异常表的区别？</strong></p>
<p>这里的异常属性表仅表示throw后的异常类</p>
<h4 id="LineNumberTable属性"><a href="#LineNumberTable属性" class="headerlink" title="LineNumberTable属性"></a>LineNumberTable属性</h4><p>Code属性可选的可变长属性。它可以被调试器用来确定哪个Java虚拟机代码阵列的一部分对应于一给定行号的原始源文件中</p>
<p>格式如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LineNumberTable_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;//&quot;LineNumberTable&quot;</span><br><span class="line">    u4 attribute_length;//属性长度，不包括开头6字节</span><br><span class="line">    u2 line_number_table_length;//line_number_table表个数</span><br><span class="line">    &#123;   u2 start_pc;//code属性中的字节码偏移量</span><br><span class="line">        u2 line_number;	//源码中的行号</span><br><span class="line">    &#125; line_number_table[line_number_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="LocalVariableTable属性"><a href="#LocalVariableTable属性" class="headerlink" title="LocalVariableTable属性"></a>LocalVariableTable属性</h4><p>Code属性可选的可变长属性。它可以被调试器使用的方法的执行过程中，以确定给定的本地变量的值以及作为域</p>
<p>格式如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalVariableTable_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;//&quot;LocalVariableTable&quot;</span><br><span class="line">    u4 attribute_length;//属性长度，不包括开头6字节</span><br><span class="line">    u2 local_variable_table_length;</span><br><span class="line">    &#123;   u2 start_pc;//生命周期开始的字节码偏移量</span><br><span class="line">        u2 length;//作用范围长度</span><br><span class="line">        u2 name_index;//CONSTANT_UTF_info索引，名字</span><br><span class="line">        u2 descriptor_index;//CONSTANT_UTF_info索引，描述符</span><br><span class="line">        u2 index;//在局部变量栈中Slot的位置，如果是64位，则占两个Slot</span><br><span class="line">    &#125; local_variable_table[local_variable_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="SourceFile属性"><a href="#SourceFile属性" class="headerlink" title="SourceFile属性"></a>SourceFile属性</h4><p>class文件可选的固定长度的属性。描述文件名，最多只有一个。</p>
<p>格式如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SourceFile_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;//&quot;SourceFile&quot;</span><br><span class="line">    u4 attribute_length;//属性长度，不包括开头6字节</span><br><span class="line">    u2 sourcefile_index;//CONSTANT_UTF_info索引，名字</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="ConstantValue属性"><a href="#ConstantValue属性" class="headerlink" title="ConstantValue属性"></a>ConstantValue属性</h4><p>字段表的定长属性，用来表示字段表中被static修饰的字段</p>
<ul>
<li>类变量: 在类构造器方法或者使用ConstantValue属性来赋值</li>
<li>实例变量：在实例构造器方法进行赋值</li>
</ul>
<p>格式如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ConstantValue_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;//&quot;ConstantValue&quot;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 constantvalue_index;//CONSTANT_Long、CONSTANT_Float等等</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="InnerClasses属性"><a href="#InnerClasses属性" class="headerlink" title="InnerClasses属性"></a>InnerClasses属性</h4><p>class文件中的变长属性，用来表示内部类</p>
<p>格式如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InnerClasses_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;//&quot;InnerClasses&quot;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 number_of_classes;</span><br><span class="line">    &#123;   u2 inner_class_info_index;//指向常量池中CONSTANT_Class_info索引，表示内部类符号引用</span><br><span class="line">        u2 outer_class_info_index;//指向常量池中CONSTANT_Class_info索引，表示宿主类符号引用</span><br><span class="line">        u2 inner_name_index;//指向常量池中CONSTANT_UTF8_info索引，表示内部类名字</span><br><span class="line">        u2 inner_class_access_flags;//访问标志</span><br><span class="line">    &#125; classes[number_of_classes];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Deprecated及Synthetic属性"><a href="#Deprecated及Synthetic属性" class="headerlink" title="Deprecated及Synthetic属性"></a>Deprecated及Synthetic属性</h4><p>Deprecated表示过时，Synthetic表示非用户产生<br>class文件，字段，方法可选属性，只包含前6个简单字节</p>
<h4 id="StackMapTable属性"><a href="#StackMapTable属性" class="headerlink" title="StackMapTable属性"></a>StackMapTable属性</h4><p>Code属性中复杂的变长属性，在字节码加载时被新类检查验证器（Type Checker）使用，用来校验字节码的合法性</p>
<h4 id="Signature属性"><a href="#Signature属性" class="headerlink" title="Signature属性"></a>Signature属性</h4><p>class文件、字段表、方法表的可选定长属性，用来表示泛型类型<br>格式如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Signature_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;//&quot;Signature&quot;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 signature_index;//CONSTANT_Utf8_info</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="BootstrapMethods属性"><a href="#BootstrapMethods属性" class="headerlink" title="BootstrapMethods属性"></a>BootstrapMethods属性</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONSTANT_InvokeDynamic_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 bootstrap_method_attr_index;//BootstrapMethods_attribute</span><br><span class="line">    u2 name_and_type_index;//CONSTANT_NameAndType_info</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BootstrapMethods_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 num_bootstrap_methods;</span><br><span class="line">    &#123;   u2 bootstrap_method_ref;// CONSTANT_MethodHandle_info</span><br><span class="line">        u2 num_bootstrap_arguments;</span><br><span class="line">        u2 bootstrap_arguments[num_bootstrap_arguments];//入参</span><br><span class="line">    &#125; bootstrap_methods[num_bootstrap_methods];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONSTANT_MethodHandle_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u1 reference_kind;</span><br><span class="line">    u2 reference_index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CONSTANT_MethodType_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 descriptor_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/10/28/JVM/（五）类文件结构/09.png" alt="MethodHandle_info中的类型"></p>
<p>复杂属性，和InvokeDynamic指令密切相关</p>
<h2 id="字节码指令介绍"><a href="#字节码指令介绍" class="headerlink" title="字节码指令介绍"></a>字节码指令介绍</h2><p>Java虚拟机采用基于栈的架构，其指令由操作码和操作数组成。</p>
<p>操作码：一个字节长度(0~255)，意味着指令集的操作码个数不能操作256条。<br>操作数：一条指令可以有零或者多个操作数，且操作数可以是1个或者多个字节。编译后的代码没有采用操作数长度对齐方式，比如16位无符号整数需使用两个字节储存(假设为byte1和byte2)，那么真实值是 (byte1 &lt;&lt; 8) | byte2。</p>
<p><strong>放弃操作数对齐意味着什么？</strong></p>
<ul>
<li>优势：可以省略很多填充和间隔符号，从而减少数据量，具有更高的传输效率；Java起初就是为了面向网络、智能家具而设计的，故更加注重传输效率。</li>
<li>劣势：运行时从字节码里构建出具体数据结构，需要花费部分CPU时间，从而导致解释执行字节码会损失部分性能。</li>
</ul>
<p><strong>一个字节长度的指令集带来的限制？</strong></p>
<p>Java虚拟机的指令集对于特定操作只提供有限的类型相关指令，并非为每一种数据类型都有相应的操作指令。必要时，有些指令可用于将不支持的类型转换为可被支持的类型。</p>
<p><strong>如何保证同步开始的指令无论是否异常一定被释放？</strong></p>
<p>编译器会自动生成一个异常处理器</p>
<p>指令参考：<a href="http://gityuan.com/2015/10/24/jvm-bytecode-grammar/" target="_blank" rel="noopener">http://gityuan.com/2015/10/24/jvm-bytecode-grammar/</a></p>
<h2 id="共有设计和私有实现"><a href="#共有设计和私有实现" class="headerlink" title="共有设计和私有实现"></a>共有设计和私有实现</h2><h2 id="Class文件的发展历史"><a href="#Class文件的发展历史" class="headerlink" title="Class文件的发展历史"></a>Class文件的发展历史</h2>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>（十）高效并发</title>
    <url>/2019/12/20/JVM/%EF%BC%88%E5%8D%81%EF%BC%89%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h1 id="高效并发"><a href="#高效并发" class="headerlink" title="高效并发"></a>高效并发</h1><p>本章主要内容：</p>
<ol>
<li>了解并发问题中的可见性、有序性和原子性问题</li>
<li>了解JAVA内存模型以及如何解决并发问题</li>
<li>了解先行发生原则</li>
<li>了解线程在JAVA中的实现</li>
</ol>
<h2 id="硬件的效率和一致性"><a href="#硬件的效率和一致性" class="headerlink" title="硬件的效率和一致性"></a>硬件的效率和一致性</h2><p><strong>物理计算机中的并发问题是什么？</strong></p>
<ol>
<li>可见性问题：本质上是缓存一致性问题，</li>
<li>有序性问题：指令乱序执行优化和指令重排序问题：为了优化指令执行效率，处理器会对指令进行乱序执行处理（单线程中指令重排后的结果和顺序执行一样，所以主要是针对多线程情况，也就是“在一个线程中观察本线程，一切都是有序的，在一个线程中观察另一个线程，所有的操作都是无序的”）</li>
<li>原子性问题：任务调度导致查询和修改分离，修改时已经不是真实的数值。</li>
</ol>
<p><img src="/2019/12/20/JVM/（十）高效并发/02.png" alt="缓存一致性问题"></p>
<p><strong>重排序具体会导致什么问题？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecordExample2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A线程执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;                  <span class="comment">// 1</span></span><br><span class="line">        flag = <span class="keyword">true</span>;            <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * B线程执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;                  <span class="comment">// 3</span></span><br><span class="line">           <span class="keyword">int</span> i = a + a;          <span class="comment">// 4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述案例中第1步和第2步的顺序会影响第4步结果</p>
<p><strong>什么是内存屏障？</strong></p>
<p>内存屏障是被插入两个CPU指令之间的一种指令，用来禁止处理器把内存屏障后面的指令重排序从排序到前面（像屏障一样），从而保障有序性的。另外，为了达到屏障的效果，它也会使处理器写入、读取值之前，将写缓冲器的值写入高速缓存，清空无效队列（数据到了高速缓存之后，缓存一致性协议就可以生效了），从而“附带”的保障了可见性。</p>
<h2 id="JAVA内存模型"><a href="#JAVA内存模型" class="headerlink" title="JAVA内存模型"></a>JAVA内存模型</h2><p><strong>建立java内存模型是为了解决什么问题？</strong></p>
<p>不同的处理器架构有着不同的内存模塑，因此这些处理器对有序性的保障程度各异，这表现为它们所支持的内存重排序不同（读读，读写，写读，写写）。</p>
<p>Java 作为一个跨平台（ 跨操作系统和硬件）的语言，为了屏蔽不同处理器的内存模型差异，以便Java应用开发人员不必根据不同的处理器编写不同的代码，它必须定义自己的内存模型，这个模型就被称为Java内存模型（JMM）。</p>
<p>JMM还可以由以下几点概括：</p>
<ol>
<li>JMM是Java的虚拟机规范，是一种<code>抽象</code>的概念</li>
<li>目的是保证多线程读写共享变量时的安全问题（提供Java关键字，内存屏障是实现volatile、synchronized、final等关键字的底层原理）</li>
<li>同时在各种平台架构下都能达到一致的内存访问效果</li>
</ol>
<p>为了解决并发问题，JMM保证线程安全是围绕原子性、可见性、有序性这3个特性来建立的，缺一不可。</p>
<p><strong>JMM和JVM的区别？</strong></p>
<p>JMM是规范，JVM是实现</p>
<p><strong>JMM的内容？</strong></p>
<p>JMM规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。</p>
<blockquote>
<p>此时的变量不同于Java编程中的变量，它包括了实例字段、静态字段、构成数组对象的元素，不包括局部变量与方法参数，因为它们是线程私有的，不会被共享，JMM不关心非共享数据。</p>
</blockquote>
<p><img src="/2019/12/20/JVM/（十）高效并发/01.png" alt="JMM"></p>
<p><strong>和JAVA内存区域有何关系？</strong></p>
<p>主内存和工作内存与JVM内存结构中的Java堆、栈、方法区等并不是同一个层次的内存划分，无法直接类比。《深入理解Java虚拟机》中认为，如果一定要勉强对应起来的话，从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分。工作内存则对应于虚拟机栈中的部分区域。</p>
<p><strong>主内存和工作内存的交互协议？</strong></p>
<p>JMM定义了八大原子操作（针对double、long有特殊情况）</p>
<ul>
<li>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。</li>
<li>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li>
<li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li>
<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li>
<li>write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</li>
</ul>
<p>规定了在执行上述八种基本操作时，必须满足如下规则：</p>
<ul>
<li>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。</li>
<li>不允许read和load、store和write操作之一单独出现</li>
<li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。</li>
<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。</li>
<li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</li>
<li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现</li>
<li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值</li>
<li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</li>
<li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</li>
</ul>
<p>上面八个操作+规则+volatile就可以正确解决并发问题</p>
<p><strong>volatile的作用？</strong></p>
<ol>
<li>保障可见性：<ul>
<li>写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存</li>
<li>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。</li>
</ul>
</li>
<li>保证有序性：类似内存屏障的功能</li>
<li>不保证原子性：如i++</li>
</ol>
<p><strong>volatile底层实现？</strong></p>
<p>volatile变量instance赋值的地方，增加了一条“lock add dword ptr [rsp],0h”指令（汇编）<br>该指令相当于一个内存屏障</p>
<p><strong>java内存模型如何解决原子性问题？</strong></p>
<ul>
<li>synchronized：底层是对lock和unlock操作的运用。</li>
</ul>
<p><strong>java内存模型如何解决可见性问题？</strong></p>
<ul>
<li>volatile：本身语义</li>
<li>synchronized：底层是对lock和unlock操作的运用。同步块的可见性是由“如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值”、“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store和write操作）”这两条规则获得的。</li>
<li>final：final关键字的可见性是指，被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程就能看见final字段的值（无须同步）</li>
</ul>
<p><strong>java内存模型如何解决有序性问题？</strong></p>
<ul>
<li>volatile：本身语义</li>
<li>synchronized：底层是对lock和unlock操作的运用，由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入</li>
</ul>
<p><strong>什么是“先行发生原则”？有什么意义？</strong></p>
<p>先行发生是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到。</p>
<p><code>先行发生原则</code>的意义简单的理解就是说：代替JMM规范，忽略底层指令真实执行过程，给程序员一个直观的参考，<code>程序的执行顺序和happens-before原则规定的顺序一致！</code>，在有并发问题时正确编写安全的代码。</p>
<p><strong>happens-before与时间关系？</strong></p>
<p>两个操作之间具有 happens-before 关系,并不意味着前一个操作必须要在后一个操作之前执行，它和时间没什么关系。</p>
<p><strong>happens-before规则：</strong></p>
<ol>
<li>单线程happen-before原则：在同一个线程中，书写在前面的操作happen-before后面的操作。</li>
<li>锁的happen-before原则：同一个锁的unlock操作happen-before此锁的lock操作。</li>
<li>volatile的happen-before原则：对一个volatile变量的写操作happen-before后续（指时间的后续）对此变量的任意操作。</li>
<li>happen-before的传递性原则：如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before C操作。</li>
<li>线程启动的happen-before原则：同一个线程的start方法happen-before此线程的其它方法。</li>
<li>线程中断的happen-before原则：对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。</li>
<li>线程终结的happen-before原则：线程中的所有操作都happen-before线程的终止检测。</li>
<li>对象创建的happen-before原则：一个对象的初始化完成先于他的finalize方法调用。</li>
</ol>
<h2 id="JAVA与线程"><a href="#JAVA与线程" class="headerlink" title="JAVA与线程"></a>JAVA与线程</h2><p>线程中的方法大都是Native方法，一个Native方法往往意味着使用平台相关的代码来实现</p>
<p><strong>线程模型有哪些？JAVA如何实现线程？</strong></p>
<p>实现线程主要有 3 种方式：使用内核线程实现、使用用户线程实现、使用用户线程加轻量级进程混合实现。</p>
<p>Java 线程在 JDK 1.2 之前是基于称为「绿色线程」的用户线程实现的。而在 JDK 1.2 中，线程模型替换为基于操作系统原生线程模型来实现。</p>
<p><strong>线程调度的方式？</strong></p>
<p>主要调度方式有两种，分别是协同式线程调度和抢占式线程调度：</p>
<ol>
<li>协同式线程调度：线程的执行时间由线程本身来控制，线程把自己的工作执行完之后，要主动通知系统切换到另外一个线程上。<ul>
<li>优势：协同式多线程的最大好处是实现简单，而且由于线程要把自己的事情做完后才会进行线程切换，切换操作对线程自己是可知的，所有没有线程同步的问题。</li>
<li>劣势：线程执行时间不可控，甚至如果一个线程编写有问题，一直不告诉操作系统进行线程切换，那么程序就会一直阻塞在那里。</li>
</ul>
</li>
<li>抢占式线程调度：那么每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定。在这种实现线程调度的方式下，线程的执行实现是系统可控的，也不会有一个线程导致整个进程阻塞的问题。</li>
</ol>
<p>Java使用的线程调度方式就是抢占式的。</p>
<p><strong>如何给一个线程分配更多的执行时间？</strong></p>
<p>给线程设置优先级，有两点需要注意：</p>
<ol>
<li>这里的优先只是建议，并不一定先发生</li>
<li>JAVA线程优先级和概念和操作系统线程优先级的概念并不一一对应</li>
</ol>
<p><strong>线程状态有什么意义？</strong></p>
<ul>
<li>新建（New）：创建后尚未启动的线程处于这种状态；</li>
<li>运行（Runnable）：Runnable 包括了操作系统线程状态中的 Running 和 Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着 CPU 为它分配执行时间；</li>
<li>无限期等待（Waiting）：处于这种状态的线程不会被分配 CPU 执行时间，它们要等待被其它线程显式地唤醒；以下三种方法会让线程进入无限期等待状态：<ul>
<li>没有设置 TimeOut 参数的 Object.wait()；</li>
<li>没有设置 TimeOut 参数的 Thread.join()；</li>
<li>LockSupport.park()。</li>
</ul>
</li>
<li>限期等待（Timed Waiting）：处于这种状态的线程也不会被分配 CPU 执行时间，不过无需等待被其它线程显式地唤醒，在一定时间之后它们会由系统自动唤醒；以下方法会让线程进入限期等待状态：<ul>
<li>Thread.sleep()；</li>
<li>设置了 TimeOut 参数的 Object.wait()；</li>
<li>设置了 TimeOut 参数的 Thread.join()；</li>
<li>LockSupport.parkNanos()；</li>
<li>LockSupport.parkUntil()。</li>
</ul>
</li>
<li>阻塞（Blocked）：线程被阻塞了，「阻塞状态」和「等待状态」的区别是：「阻塞状态」在等待着获取一个排他锁，这个事件将在另一个线程放弃这个锁的时候发生；而「等待状态」则是在等待一段时间，或者唤醒动作的发送。在程序等待进入同步区域时，线程将进入这种状态；</li>
<li>结束（Terminated）：线程已经结束执行。</li>
</ul>
<p><img src="/2019/12/20/JVM/（十）高效并发/03.png" alt="线程状态的转换"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>（十一）线程安全与锁优化</title>
    <url>/2019/12/24/JVM/%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="线程安全与锁优化"><a href="#线程安全与锁优化" class="headerlink" title="线程安全与锁优化"></a>线程安全与锁优化</h1><p>本章主要内容：</p>
<ol>
<li>线程安全所涉及的概念和分类</li>
<li>同步实现的方法及虚拟机的底层的运作与阿里</li>
<li>虚拟机为了实现高效并发所采取的一系列锁优化措施</li>
</ol>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>面向过程：会把数据和过程看成两个独立的部分分别处理，数据表示问题空间的客体，过程用于处理这些数据<br>面向对象：数据和行为都是对象的一部分，更符合现实世界的思维方式</p>
<p><strong>什么是线程安全？</strong></p>
<p>当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。（绝对线程安全，条件很苛刻）</p>
<p><strong>JAVA中线程安全的5个级别</strong></p>
<p>讨论线程安全，就限定于多个线程之间存在共享数据访问这个前提，因为如果一段代码根本不会与其他线程共享数据，那么从线程安全的角度来看，程序是串行执行还是多线程执行对它来说是完全没有区别的。我们将Java语言中各种操作共享的数据分为以下5类：不可变、绝对线程安全、相对线程安全、线程兼容和线程独立。</p>
<ol>
<li>不可变：在Java语言中，不可变的对象一定是线程安全的。基本数据类型采用final关键字修饰，如果是对象则需要保证自己的行为不会影响状态，例如String的replace()等方法都是产生新的对象。<br>例如，JDK中Integer类的构造函数：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;  </span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Constructs a newly allocated &#123;<span class="doctag">@code</span> Integer&#125; object that</span></span><br><span class="line"><span class="comment">  * represents the specified &#123;<span class="doctag">@code</span> int&#125; value.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>   value   the value to be represented by the</span></span><br><span class="line"><span class="comment">  *                  &#123;<span class="doctag">@code</span> Integer&#125; object.</span></span><br><span class="line"><span class="comment">  */</span>  </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">this</span>.value = value;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>绝对线程安全：绝对的线程安全就是前面的提到的定义，这个定义很严格，一个类要达到「不管运行时环境如何，调用者都不需要任何额外的同步措施」通常需要付出很大的，甚至有时候是不切实际的代价。在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。<br>例如Vector，加入同步以保证Vector访问的线程安全性：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread removeThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">synchronized</span>(vector) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;  </span><br><span class="line">                vector.remove(i);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line">Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">synchronized</span>(vector) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;  </span><br><span class="line">                System.out.println(vector.get(i));  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>相对的线程安全：就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外保障措施。在Java语言中，大部分的线程安全类都属于这种类型，例如Vector、HashTable等。</li>
<li>线程兼容：线程兼容是指对象本身并不是线程安全的，但是可以通过调用端正确地使用同步手段来保证对象在并发环境中可以安全的使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。</li>
<li>线程对立：指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。一个线程对立的例子是Thread类的suspend()和resume()方法，如果并发进行的话，无论调用时是否进行了同步，目标线程都是存在死锁风险的，如果suspend()中断的线程就是即将要执行resume()的那个线程，那肯定就要产生死锁了。</li>
</ol>
<p><strong>如何实现线程安全？</strong></p>
<ol>
<li>互斥同步：互斥是因，同步是果；互斥是方法，同步是目的。</li>
<li>非阻塞同步：解决互斥同步进行线程阻塞和唤醒所带来的性能问题</li>
<li>无同步方案：如果一个方法本来就不涉及共享数据，那它就无须任何同步措施去保证正确性。</li>
</ol>
<p><strong>可重入锁是什么意思？</strong></p>
<p>线程可以进入任何一个它已经拥有的锁所同步着的代码块。意味着可以进行递归</p>
<p><strong>ReentrantLock和Synchronized区别？</strong></p>
<p>synchronized是原生语法层面的实现。ReentrantLock是API层面，使用lock()和unlock()方法配合try/finally语句块来实现。</p>
<p>ReentrantLock有三个高级特性：</p>
<ol>
<li>等待可中断：当持有锁的线程长期不释放锁时，正在等待的线程可以选择放弃等待，改为处理其他事情。可中断特性对处理执行时间非常长的同步块很有帮助。</li>
<li>可实现公平锁：公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。</li>
<li>锁可以绑定多个条件：一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait()和notify()或notifyAll()方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则无须这样做，只需要多次调用newCondition()方法即可。</li>
</ol>
<p><strong>如何理解阻塞同步？</strong></p>
<p>通俗理解：到我的工作时间，却因为拿不到资源而无法工作，只能转让别人，而这个转让的手续又比较复杂。</p>
<p><strong>什么是悲观和乐观？</strong></p>
<p>悲观并发策略：认为只要不作同步，就一定会出现问题<br>乐观并发策略：认为一般情况下都没有数据竞争，可以不作同步，若真发生共享数据争用，再采取补偿措施</p>
<p><strong>为什么乐观策略需要“硬件指令集的发展”？</strong></p>
<p>乐观策略需要在<code>更新时判断是否发生数据冲突</code>，这两步操作需要合成一个原子指令（称为CAS操作），这需要硬件指令集的支持</p>
<blockquote>
<p>当然也可以用互斥同步，但是这样就失去了乐观策略的意义</p>
</blockquote>
<p><strong>CAS的“ABA”问题是什么？如何解决？</strong></p>
<p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然为A值，那我们就能说它的值没有被其他线程改变过了吗？如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。</p>
<p><strong>如何判断一个方法是可重入的？</strong></p>
<p>返回结果是可预测的，只要输入相同，返回也就相同</p>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p><strong>自旋锁解决什么问题？如何工作？</strong></p>
<p>线程阻塞的时候，让等待的线程不放弃cpu执行时间，而是执行一个自旋(一般是空循环)，这叫做自旋锁。</p>
<p>自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，如果锁被占用的时间很短，自旋等待的效果就非常好，反之，如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，带来性能上的浪费。因此，自旋等待的时间必须要有一定的限度。</p>
<p><strong>锁消除解决什么问题？如何工作？</strong></p>
<p>虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。一般根据逃逸分析的数据支持来作为判定依据。</p>
<p><strong>锁粗化解决什么问题？如何工作？</strong></p>
<p>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。</p>
<p>但如果一系列操作频繁对同一个对象加锁解锁，或者加锁操作再循环体内，会耗费性能，这时虚拟机会扩大加锁范围。</p>
<p><strong>轻量级锁和偏向锁解决什么问题？如何工作？</strong></p>
<p>轻量级锁是JDK 1.6之中加入的新型锁机制。它的作用是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。<br>偏向锁也是JDK1.6中引入的锁优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。</p>
<p><img src="/2019/12/24/JVM/（十一）线程安全与锁优化/01.png" alt="mark word"></p>
<p><img src="/2019/12/24/JVM/（十一）线程安全与锁优化/02.png" alt="锁的状态转换"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>（四）调优案例分析和实战</title>
    <url>/2019/10/17/JVM/%EF%BC%88%E5%9B%9B%EF%BC%89%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%92%8C%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="调优案例分析和实战"><a href="#调优案例分析和实战" class="headerlink" title="调优案例分析和实战"></a>调优案例分析和实战</h1><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><h3 id="高性能硬件上的程序部署策略"><a href="#高性能硬件上的程序部署策略" class="headerlink" title="高性能硬件上的程序部署策略"></a>高性能硬件上的程序部署策略</h3><p>案例：一个15万PV/天左右的在线文档类型网站最近更换了硬件系统，新的硬件为4个CPU、16GB物理内存，操作系统为64位CentOS 5.4 ，Resin作为Web服务器。整个服务器暂时没有部署别的应用，所有硬件资源都可以提供给这访问量并不算太大的网站使用。管理员为了尽量利用硬件资源选用了64位的JDK1.5，并通过-Xmx和-Xms参数将Java堆固定在12GB。使用一段时间后发现使用效果并不理想，网站经常不定期出现长时间失去响应的情况。</p>
<p><strong>在高性能硬件上部署程序有哪些方式？</strong></p>
<ul>
<li>通过64位JDK来使用大内存</li>
<li>使用若干个32位虚拟机建立逻辑集群来利用硬件资源</li>
</ul>
<p><strong>64位JDK和32位JDK的区别？</strong></p>
<p>32位的jdk内存大小最大为4G</p>
<p><strong>使用64位JDK管理大内存的优势和问题？</strong></p>
<p>优势：能够使用的内存空间更多了</p>
<p>问题：</p>
<ul>
<li>内存太大，回收导致的长时间停顿</li>
<li>无法产生堆转储快照（太大了）</li>
<li>相同程序在64位JDK消耗的内存一般比32位JDK大 ，这是由于指针膨胀，以及数据类型对齐补白等因素导致的。</li>
</ul>
<p>对于用户交互性强、对停顿时间敏感的系统，可以给Java虚拟机分配超大堆的前提是有把握把应用程序的Full GC频率控制得足够低，至少要低到不会影响用户使用，譬如十几个小时乃至一天才出现一次Full GC。</p>
<p><strong>如何控制好GC的低频率？</strong></p>
<p>控制Full GC频率的关键是看应用中绝大多数对象能否符合“朝生夕灭”的原则，即大多数对象的生存时间不应太长，尤其是不能有成批量的、长生存时间的大对象产生，这样才能保障老年代空间的稳定。</p>
<p><strong>什么是session同步？为什么需要进行session同步？</strong></p>
<p>session是存储在服务器的访问信息<br>不同服务器之间可能会不同，如果不同步，由于负载均衡可能导致下次访问失效</p>
<p><strong>session同步的几种方式？</strong></p>
<ul>
<li>进程间通信传递session：比如不同的服务器中建立socket链接，然后用socket来将相互拥有的session数据进行传递。早期的tomcat使用的方式</li>
<li>全局缓存或者使用数据库做session管理</li>
</ul>
<p><strong>什么是亲合式的集群？</strong></p>
<ul>
<li>亲和性可以实现就近部署，增强网络能力实现通信上的就近路由，减少网络的损耗。</li>
<li>反亲和性主要是出于高可靠性考虑，尽量分散实例，某个节点故障的时候，对应用的影响只是 N 分之一或者只是一个实例。</li>
</ul>
<p>亲和性集群可以使均衡器按一定的规则算法将一个固定的用户请求永远分配到固定的一个集群节点进行处理，因此不需要进行session同步。</p>
<p><strong>使用若干个32位虚拟机建立逻辑集群来利用硬件资源的优势和问题？</strong></p>
<p>具体做法是在一台物理机器上启动多个应用服务器进程 ，每个服务器进程分配不同端口，然后在前端搭建一个负载均衡器，以反向代理的方式来分配访问请求。考虑到在一台物理机器上建立逻辑集群的目的仅仅是为了尽可能利用硬件资源，并不需要关心状态保留、热转移之类的高可用性需求，也不需要保证每个虚拟机进程有绝对准确的均衡负载，因此使用无Session复制的亲合式集群是一个相当不错的选择。</p>
<h3 id="集群间同步导致的内存溢出"><a href="#集群间同步导致的内存溢出" class="headerlink" title="集群间同步导致的内存溢出"></a>集群间同步导致的内存溢出</h3><p>案例：有一个基于B/S的MIS系 统 ，硬件为两台2个CPU、8GB内存的HP小型机，服务器是WebLogic 9.2 ，每台机器启动了3个WebLogic实 例 ，构成一个6个节点的亲合式集群。由于是亲合式集群，节点之间没有进行Sessurn同步，但是有一些需求要实现部分数据在各个节点间共享。开始这些数据存放在数据库中，但由于读写频繁竞争很激烈，性能影响较大，后面 使用JBossCache构建了 一个全局缓存。全局缓存启用后，服务正常使用了一段较长的时间， 但最近却不定期地出现了多次的内存溢出问题。</p>
<p><strong>什么是JBossCache和JGroups？</strong></p>
<p>JBossCache是一种全局缓存<br>JGroups是JBossCache实现集群节点通讯的协议</p>
<p><strong>JGroups通讯方式导致的内存溢出问题？</strong></p>
<p>由于JGroups的重发机制，每份发出的数据都会有在本地内存有一份短暂的保留。与此同时。MIS的服务端中有一个负责安全校验的全局Filter，每鈑接收到请求时，均会更新一次最后操作时间，并且将这个时间同步到所有的节点去，使得一个用户在一段时间内不能在多台机器上登录。在服务使用过程中，往往一个页面会产生数次乃至数十次的请求，因此这个过滤器导致集群各个节点之间网络交互非常频繁。当网络情况不能满足传输要求时，重发数据在内存中不断堆积，很快就产生了内存溢出。</p>
<h3 id="堆外内存导致的溢出错误"><a href="#堆外内存导致的溢出错误" class="headerlink" title="堆外内存导致的溢出错误"></a>堆外内存导致的溢出错误</h3><p>案例：一个学校的小型项目:基于B/S的电子考试系统，为了实现客户端能实时地从服务器端接收考试数据 ， 系统使用了逆向AJAX技术(也称为Comet或者Server Side Push) ，选用CometD 1.1.1作为服务端推送框架，服务器是Jetty 7.1 .4 ，硬件为一台普通PC机 ， Core i5 CPU ， 4GB内存，运行32位Windows操作系统。</p>
<p><strong>什么时候对DirectMemory进行回收？</strong></p>
<p>只能等待老年代满了后Full GC，然后“顺便地”帮它清理掉内存的废弃对象。</p>
<p><strong>上面案例造成溢出的原因？</strong></p>
<p>这台服务器使用的32位 Windows平台的限制是2GB，其中划了1.6GB给Java堆，而Direct Memory内存并不算入1.6GB的堆之内，因此它最大也只能在剩余的0.4GB空间中分出一部分。</p>
<p><strong>还有哪些容易造成堆外内存溢出的区域？</strong></p>
<ul>
<li>Direct Memory:可通过-XX:MaxDirectMemorySize调整大小，内存不足时拋出OutOfMemoryError或者OutOfMemoryError:Direct buffer memory。</li>
<li>线程堆栈:可通过-Xss调整大小，内存不足时拋出StackOverflowError (纵向无法分配， 即无法分配新的栈帧)或者OutOfMemoryError : unable to create new native thread (横向无法分配 ，即无法建立新的线程)。</li>
<li>Socket缓存区:每个Socket连接都Receive和Send两个缓存区，分别占大约37KB和25KB内存，连接多的话这块内存占用也比较可观。如果无法分配，则可能会拋出IOException : Too many open files异常。</li>
<li>JNI代码:如果代码中使用JNI调用本地库，那本地库使用的内存也不在堆中。</li>
<li>虚拟机和GC:虚拟机、GC的代码执行也要消耗一定的内存。</li>
</ul>
<h3 id="外部命令导致系统缓慢"><a href="#外部命令导致系统缓慢" class="headerlink" title="外部命令导致系统缓慢"></a>外部命令导致系统缓慢</h3><p>案例：一个数字校园应用系统，运行在一台4个CPU的Solaris 10操作系统上，中间件为GlassFish服务器。系统在做大并发压力测试的时候，发现请求响应时间比较慢 ，通过操作系统的mpstat工具发现CPU使用率很高 ，并且系统占用绝大多数的CPU资源的程序并不是应用系统本身。</p>
<p><strong>为什么外部命令会导致系统缓慢？</strong></p>
<p>每个用户请求的处理都需要执行一个外部shell脚本来获得系统的一些信息。实际上也是这个脚本导致每次都回去fork一个新进程，吃了大量资源。<br>外部命令不属于java内存的管理范畴，所以无法监控到。</p>
<p><strong>解决方案</strong>：建议去掉这个Shell脚本执行的语句，改为使用Java的API去获取这些信息后，系统很快恢复了正常。</p>
<h3 id="服务器JVM进程崩溃"><a href="#服务器JVM进程崩溃" class="headerlink" title="服务器JVM进程崩溃"></a>服务器JVM进程崩溃</h3><p>案例：一个基于B/S的MIS系统，硬件为两台2个CRJ、8GB内存的HP系统，服务器是 WebLogic 9.2。正常运行一段时间后，最近发现在运行期间频繁出现集群节点的虚拟机进程自动关闭的现象，留下了一个hs_err_pid/#/#/#.log文件后，进程就消失了，两台物理机器里的每个节点都出现过进程崩溃的现象。从系统日志中可以看出，每个节点的虚拟机进程在崩溃前不久，都发生过大量相同的异常:SocketException</p>
<p><strong>为什么服务器中过多异步http调用会导致服务器崩溃？</strong></p>
<p>过多异步http调用导致在等待的线程和Socket连接越来越多，最终在超过虚拟机的承受能力后使得虚拟机进程崩溃。</p>
<p><strong>解决方法</strong>:通知OA门户方修复无法使用的集成接口，并将异步调用改为生产者/消费者模式的消息队列实现后，系统恢复正常。</p>
<h3 id="不恰当的数据结构导致内存占用过大"><a href="#不恰当的数据结构导致内存占用过大" class="headerlink" title="不恰当的数据结构导致内存占用过大"></a>不恰当的数据结构导致内存占用过大</h3><p>案例：有一个后台RPC服务器，使用64位虚拟机，内存配置为-Xms4g-Xmx8g-Xmnlg，使用ParNew+CMS的收集器组合。平时对外服务的Minor GC时间约在30毫秒以内，完全可以接受。但业务上需要每10分钟加载一个约80MB的数据文件到内存进行数据分析，这些数据会在内存中形成超过100万个HashMap&lt;Long，Long&gt;Entry，在这段时间里面Minor GC就会造成超过500毫秒的停顿，对于这个停顿时间就接受不了了。</p>
<p><strong>使用一个100W大小的haspMap会导致的GC问题？</strong></p>
<p>ParNew收集器使用的是复制算法，这个算法的高效是建立在大部分对象都“朝生夕灭”的特性上的，如果存活对象过多，把这些对象复制到Survivor并维持这些对象引用的正确就成为一个沉重的负担，因此导致GC暂停时间明显变长。</p>
<p><strong>解决方案</strong>：加入参数-XX:SurvivorRatio=65536、-XX:MaxTenuringThreshold=0或者-XX:+AlwaysTenure，让新生代中存活的对象在第一次Minor GC后立即进入老年代，等到Major GC的时候再清理它们。这个方案治标不治本。</p>
<p><strong>hashMap的空间效率？</strong></p>
<p>在HashMap&lt;Long，Long&gt;结构中，只有Key和Value所存放的两个长整型数据是有效数据，共16B( 2x8B )。</p>
<p>这两个长整型数据包装成java.lang.Long对象之后，就分别具有8B的MarkWord、8B的Klass指针，在加8B存储数据的long值。在这两个Long对贏组成Map.Entry之后，又多了16B的对象头，然后一个8B的next字段和4B的int型的hash字段，为了对齐，还必须添加4B的空白填充，最后还有HashMap中对这个Entry的8B的引用，这样增加两个长整型数字，实际耗费的内存为(Long(24B)x2)+Entry(32B)+HashMap Ref(8B)=88B，空间效率为16B/88B=18%，实在太低了。</p>
<h2 id="Eclipse运行速度调优"><a href="#Eclipse运行速度调优" class="headerlink" title="Eclipse运行速度调优"></a>Eclipse运行速度调优</h2>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA8 时间</title>
    <url>/2019/07/02/Java/JAVA8%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="JAVA8-时间"><a href="#JAVA8-时间" class="headerlink" title="JAVA8 时间"></a>JAVA8 时间</h1><p>java8非常精确的区别“时间”和“日期”两个概念</p>
<h2 id="表示时间的类"><a href="#表示时间的类" class="headerlink" title="表示时间的类"></a>表示时间的类</h2><h3 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h3><p>表示日期</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate now = LocalDate.now();                    <span class="comment">//获取当前日期</span></span><br><span class="line">LocalDate localDate = LocalDate.of(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">4</span>);     <span class="comment">// 初始化一个日期：2017-01-04</span></span><br><span class="line"><span class="keyword">int</span> year = localDate.getYear();                     <span class="comment">// 年份：2017</span></span><br><span class="line">Month month = localDate.getMonth();                 <span class="comment">// 月份：JANUARY</span></span><br><span class="line"><span class="keyword">int</span> dayOfMonth = localDate.getDayOfMonth();         <span class="comment">// 月份中的第几天：4</span></span><br><span class="line">DayOfWeek dayOfWeek = localDate.getDayOfWeek();     <span class="comment">// 一周的第几天：WEDNESDAY</span></span><br><span class="line"><span class="keyword">int</span> length = localDate.lengthOfMonth();             <span class="comment">// 月份的天数：31</span></span><br><span class="line"><span class="keyword">boolean</span> leapYear = localDate.isLeapYear();          <span class="comment">// 是否为闰年：false</span></span><br></pre></td></tr></table></figure>
<h3 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h3><p>表示时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalTime localTime = LocalTime.of(<span class="number">17</span>, <span class="number">23</span>, <span class="number">52</span>);     <span class="comment">// 初始化一个时间：17:23:52</span></span><br><span class="line"><span class="keyword">int</span> hour = localTime.getHour();                     <span class="comment">// 时：17</span></span><br><span class="line"><span class="keyword">int</span> minute = localTime.getMinute();                 <span class="comment">// 分：23</span></span><br><span class="line"><span class="keyword">int</span> second = localTime.getSecond();                 <span class="comment">// 秒：52</span></span><br></pre></td></tr></table></figure>
<h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><p>LocalDate和LocalTime的结合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化，方式一</span></span><br><span class="line">LocalDateTime ldt1 = LocalDateTime.of(<span class="number">2017</span>, Month.JANUARY, <span class="number">4</span>, <span class="number">17</span>, <span class="number">23</span>, <span class="number">52</span>);</span><br><span class="line"><span class="comment">//初始化，方式二</span></span><br><span class="line">LocalDate localDate = LocalDate.of(<span class="number">2017</span>, Month.JANUARY, <span class="number">4</span>);</span><br><span class="line">LocalTime localTime = LocalTime.of(<span class="number">17</span>, <span class="number">23</span>, <span class="number">52</span>);</span><br><span class="line">LocalDateTime ldt2 = localDate.atTime(localTime);</span><br><span class="line"><span class="comment">//转换</span></span><br><span class="line">LocalDate date = ldt1.toLocalDate();</span><br><span class="line">LocalTime time = ldt1.toLocalTime();</span><br></pre></td></tr></table></figure>
<h3 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h3><p>时间戳，精确到纳秒</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Instant instant1 = Instant.now();                      <span class="comment">//获取当前时间</span></span><br><span class="line">Instant instant2 = Instant.ofEpochSecond(<span class="number">120</span>, <span class="number">100000</span>); <span class="comment">//指定时间，第一个参数是秒，第二个参数是纳秒（相对1970-01-01 00:00:00）</span></span><br></pre></td></tr></table></figure>
<h3 id="Duration"><a href="#Duration" class="headerlink" title="Duration"></a>Duration</h3><p>表示时间段，精确到纳秒，可用于计算时间差</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime from = LocalDateTime.of(<span class="number">2017</span>, Month.JANUARY, <span class="number">5</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">0</span>);    <span class="comment">// 2017-01-05 10:07:00</span></span><br><span class="line">LocalDateTime to = LocalDateTime.of(<span class="number">2017</span>, Month.FEBRUARY, <span class="number">5</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">0</span>);     <span class="comment">// 2017-02-05 10:07:00</span></span><br><span class="line">Duration duration0 = Duration.between(from, to);     <span class="comment">// 表示从 2017-01-05 10:07:00 到 2017-02-05 10:07:00 这段时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> days = duration.toDays();              <span class="comment">// 这段时间的总天数</span></span><br><span class="line"><span class="keyword">long</span> hours = duration.toHours();            <span class="comment">// 这段时间的小时数</span></span><br><span class="line"><span class="keyword">long</span> minutes = duration.toMinutes();        <span class="comment">// 这段时间的分钟数</span></span><br><span class="line"><span class="keyword">long</span> seconds = duration.getSeconds();       <span class="comment">// 这段时间的秒数</span></span><br><span class="line"><span class="keyword">long</span> milliSeconds = duration.toMillis();    <span class="comment">// 这段时间的毫秒数</span></span><br><span class="line"><span class="keyword">long</span> nanoSeconds = duration.toNanos();      <span class="comment">// 这段时间的纳秒数</span></span><br><span class="line"></span><br><span class="line">Duration duration1 = Duration.of(<span class="number">5</span>, ChronoUnit.DAYS);       <span class="comment">// 5天</span></span><br><span class="line">Duration duration2 = Duration.of(<span class="number">1000</span>, ChronoUnit.MILLIS);  <span class="comment">// 1000毫秒</span></span><br></pre></td></tr></table></figure>
<h3 id="Period"><a href="#Period" class="headerlink" title="Period"></a>Period</h3><p>表示日期段，精确到日</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Period period1 = Period.of(<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>);</span><br><span class="line"><span class="comment">// 2017-01-05 到 2017-02-05 这段时间</span></span><br><span class="line">Period period2 = Period.between(</span><br><span class="line">                LocalDate.of(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">5</span>),</span><br><span class="line">                LocalDate.of(<span class="number">2017</span>, <span class="number">2</span>, <span class="number">5</span>));</span><br></pre></td></tr></table></figure>
<h2 id="时间的操作"><a href="#时间的操作" class="headerlink" title="时间的操作"></a>时间的操作</h2><p>和String一样，时间类都是不可变的<br>内置了大量的操作方法。<br><code>下面用日期类作说明，时间类一样。</code></p>
<p>简单的时间操作：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate date = LocalDate.of(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">5</span>);          <span class="comment">// 2017-01-05</span></span><br><span class="line"></span><br><span class="line">LocalDate date1 = date.withYear(<span class="number">2016</span>);              <span class="comment">// 修改为 2016-01-05</span></span><br><span class="line">LocalDate date2 = date.withMonth(<span class="number">2</span>);                <span class="comment">// 修改为 2017-02-05</span></span><br><span class="line">LocalDate date3 = date.withDayOfMonth(<span class="number">1</span>);           <span class="comment">// 修改为 2017-01-01</span></span><br><span class="line"></span><br><span class="line">LocalDate date4 = date.plusYears(<span class="number">1</span>);                <span class="comment">// 增加一年 2018-01-05</span></span><br><span class="line">LocalDate date5 = date.minusMonths(<span class="number">2</span>);              <span class="comment">// 减少两个月 2016-11-05</span></span><br><span class="line">LocalDate date6 = date.plus(<span class="number">5</span>, ChronoUnit.DAYS);    <span class="comment">// 增加5天 2017-01-10</span></span><br></pre></td></tr></table></figure></p>
<p>使用TemporalAdjuster实现更复杂的时间计算：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate date7 = date.with(nextOrSame(DayOfWeek.SUNDAY));      <span class="comment">// 返回下一个距离当前时间最近的星期日</span></span><br><span class="line">LocalDate date9 = date.with(lastInMonth(DayOfWeek.SATURDAY));   <span class="comment">// 返回本月最后一个星期六</span></span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>dayOfWeekInMonth</td>
<td>返回同一个月中每周的第几天</td>
</tr>
<tr>
<td>firstDayOfMonth</td>
<td>返回当月的第一天</td>
</tr>
<tr>
<td>firstDayOfNextMonth</td>
<td>返回下月的第一天</td>
</tr>
<tr>
<td>firstDayOfNextYear</td>
<td>返回下一年的第一天</td>
</tr>
<tr>
<td>firstDayOfYear</td>
<td>返回本年的第一天</td>
</tr>
<tr>
<td>firstInMonth</td>
<td>返回同一个月中第一个星期几</td>
</tr>
<tr>
<td>lastDayOfMonth</td>
<td>返回当月的最后一天</td>
</tr>
<tr>
<td>lastDayOfNextMonth</td>
<td>返回下月的最后一天</td>
</tr>
<tr>
<td>lastDayOfNextYear</td>
<td>返回下一年的最后一天</td>
</tr>
<tr>
<td>lastDayOfYear</td>
<td>返回本年的最后一天</td>
</tr>
<tr>
<td>lastInMonth</td>
<td>返回同一个月中最后一个星期几</td>
</tr>
<tr>
<td>next / previous</td>
<td>返回后一个/前一个给定的星期几</td>
</tr>
<tr>
<td>nextOrSame / previousOrSame</td>
<td>返回后一个/前一个给定的星期几，如果这个值满足条件，直接返回</td>
</tr>
</tbody>
</table>
<p>TemporalAdjuster还可以定制</p>
<h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p>format()方法用于将日期格式化为字符串，该方法接收一个DateTimeFormatter类型参数：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime dateTime = LocalDateTime.now();</span><br><span class="line">String strDate1 = dateTime.format(DateTimeFormatter.BASIC_ISO_DATE);    <span class="comment">// 20170105</span></span><br><span class="line">String strDate2 = dateTime.format(DateTimeFormatter.ISO_LOCAL_DATE);    <span class="comment">// 2017-01-05</span></span><br><span class="line">String strDate3 = dateTime.format(DateTimeFormatter.ISO_LOCAL_TIME);    <span class="comment">// 14:20:16.998</span></span><br><span class="line">String strDate4 = dateTime.format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>));   <span class="comment">// 2017-01-05</span></span><br><span class="line">String strDate5 = dateTime.format(DateTimeFormatter.ofPattern(<span class="string">"今天是：YYYY年 MMMM DD日 E"</span>, Locale.CHINESE)); <span class="comment">// 今天是：2017年 一月 05日 星期四</span></span><br><span class="line"></span><br><span class="line">String strDate6 = <span class="string">"2017-01-05"</span>;</span><br><span class="line">String strDate7 = <span class="string">"2017-01-05 12:30:05"</span>;</span><br><span class="line">LocalDate date = LocalDate.parse(strDate6, DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>));</span><br><span class="line">LocalDateTime dateTime1 = LocalDateTime.parse(strDate7, DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</span><br></pre></td></tr></table></figure></p>
<h2 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h2><h3 id="ZoneId"><a href="#ZoneId" class="headerlink" title="ZoneId"></a>ZoneId</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ZoneId shanghaiZoneId = ZoneId.of(<span class="string">"Asia/Shanghai"</span>);         <span class="comment">//指定时区ID</span></span><br><span class="line">ZoneId systemZoneId = ZoneId.systemDefault();               <span class="comment">//获取本地时区ID</span></span><br><span class="line">Set&lt;String&gt; zoneIds = ZoneId.getAvailableZoneIds();         <span class="comment">//获取所有合法的“区域/城市”字符串</span></span><br></pre></td></tr></table></figure>
<p>有了ZoneId，我们就可以将一个LocalDate、LocalTime或LocalDateTime对象转化为ZonedDateTime对象：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.now();          <span class="comment">//时间对象</span></span><br><span class="line">ZonedDateTime zonedDateTime = ZonedDateTime.of(localDateTime, shanghaiZoneId);</span><br></pre></td></tr></table></figure></p>
<h3 id="ZoneOffset"><a href="#ZoneOffset" class="headerlink" title="ZoneOffset"></a>ZoneOffset</h3><p>以当前时间和世界标准时间（UTC）/格林威治时间（GMT）的偏差来计算</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ZoneOffset zoneOffset = ZoneOffset.of(<span class="string">"+09:00"</span>);</span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">OffsetDateTime offsetDateTime = OffsetDateTime.of(localDateTime, zoneOffset);</span><br></pre></td></tr></table></figure>
<h2 id="和Date的转换"><a href="#和Date的转换" class="headerlink" title="和Date的转换"></a>和Date的转换</h2><p>Instant作为中介<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 01. java.util.Date --&gt; java.time.LocalDateTime</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UDateToLocalDateTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    java.util.Date date = <span class="keyword">new</span> java.util.Date();</span><br><span class="line">    Instant instant = date.toInstant();</span><br><span class="line">    ZoneId zone = ZoneId.systemDefault();</span><br><span class="line">    LocalDateTime localDateTime = LocalDateTime.ofInstant(instant, zone);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 02. java.util.Date --&gt; java.time.LocalDate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UDateToLocalDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    java.util.Date date = <span class="keyword">new</span> java.util.Date();</span><br><span class="line">    Instant instant = date.toInstant();</span><br><span class="line">    ZoneId zone = ZoneId.systemDefault();</span><br><span class="line">    LocalDateTime localDateTime = LocalDateTime.ofInstant(instant, zone);</span><br><span class="line">    LocalDate localDate = localDateTime.toLocalDate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 03. java.util.Date --&gt; java.time.LocalTime</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UDateToLocalTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    java.util.Date date = <span class="keyword">new</span> java.util.Date();</span><br><span class="line">    Instant instant = date.toInstant();</span><br><span class="line">    ZoneId zone = ZoneId.systemDefault();</span><br><span class="line">    LocalDateTime localDateTime = LocalDateTime.ofInstant(instant, zone);</span><br><span class="line">    LocalTime localTime = localDateTime.toLocalTime();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 04. java.time.LocalDateTime --&gt; java.util.Date</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LocalDateTimeToUdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">    ZoneId zone = ZoneId.systemDefault();</span><br><span class="line">    Instant instant = localDateTime.atZone(zone).toInstant();</span><br><span class="line">    java.util.Date date = Date.from(instant);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 05. java.time.LocalDate --&gt; java.util.Date</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LocalDateToUdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LocalDate localDate = LocalDate.now();</span><br><span class="line">    ZoneId zone = ZoneId.systemDefault();</span><br><span class="line">    Instant instant = localDate.atStartOfDay().atZone(zone).toInstant();</span><br><span class="line">    java.util.Date date = Date.from(instant);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 06. java.time.LocalTime --&gt; java.util.Date</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LocalTimeToUdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LocalTime localTime = LocalTime.now();</span><br><span class="line">    LocalDate localDate = LocalDate.now();</span><br><span class="line">    LocalDateTime localDateTime = LocalDateTime.of(localDate, localTime);</span><br><span class="line">    ZoneId zone = ZoneId.systemDefault();</span><br><span class="line">    Instant instant = localDateTime.atZone(zone).toInstant();</span><br><span class="line">    java.util.Date date = Date.from(instant);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2019/04/27/Java/git/</url>
    <content><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>生成如下的目录：</p>
<ul>
<li>HEAD：指示目前被检出的分支；</li>
<li>config*：项目特有的配置选项。</li>
<li>description：文件仅供 GitWeb 程序使用，我们无需关心。</li>
<li>hooks/：客户端或服务端的钩子脚本（hook scripts）</li>
<li>info/包含一个全局性排除（global exclude）文件，用以放置那些不希望被记录在 .gitignore 文件中的忽略模式（ignored patterns）。</li>
<li>objects/存储所有数据内容；</li>
<li>refs/存储指向数据（分支）的提交对象的指针；</li>
</ul>
<p>接下来一一学习。</p>
<h2 id="Git对象"><a href="#Git对象" class="headerlink" title="Git对象"></a>Git对象</h2><p>Git的本质是一个寻址文件系统，这意思是Git 的核心部分是一个简单的键值对数据库（key-value data store）。<br>数据的内容都会存储到objects中。</p>
<p>现在用 hash-object 命令来展示如何存储数据，这个命令会生成一个SHA-1的哈希值作为Key.<br>–stdin 选项则指示该命令从标准输入读取内容；若不指定此选项，则须在命令尾部给出待存储文件的路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git init test</span><br><span class="line">$ echo &apos;test content&apos; | git hash-object -w --stdin</span><br><span class="line">d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br><span class="line"></span><br><span class="line">$ find .git/objects -type f</span><br><span class="line">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</span><br></pre></td></tr></table></figure>
<p>然后会在objects目录下看到一个新的文件，一个文件对应着一个数据内容。<br>校验和的前两个字符用于命名子目录，余下的 38 个字符则用作文件名。</p>
<p>通过 cat-file 命令取出数据<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br><span class="line">test content</span><br></pre></td></tr></table></figure></p>
<p>这个存储数据的对象就是git对象。</p>
<p>由此可以做一个简单的版本控制方案，存储“版本一”生成一个git对象，存储“版本二”生成一个git对象。需要哪一个版本就取出git对象中的数据去覆盖本地文件的数据。</p>
<ul>
<li>echo ‘test content’ | git hash-object -w –stdin：将前面的内容写成一个git对象</li>
<li>git hash-object -w test.txt:将一个文件写成git对象</li>
<li>git update-index –add –cacheinfo 100644 83baae61804e65cc73a7201a7252750c76066a30 test.txt：将一个git对象放到暂存区，–cacheinfo是指定一个git对象</li>
<li>git write-tree：将暂存区的所有对象写成一个树对象</li>
<li>git read-tree –prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579：将一个树对象存储到暂存区</li>
<li>echo ‘first commit’ | git commit-tree d8329f -p fdf4fc3344e67ab068f836878b6c4951e3b15f3d：创建一个提交对象</li>
<li>echo “1a410efbd13591db07496601ebc7a059dd55cfe9” &gt; .git/refs/heads/master：修改引用指向的提交对象</li>
<li>git log –pretty=oneline master：查看引用指向的提交对象的历史</li>
<li>git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9：更新引用指向的提交对象</li>
</ul>
<p>git add = git hash-object -w (+) git update-index –all –cacheinfo （git对象） =  git update-index –add 文件<br>//git commit = git write-tree (+) git commit-tree 把当前HEAD指向的提交对象作为父对象</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li>cat .git/HEAD：查看HEAD指针指向的ref引用</li>
<li>git commit：会取出HEAD的SHA-1值作为新提交的父提交。</li>
<li>git symbolic-ref HEAD refs/heads/test：修改HEAD中的ref引用</li>
<li>git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d：创建一个轻量标签对象</li>
<li>git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m ‘test tag’：创建一个附注标签对象</li>
<li>git cat-file -p 9585191f37f7b0fb9444f35a9bf50de191beadc2：查看标签对象内容</li>
<li>git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:schacon/simplegit-progit.git：添加一个远程分支时会新建一个远程引用</li>
<li>cat .git/refs/remotes/origin/master：查看远程引用</li>
</ul>
<h2 id="包文件"><a href="#包文件" class="headerlink" title="包文件"></a>包文件</h2><ul>
<li>git gc：打包，生成包文件和一个索引， 包文件包含了刚才从文件系统中移除的所有对象的内容。索引文件包含了包文件的偏移信息。</li>
<li>git verify-pack -v .git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.idx：查看已打包的内容</li>
</ul>
<blockquote>
<p>Git 最初向磁盘中存储对象时所使用的格式被称为“松散（loose）”对象格式。 但是，Git 会时不时地将多个这些对象打包成一个称为“包文件（packfile）”的二进制文件，以节省空间和提高效率。</p>
</blockquote>
<h2 id="引用规格"><a href="#引用规格" class="headerlink" title="引用规格"></a>引用规格</h2><ul>
<li><p>引用规格：+<src>:<dst>  其中 <src> 是一个模式（pattern），代表远程版本库中的引用；<dst> 是那些远程引用在本地所对应的位置。 + 号告诉 Git 即使在不能快进的情况下也要（强制）更新引用。</dst></src></dst></src></p>
</li>
<li><p>git remote add origin https:// github.com/schacon/simplegit-progit：添加远程分支到本地引用的简单映射方式</p>
</li>
</ul>
<p>上述命令会在你的 .git/config 文件中添加一个小节，并在其中指定远程版本库的名称（origin）、URL 和一个用于获取操作的引用规格（refspec）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">	url = https://github.com/schacon/simplegit-progit</span><br><span class="line">	fetch = +refs/heads/*:refs/remotes/origin/*</span><br></pre></td></tr></table></figure></p>
<p>如果想让 Git 每次只拉取远程的 master 分支，而不是所有分支，可以把（引用规格的）获取那一行修改为：fetch = +refs/heads/master:refs/remotes/origin/master。</p>
<p>如果有某些只希望被执行一次的操作，我们也可以在命令行指定引用规格。 若要将远程的 master 分支拉到本地的 origin/mymaster 分支，可以运行：<br>git fetch origin master:refs/remotes/origin/mymaster</p>
<ul>
<li>git log origin/master || git log remotes/origin/master || git log refs/remotes/origin/master：查看远程分支的提交记录</li>
</ul>
<p>我们不能在模式中使用部分通配符，所以像下面这样的引用规格是不合法的：fetch = +refs/heads/qa<em>:refs/remotes/origin/qa</em>。但我们可以使用命名空间（或目录）来达到类似目的，可以使用如下配置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">	url = https://github.com/schacon/simplegit-progit</span><br><span class="line">	fetch = +refs/heads/master:refs/remotes/origin/master</span><br><span class="line">	fetch = +refs/heads/qa/*:refs/remotes/origin/qa/*</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>git push origin master:refs/heads/qa/master：把本地 master 分支推送到远程服务器的 qa/master 分支上，同样修改config配置可以实现默认git push origin的实现。</p>
</li>
<li><p>git push origin :topic || git push origin –delete topic(自Git v1.7.0以后可用)：删除远程分支</p>
</li>
</ul>
<h2 id="数据维护"><a href="#数据维护" class="headerlink" title="数据维护"></a>数据维护</h2><p>Git 会不定时地自动运行一个叫做 “auto gc” 的命令。 大多数时候，这个命令并不会产生效果。 然而，如果有太多松散对象（不在包文件中的对象）或者太多包文件，Git 会运行一个完整的 git gc 命令。 这个命令会做以下事情：收集所有松散对象并将它们放置到包文件中，将多个包文件合并为一个大的包文件，移除与任何提交都不相关的陈旧对象。</p>
<ul>
<li>git gc –auto：手动执行自动垃圾回收。大约需要7000个以上的松散对象或超过50个的包文件才能让Git启动一次真正的gc命令。</li>
</ul>
<p>gc 将会做的另一件事是打包你的引用到一个单独的文件。 假设你的仓库包含以下分支与标签：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find .git/refs -type f</span><br><span class="line">.git/refs/heads/experiment</span><br><span class="line">.git/refs/heads/master</span><br><span class="line">.git/refs/tags/v1.0</span><br><span class="line">.git/refs/tags/v1.1</span><br></pre></td></tr></table></figure></p>
<p>如果你执行了 git gc 命令，refs 目录中将不会再有这些文件。 为了保证效率 Git 会将它们移动到名为 .git/packed-refs 的文件中，如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat .git/packed-refs</span><br><span class="line"># pack-refs with: peeled fully-peeled</span><br><span class="line">cac0cab538b970a37ea1e769cbbde608743bc96d refs/heads/experiment</span><br><span class="line">ab1afef80fac8e34258ff41fc1b867c702daa24b refs/heads/master</span><br><span class="line">cac0cab538b970a37ea1e769cbbde608743bc96d refs/tags/v1.0</span><br><span class="line">9585191f37f7b0fb9444f35a9bf50de191beadc2 refs/tags/v1.1</span><br><span class="line">^1a410efbd13591db07496601ebc7a059dd55cfe9</span><br></pre></td></tr></table></figure></p>
<p>如果你更新了引用，Git 并不会修改这个文件，而是向 refs/heads 创建一个新的文件。 为了获得指定引用的正确 SHA-1 值，Git 会首先在 refs 目录中查找指定的引用，然后再到 packed-refs 文件中查找。</p>
<blockquote>
<p>注意这个文件的最后一行，它会以 ^ 开头。 这个符号表示它上一行的标签是附注标签，^ 所在的那一行是附注标签指向的那个提交。</p>
</blockquote>
<h2 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h2><p>在你使用 Git 的时候，你可能会意外丢失一次提交。 通常这是因为你强制删除了正在工作的分支，但是最后却发现你还需要这个分支；亦或者硬重置了一个分支，放弃了你想要的提交。 如果这些事情已经发生，该如何找回你的提交呢？</p>
<ul>
<li><p>git reflog：当你正在工作时，Git 会默默地记录每一次你改变 HEAD 时它的值。 每一次你提交或改变分支，引用日志都会被更新。 引用日志（reflog）也可以通过 git update-ref 命令更新：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">1a410ef HEAD@&#123;0&#125;: reset: moving to 1a410ef</span><br><span class="line">ab1afef HEAD@&#123;1&#125;: commit: modified repo.rb a bit</span><br><span class="line">484a592 HEAD@&#123;2&#125;: commit: added repo.rb</span><br></pre></td></tr></table></figure>
</li>
<li><p>git log -g；以标准日志的格式输出引用日志</p>
</li>
</ul>
<blockquote>
<p>引用日志数据存放在 .git/logs/ 目录中。</p>
</blockquote>
<p><strong>如何恢复呢？</strong></p>
<p>可以通过创建一个新的分支指向这个提交来恢复它，如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch recover-branch ab1afef</span><br><span class="line">$ git log --pretty=oneline recover-branch</span><br><span class="line">ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit</span><br><span class="line">484a59275031909e19aadb7c92262719cfcdf19a added repo.rb</span><br><span class="line">1a410efbd13591db07496601ebc7a059dd55cfe9 third commit</span><br><span class="line">cac0cab538b970a37ea1e769cbbde608743bc96d second commit</span><br><span class="line">fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</span><br></pre></td></tr></table></figure></p>
<p><strong>如果出于某种原因，丢失的提交不在引用日志中，如何处理？</strong></p>
<ul>
<li>git fsck：检查数据库的完整性。 如果使用一个 –full 选项运行它，它会向你显示出所有没有被其他对象指向的对象：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git fsck --full</span><br><span class="line">Checking object directories: 100% (256/256), done.</span><br><span class="line">Checking objects: 100% (18/18), done.</span><br><span class="line">dangling blob d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br><span class="line">dangling commit ab1afef80fac8e34258ff41fc1b867c702daa24b</span><br><span class="line">dangling tree aea790b9a58f6cf6f2804eeac9f0abbe9631e4c9</span><br><span class="line">dangling blob 7108f7ecb345ee9d0084193f147cdad4d2998293</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h2><h3 id="1-配置"><a href="#1-配置" class="headerlink" title="1.配置"></a>1.配置</h3><p>git config –global user.name “xxx”<br>git config –global user.emil “xxx”</p>
<h3 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2.初始化"></a>2.初始化</h3><p>git init</p>
<h3 id="3-克隆"><a href="#3-克隆" class="headerlink" title="3.克隆"></a>3.克隆</h3><p>git clone xxx(ssh,http)</p>
<h3 id="4-修改"><a href="#4-修改" class="headerlink" title="4.修改"></a>4.修改</h3><p>放入暂存区：git add<br>存入本地仓库：git commit -m “xxx”<br>放入暂存区+存入本地仓库：git commit -am “xxx”</p>
<h3 id="5-撤销修改"><a href="#5-撤销修改" class="headerlink" title="5.撤销修改"></a>5.撤销修改</h3><p>撤销暂存区修改：git reset HEAD xxx.xx<br>撤销工作区的修改：git checkout xxx.xx</p>
<h3 id="6-查看"><a href="#6-查看" class="headerlink" title="6.查看"></a>6.查看</h3><p>当前状态：git status<br>比较工作区和暂存区：git diff<br>查改历史版本：git log<br>查看修改过的版本：git reflog</p>
<h3 id="7-版本控制"><a href="#7-版本控制" class="headerlink" title="7.版本控制"></a>7.版本控制</h3><p>删除工作空间改动代码， 撤销commit， 撤销add：  git reset –hard 版本号<br>不删除工作空间改动代码，撤销commit，不撤销add：git reset –soft 版本号<br>不删除工作空间改动代码，撤销commit，且撤销add：git reset –mixed 版本号<br>commit注释写错了，只是想改一下注释：git commit –amend</p>
<h3 id="8-暂存处理"><a href="#8-暂存处理" class="headerlink" title="8.暂存处理"></a>8.暂存处理</h3><p>把当前工作区暂存起来做其他处理：git stash<br>读取最近一次保存的内容：git stash pop<br>-&gt; 取出来的内存会和当前工作区内容合并</p>
<h3 id="9-分支"><a href="#9-分支" class="headerlink" title="9.分支"></a>9.分支</h3><p>创建分支：git branch xxx<br>切换分支：git checkout xxx<br>创建+切换：git checkout -b xxx<br>查看分支：git branch<br>分支合并：git merge xxx(把xxx合并到现在所在分支)<br>分支删除：git branch -d xxx</p>
<h3 id="10-远程分支"><a href="#10-远程分支" class="headerlink" title="10.远程分支"></a>10.远程分支</h3><p>取回远程分支的更新：git fetch origin（主机名） master（分支名）<br>合并远程分支：git merge origin/master<br>取回+合并：git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;<br>新建远程分支：git push xxx:xxx<br>删除远程分支：git push :xxx<br>关联远程仓库：git remote add origin git@server-name:path/repo-name.git；<br>把当前分支推送到远程：git push -u origin master<br>-&gt; 加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<h3 id="11-rebase"><a href="#11-rebase" class="headerlink" title="11.rebase"></a>11.rebase</h3><p>git rebase -i cid</p>
<p>reword：修改提交信息；<br>edit：修改此提交；<br>squash：将提交融合到前一个提交中；<br>fixup：将提交融合到前一个提交中，不保留该提交的日志消息；<br>exec：在每个提交上运行我们想要 rebase 的命令；<br>drop：移除该提交。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>linux常用命令</title>
    <url>/2019/04/15/Java/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="linux常用命令"><a href="#linux常用命令" class="headerlink" title="linux常用命令"></a>linux常用命令</h1><h2 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h2><p>切换目录</p>
<p>cd /root/Docements # 切换到目录/root/Docements<br>cd ./path          # 切换到当前目录下的path目录中，“.”表示当前目录<br>cd ../path         # 切换到上层目录中的path目录中，“..”表示上一层目录</p>
<h2 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h2><p>查看文件与目录</p>
<p>-l ：列出长数据串，包含文件的属性与权限数据等<br>-a ：列出全部的文件，连同隐藏文件（开头为.的文件）一起列出来（常用）<br>-d ：仅列出目录本身，而不是列出目录的文件数据<br>-h ：将文件容量以较易读的方式（GB，kB等）列出来<br>-R ：连同子目录的内容一起列出（递归列出），等于该目录下的所有文件都会显示出来</p>
<h2 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h2><p>该命令常用于分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工等等，它的简单语法为<br>grep [-acinv] [–color=auto] ‘查找字符串’ filename</p>
<p>它的常用参数如下：<br>-a ：将binary文件以text文件的方式查找数据<br>-c ：计算找到‘查找字符串’的次数<br>-i ：忽略大小写的区别，即把大小写视为相同<br>-v ：反向选择，即显示出没有‘查找字符串’内容的那一行</p>
<p>例如：<br>grep –color=auto ‘MANPATH’ /etc/man.config  # 取出文件/etc/man.config中包含MANPATH的行，并把找到的关键字加上颜色<br>ls -l | grep -i file                         # 把ls -l的输出中包含字母file（不区分大小写）的内容输出</p>
<h2 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h2><p>查找的功能非常强大的命令，相对而言，它的使用也相对较为复杂，参数也比较多，所以在这里将给把它们分类列出，它的基本语法如下：<br>find [PATH] [option] [action]</p>
<p>与时间有关的参数：<br>-mtime n : n为数字，意思为在n天之前的“一天内”被更改过的文件；<br>-mtime +n : 列出在n天之前（不含n天本身）被更改过的文件名；<br>-mtime -n : 列出在n天之内（含n天本身）被更改过的文件名；<br>-newer file : 列出比file还要新的文件名<br>例如：<br>find /root -mtime 0 # 在当前目录下查找今天之内有改动的文件</p>
<p>与用户或用户组名有关的参数：<br>-user name : 列出文件所有者为name的文件<br>-group name : 列出文件所属用户组为name的文件<br>-uid n : 列出文件所有者为用户ID为n的文件<br>-gid n : 列出文件所属用户组为用户组ID为n的文件<br>例如：<br>find /home/ljianhui -user ljianhui # 在目录/home/ljianhui中找出所有者为ljianhui的文件</p>
<p>与文件权限及名称有关的参数：<br>-name filename ：找出文件名为filename的文件<br>-size [+-]SIZE ：找出比SIZE还要大（+）或小（-）的文件<br>-tpye TYPE ：查找文件的类型为TYPE的文件，TYPE的值主要有：一般文件（f)、设备文件（b、c）、目录（d）、连接文件（l）、socket（s）、FIFO管道文件（p）；<br>-perm mode ：查找文件权限刚好等于mode的文件，mode用数字表示，如0755；<br>-perm -mode ：查找文件权限必须要全部包括mode权限的文件，mode用数字表示<br>-perm +mode ：查找文件权限包含任一mode的权限的文件，mode用数字表示<br>例如：<br>find / -name passwd # 查找文件名为passwd的文件<br>find . -perm 0755 # 查找当前目录中文件权限的0755的文件<br>find . -size +12k # 查找当前目录中大于12KB的文件，注意c表示byte</p>
<h2 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h2><p>该命令用于复制文件，copy之意，它还可以把多个文件一次性地复制到一个目录下，它的常用参数如下：<br>-a ：将文件的特性一起复制<br>-p ：连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份<br>-i ：若目标文件已经存在时，在覆盖时会先询问操作的进行<br>-r ：递归持续复制，用于目录的复制行为<br>-u ：目标文件与源文件有差异时才会复制<br>例如 ：<br>cp -a file1 file2        # 连同文件的所有特性把文件file1复制成文件file2<br>cp file1 file2 file3 dir # 把文件file1、file2、file3复制到目录dir中</p>
<h2 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h2><p>该命令用于移动文件、目录或更名，move之意，它的常用参数如下：<br>-f ：force强制的意思，如果目标文件已经存在，不会询问而直接覆盖<br>-i ：若目标文件已经存在，就会询问是否覆盖<br>-u ：若目标文件已经存在，且比目标文件新，才会更新<br>注：该命令可以把一个文件或多个文件一次移动一个文件夹中，但是最后一个目标文件一定要是“目录”。</p>
<p>例如：<br>mv file1 file2 file3 dir # 把文件file1、file2、file3移动到目录dir中<br>mv file1 file2           # 把文件file1重命名为file2</p>
<h2 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h2><p>该命令用于删除文件或目录，remove之间，它的常用参数如下：<br>-f ：就是force的意思，忽略不存在的文件，不会出现警告消息<br>-i ：互动模式，在删除前会询问用户是否操作<br>-r ：递归删除，最常用于目录删除，它是一个非常危险的参数<br>例如：<br>rm -i file # 删除文件file，在删除之前会询问是否进行该操作<br>rm -fr dir # 强制删除目录dir中的所有文件</p>
<h2 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h2><p>该命令用于将某个时间点的进程运行情况选取下来并输出，process之意，它的常用参数如下：<br>-A ：所有的进程均显示出来<br>-a ：不与terminal有关的所有进程<br>-u ：有效用户的相关进程<br>-x ：一般与a参数一起使用，可列出较完整的信息<br>-l ：较长，较详细地将PID的信息列出<br>其实我们只要记住ps一般使用的命令参数搭配即可，它们并不多，如下：<br>ps aux # 查看系统所有的进程数据<br>ps ax # 查看不与terminal有关的所有进程<br>ps -lA # 查看系统所有的进程数据<br>ps axjf # 查看连同一部分进程树状态</p>
<h2 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h2><p>该命令用于向某个工作（%jobnumber）或者是某个PID（数字）传送一个信号，它通常与ps和jobs命令一起使用，它的基本语法如下：<br>kill -signal PID<br>signal的常用参数如下：<br>注：最前面的数字为信号的代号，使用时可以用代号代替相应的信号。<br>1：SIGHUP，启动被终止的进程<br>2：SIGINT，相当于输入ctrl+c，中断一个程序的进行<br>9：SIGKILL，强制中断一个进程的进行<br>15：SIGTERM，以正常的结束进程方式来终止进程<br>17：SIGSTOP，相当于输入ctrl+z，暂停一个进程的进行<br>例如：<br>kill -SIGTERM %1  # 以正常的结束进程方式来终于第一个后台工作，可用jobs命令查看后台中的第一个工作进程<br>kill -SIGHUP PID  # 重新改动进程ID为PID的进程，PID可用ps命令通过管道命令加上grep命令进行筛选获得</p>
<h2 id="killall命令"><a href="#killall命令" class="headerlink" title="killall命令"></a>killall命令</h2><p>该命令用于向一个命令启动的进程发送一个信号，它的一般语法如下：<br>killall [-iIe] [command name]<br>它的参数如下：<br>-i ：交互式的意思，若需要删除时，会询问用户<br>-e ：表示后面接的command name要一致，但command name不能超过15个字符<br>-I ：命令名称忽略大小写<br>例如：<br>killall -SIGHUP syslogd # 重新启动syslogd</p>
<h2 id="file命令"><a href="#file命令" class="headerlink" title="file命令"></a>file命令</h2><p>该命令用于判断接在file命令后的文件的基本数据，因为在Linux下文件的类型并不是以后缀为分的，所以这个命令对我们来说就很有用了，它的用法非常简单，基本语法如下：<br>file filename<br>例如：<br>file ./test</p>
<h2 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h2><p>该命令用于对文件进行打包，默认情况并不会压缩，如果指定了相应的参数，它还会调用相应的压缩程序（如gzip和bzip等）进行压缩和解压。它的常用参数如下：<br>-c ：新建打包文件<br>-t ：查看打包文件的内容含有哪些文件名<br>-x ：解打包或解压缩的功能，可以搭配-C（大写）指定解压的目录，注意-c,-t,-x不能同时出现在同一条命令中<br>-j ：通过bzip2的支持进行压缩/解压缩<br>-z ：通过gzip的支持进行压缩/解压缩<br>-v ：在压缩/解压缩过程中，将正在处理的文件名显示出来<br>-f filename ：filename为要处理的文件<br>-C dir ：指定压缩/解压缩的目录dir<br>上面的解说可以已经让你晕过去了，但是通常我们只需要记住下面三条命令即可：<br>压缩：tar -jcv -f filename.tar.bz2 要被处理的文件或目录名称<br>查询：tar -jtv -f filename.tar.bz2<br>解压：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录<br>注：文件名并不定要以后缀tar.bz2结尾，这里主要是为了说明使用的压缩程序为bzip2</p>
<h2 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h2><p>该命令用于查看文本文件的内容，后接要查看的文件名，通常可用管道与more和less一起使用，从而可以一页页地查看数据。例如：<br>cat text | less # 查看text文件中的内容<br>注：这条命令也可以使用less text来代替</p>
<h2 id="chgrp命令"><a href="#chgrp命令" class="headerlink" title="chgrp命令"></a>chgrp命令</h2><p>该命令用于改变文件所属用户组，它的使用非常简单，它的基本用法如下：<br>chgrp [-R] dirname/filename<br>-R ：进行递归的持续对所有文件和子目录更改<br>例如：<br>chgrp users -R ./dir # 递归地把dir目录下中的所有文件和子目录下所有文件的用户组修改为users</p>
<h2 id="chown命令"><a href="#chown命令" class="headerlink" title="chown命令"></a>chown命令</h2><p>该命令用于改变文件的所有者，与chgrp命令的使用方法相同，只是修改的文件属性不同，不再详述。</p>
<h2 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h2><p>该命令用于改变文件的权限，一般的用法如下：<br>chmod [-R] xyz 文件或目录<br>-R：进行递归的持续更改，即连同子目录下的所有文件都会更改<br>同时，chmod还可以使用u（user）、g（group）、o（other）、a（all）和+（加入）、-（删除）、=（设置）跟rwx搭配来对文件的权限进行更改。</p>
<p>例如：<br>chmod 0755 file # 把file的文件权限改变为-rxwr-xr-x<br>chmod g+w file # 向file的文件权限中加入用户组可写权限<br>18、vim命令<br>该命令主要用于文本编辑，它接一个或多个文件名作为参数，如果文件存在就打开，如果文件不存在就以该文件名创建一个文件。vim是一个非常好用的文本编辑器，它里面有很多非常好用的命令，在这里不再多说。你可以从这里下载vim常用操作的详细说明。</p>
<h2 id="gcc命令"><a href="#gcc命令" class="headerlink" title="gcc命令"></a>gcc命令</h2><p>对于一个用Linux开发C程序的人来说，这个命令就非常重要了，它用于把C语言的源程序文件，编译成可执行程序，由于g++的很多参数跟它非常相似，所以这里只介绍gcc的参数，它的常用参数如下：<br>-o ：output之意，用于指定生成一个可执行文件的文件名<br>-c ：用于把源文件生成目标文件（.o)，并阻止编译器创建一个完整的程序<br>-I ：增加编译时搜索头文件的路径<br>-L ：增加编译时搜索静态连接库的路径<br>-S ：把源文件生成汇编代码文件<br>-lm：表示标准库的目录中名为libm.a的函数库<br>-lpthread ：连接NPTL实现的线程库<br>-std= ：用于指定把使用的C语言的版本</p>
<p>例如：<br>gcc -o test test.c -lm -std=c99 # 把源文件test.c按照c99标准编译成可执行程序test</p>
<p>gcc -S test.c                   # 把源文件test.c转换为相应的汇编程序源文件test.s</p>
<h2 id="time命令"><a href="#time命令" class="headerlink" title="time命令"></a>time命令</h2><p>该命令用于测算一个命令（即程序）的执行时间。它的使用非常简单，就像平时输入命令一样，不过在命令的前面加入一个time即可，例如：<br>time ./process<br>time ps aux<br>在程序或命令运行结束后，在最后输出了三个时间，它们分别是：<br>user：用户CPU时间，命令执行完成花费的用户CPU时间，即命令在用户态中执行时间总和；<br>system：系统CPU时间，命令执行完成花费的系统CPU时间，即命令在核心态中执行时间总和；<br>real：实际时间，从command命令行开始执行到运行终止的消逝时间；</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>初识消息队列</title>
    <url>/2018/10/28/Java/%E5%86%8D%E8%AF%86%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="常见的架构特性"><a href="#常见的架构特性" class="headerlink" title="常见的架构特性"></a>常见的架构特性</h1><h2 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h2><p>假设系统一直能够提供服务，我们说系统的可用性是100%。<br>如果系统每运行100个时间单位，会有1个时间单位无法提供服务，我们说系统的可用性是99%。<br>方法论上，高可用保证的原则是“集群化”</p>
<h2 id="事务和一致性"><a href="#事务和一致性" class="headerlink" title="事务和一致性"></a>事务和一致性</h2><p>强一致性：两个系统的结果任何时间都保持一致，都成功，或者都失败。<br>解决方案：分布式事务<br>最终一致性：两个消息系统的结果进过一段时间后最终一致，都成功，或者都失败。<br>解决方案：本地事务处理业务落地和消息落地。<br>消息落地失败整个事务回滚。<br>消息落地之后就可以做相应的补偿。</p>
<p>后者的优劣：<br>优：成本降低，复杂度降低。<br>劣：1.必须要建立一个存放消息的空间。2.对于消息延迟高敏感的业务不适用。</p>
<p>“补偿”如果采用自动重复调用的方式，就会产生非幂等性的操作。<br>如果最后消息依旧存在，可以手动补偿。</p>
<h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><p>对同一个系统，使用同样的条件，一次请求和重复的多次请求对系统资源的影响是一致的。<br>幂等性的提出是为了解决由网络原因带来的不一致的问题。<br>并且解决重复提交带来的问题<br>解决方案有：多版本并发控制，TOKEN机制，利用去重表，<strong>select+update</strong></p>
<p>多服务使用一个数据库的操作是幂等的吗？</p>
<h1 id="消息队列介绍"><a href="#消息队列介绍" class="headerlink" title="消息队列介绍"></a>消息队列介绍</h1><p><img src="https://img.ctolib.com/uploadImg/20180106/20180106104443_540.png" alt="消息队列工作流程"></p>
<h2 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h2><table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>appid</td>
<td>string</td>
<td>应用的ID，SKMQ会根据应用ID将消息投递给不同的消费者</td>
</tr>
<tr>
<td>msgid</td>
<td>string</td>
<td>消息ID，必须保证ID的唯一性，SKMQ会过滤重复的消息</td>
</tr>
<tr>
<td>type</td>
<td>string</td>
<td>消息类型，生产者发送消息、消息队列投递消息、消费者反馈都会附带相应的消息类型</td>
</tr>
<tr>
<td>content</td>
<td>byte</td>
<td>消息内容，SKMQ会将它转发给相应的消费者</td>
</tr>
</tbody>
</table>
<ul>
<li>topic 生产者要发送的消息类型 - 应用内广播</li>
<li>queue 生产中要发送的消息类型 - 点对点单播</li>
<li>push MQ推送消息时的默认类型</li>
<li>resp MQ所有的返回信息类型均为 resp ，此时的返回内容为json text，状态包含在返回内容中</li>
<li>register 注册收件人（消费者），此时消息的content应该为合法的json text，否则无法完成注册。</li>
</ul>
<pre><code>{
  &quot;Status&quot;: &quot;arrived | ack | reject | error&quot;,
  &quot;Content&quot;: &quot;response msg&quot;
}
</code></pre><ul>
<li>arrived MQ投递消息时，消费者在接收到消息时需先发送arrived类型的消息，在确保消息落地时才发送ack消息</li>
<li>ack 对消息队列的正常响应信号</li>
<li>reject 当消费者无法消费时，发送一个reject消息给消息队列，消息队列收到reject时，会将消息投入到待重传队列重新排队</li>
<li>error 消息处理失败的标志，消息同样会进入待重传队列</li>
</ul>
<h2 id="ack"><a href="#ack" class="headerlink" title="ack"></a>ack</h2><p>消息到达消费者节点时，消费者先发送一个 arrived 类型的消息告知MQ信件已经到达，MQ会等待一段时间，<br>在这段时间内，如果消费者很快完成任务处理，可以立即发送ack响应告知MQ消息已经处理完成；若未完成，<br>MQ会关闭连接，消费者可以随后主动发送ack消息告知MQ消息已处理完成</p>
<h2 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h2><p>为了消息投递的稳定性，MQ会定期监测消费者节点，通过心跳包检查节点是否失联并及时将其标记，不参与下次消息接收</p>
<h1 id="设计一个消息队列"><a href="#设计一个消息队列" class="headerlink" title="设计一个消息队列"></a>设计一个消息队列</h1><h2 id="高可用性-1"><a href="#高可用性-1" class="headerlink" title="高可用性"></a>高可用性</h2><p>集群环境下使用同一个存储是幂等的，如果不使用同一个，就要做好主从复制。</p>
<h2 id="服务端承载消息堆积的能力"><a href="#服务端承载消息堆积的能力" class="headerlink" title="服务端承载消息堆积的能力"></a>服务端承载消息堆积的能力</h2><p>存储无非是持久化和非持久化两种。</p>
<h2 id="存储子系统的选择"><a href="#存储子系统的选择" class="headerlink" title="存储子系统的选择"></a>存储子系统的选择</h2><p>持久化的前提下：<br>速度：文件系统&gt;分布式KV（持久化）&gt;分布式文件系统&gt;数据库。可靠性相反。</p>
<h2 id="消息队列的作用-设计思路"><a href="#消息队列的作用-设计思路" class="headerlink" title="消息队列的作用+设计思路"></a>消息队列的作用+设计思路</h2><ol>
<li>解耦：立刻返回请求结果，请求过程放到队列中异步处理。</li>
<li>最终一致性：将调用过程放到消息队列中，调用成功就删除消息，最终一致性不是消息队列的必备特性，使用消息队列实现消息的落地不能保证100%不丢失消息（譬如停电）。</li>
<li>广播：谁关心谁订阅</li>
<li>错峰与流控</li>
</ol>
<p>对于消息的后续自动“补偿”处理，消息服务端（broker）“确认”消息（ack）正确后，才会删除本地。<br>消息队列应该把消息确认和消息处理分开，通过ack可以返回消息确认的结果。<br>默认Auto Ack不能确定消息处理有没有失败。<br>消息处理失败时可以主动的ack error<br>如果失败（包括超时）或者误以为失败，则定时重发。<br>误以为失败的情况下，会出现消息重复的问题。</p>
<p>重复消息不可能100%避免，除非允许丢失。<br>不丢消息和消息不重复，两者不可兼得。<br>一般情况下，消息可以通过持久化的id来鉴别重复，但是消息不能永远存在，但是最终这些id总会消失，这时产生了异常情况。<br>现在对于重复消息有两个问题：</p>
<ol>
<li>如何鉴别重复消息，并且处理重复消息？</li>
<li>一个消息队列如何减少重复消息。</li>
</ol>
<h2 id="版本号方式解决问题1"><a href="#版本号方式解决问题1" class="headerlink" title="版本号方式解决问题1"></a>版本号方式解决问题1</h2><p>每个消息带有一个版本号<br>下游（服务器或者消费者）维护一个版本号’，只处理版本号&gt;版本号’的消息。<br>这样做会出现的问题：如果版本号2的消息先到，版本号1的厚道，就gg了。<br>解决方案，只处理版本号=版本号’+1的消息，对于其他的消息，下游要保存起来。<br>优：解决了重复问题<br>劣：1.发送方的消息必须要带有版本号。2.对于顺序严格的，下游要保存消息的版本号。</p>
<h2 id="状态机解决问题1"><a href="#状态机解决问题1" class="headerlink" title="状态机解决问题1"></a>状态机解决问题1</h2><p>定义消息状态的流转关系</p>
<h2 id="减少重复消息的方案"><a href="#减少重复消息的方案" class="headerlink" title="减少重复消息的方案"></a>减少重复消息的方案</h2><ol>
<li>broker不处理重复的id消息</li>
<li>心跳定期监测消费者节点</li>
</ol>
<p>上面解决消息重复的一些方案对于消息队列而言并没有严格定义，由各种消息队列去各自实现。</p>
<h2 id="消息队列对于非事务性业务的支持"><a href="#消息队列对于非事务性业务的支持" class="headerlink" title="消息队列对于非事务性业务的支持"></a>消息队列对于非事务性业务的支持</h2><p>并不是每个业务都要求事务。下单和发送短信就不需要，不能因为发送短信失败就导致下单回滚。一个完整的消息队列应该定义清楚自己可以投递的消息类型，如事务型消息，本地非持久型消息，以及服务端不落地的非可靠消息等。</p>
<h1 id="消息队列的同步和异步"><a href="#消息队列的同步和异步" class="headerlink" title="消息队列的同步和异步"></a>消息队列的同步和异步</h1><p>对于服务端是同步还是异步，主要看返回的是result还是Future。</p>
<h2 id="客户端同步服务端异步"><a href="#客户端同步服务端异步" class="headerlink" title="客户端同步服务端异步"></a>客户端同步服务端异步</h2><pre><code>Future&lt;Result&gt; future = request(server);
//server立刻返回future
ynchronized(future)
{    while(!future.isDone())
        { future.wait();
          //server处理结束后会notify这个future，并修改isdone标志
        }
}
...
return future.get();
</code></pre><h2 id="客户端同步服务端同步"><a href="#客户端同步服务端同步" class="headerlink" title="客户端同步服务端同步"></a>客户端同步服务端同步</h2><pre><code>Result result = request(server);
</code></pre><h2 id="客户端异步服务端同步"><a href="#客户端异步服务端同步" class="headerlink" title="客户端异步服务端同步"></a>客户端异步服务端同步</h2><pre><code>Future&lt;Result&gt; future = executor.submit(new Callable(){
                              public void call&lt;Result&gt;()
                                {
                                  result = request(server);
                                }
                              })
return future;
</code></pre><h2 id="客户端异步服务端异步。"><a href="#客户端异步服务端异步。" class="headerlink" title="客户端异步服务端异步。"></a>客户端异步服务端异步。</h2><pre><code>Future&lt;Result&gt; future = request(server);
//server立刻返回futurereturn future
</code></pre><p>消息队列服务端66666·异步的好处是可以先返回一个Future<br>把消息堆积起来最后batch处理，提高效率，解放了同步处理需要创建的很多个线程。</p>
<p>最后一个客户端异步并没有创建线程，不影响后续主流程，但是因为获取数据时需要正确的结果，而在future.get()就会等待正确结果的生成。<br>这和我们创建一个线程，并在线程中加同步是一致的。<br><strong><a href="https://www.jianshu.com/p/fee513982f8e" target="_blank" rel="noopener">https://www.jianshu.com/p/fee513982f8e</a></strong><br><strong><a href="https://blog.csdn.net/laoyang360/article/details/52244917" target="_blank" rel="noopener">https://blog.csdn.net/laoyang360/article/details/52244917</a></strong></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>存储程序</title>
    <url>/2018/09/29/MySQL/%E5%AD%98%E5%82%A8%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="存储程序"><a href="#存储程序" class="headerlink" title="存储程序"></a>存储程序</h1><p>结构：</p>
<p><img src="/2018/09/29/MySQL/存储程序/1.png" alt="存储程序结构"></p>
<h2 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h2><p><strong>MySQL中有变量吗？</strong></p>
<p>MySQL中的变量关键词是<strong>@</strong></p>
<ul>
<li>常量赋值：SET @a = 1 or SET @a=”abc”</li>
<li>变量赋值：SET @a = @b</li>
<li>sql语句赋值：SET @a = (SELECT..) (要求sql语句的返回结果只有一个)</li>
<li>sql语句赋值除了使用SET 和 “=”，还可以使用INTO,如(SELECT..) INTO @a,使用INTO可以一次赋多个值。</li>
<li>查询变量：SELECT @a</li>
</ul>
<h2 id="修改语句执行终结符"><a href="#修改语句执行终结符" class="headerlink" title="修改语句执行终结符"></a>修改语句执行终结符</h2><p><strong>什么是语句执行终结符？</strong></p>
<p>在MySQL的命令行窗体里，命令如果遇到了”;”就会执行，并且转到下一行重新输入。<br>为了同时输入多行语句，需要修改语句终结符。</p>
<p><strong>如何修改？</strong></p>
<p>默认执行的终结符是”;”<br>使用delimiter来修改</p>
<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delimiter EOF</span><br><span class="line">mysql&gt; SELECT * FROM t1 LIMIT 1;</span><br><span class="line">    -&gt; SELECT * FROM t2 LIMIT 1;</span><br><span class="line">    -&gt; SELECT * FROM t3 LIMIT 1;</span><br><span class="line">    -&gt; EOF</span><br></pre></td></tr></table></figure>
<h2 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h2><p><strong>什么是存储函数</strong><br>将sql语句写在一个函数中执行</p>
<p><strong>如何创建一个存储函数</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE FUNCTION 存储函数名称([参数列表])</span><br><span class="line">RETURNS 返回值类型</span><br><span class="line">BEGIN</span><br><span class="line">    函数体内容</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<p>需要指定函数名称、参数列表、返回值类型以及函数体内容</p>
<p><strong>在哪些地方可以调用存储函数？</strong></p>
<p>函数调用可以作为</p>
<ol>
<li>查询对象</li>
<li>搜索条件</li>
<li>和别的操作数一起组成更复杂的表达式</li>
</ol>
<p><strong>如何查看或删除MySQL中已存在的存储函数？</strong></p>
<p>查看系统mysql中的存储函数：</p>
<ul>
<li>模糊查询：SHOW FUNCTION STATUS [LIKE 需要匹配的函数名]</li>
<li>精确查询：SHOW CREATE FUNCTION 函数名</li>
</ul>
<p>删除存储函数：DROP FUNCTION 函数名</p>
<p><strong>如何在存储函数中定义变量？</strong></p>
<p>语句：DECLARE 变量名 数据类型 [DEFAULT 默认值]</p>
<blockquote>
<p>  函数体中的变量名不允许加@前缀</p>
</blockquote>
<p><strong>判断语句的编写：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IF 布尔表达式 THEN</span><br><span class="line">    处理语句</span><br><span class="line">[ELSEIF 布尔表达式 THEN</span><br><span class="line">    处理语句]</span><br><span class="line">[ELSE</span><br><span class="line">    处理语句]    </span><br><span class="line">END IF;</span><br></pre></td></tr></table></figure>
<p><strong>循环语句的编写：</strong></p>
<ul>
<li><p>WHILE循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WHILE 布尔表达式 DO</span><br><span class="line">    循环语句</span><br><span class="line">END WHILE;</span><br></pre></td></tr></table></figure>
</li>
<li><p>REPEAT循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REPEAT</span><br><span class="line">    循环语句</span><br><span class="line">UNTIL 布尔表达式 END REPEAT;</span><br></pre></td></tr></table></figure>
</li>
<li><p>LOOP循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">循环标记:LOOP</span><br><span class="line">    循环语句</span><br><span class="line">    LEAVE 循环标记;</span><br><span class="line">END LOOP 循环标记;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>注释：</strong></p>
<ul>
<li>使用”–”</li>
</ul>
<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p><strong>什么是存储过程？</strong></p>
<p>存储函数侧重于执行这些语句并返回一个值，而存储过程更侧重于单纯的去执行这些语句。</p>
<p><strong>如何创建存储过程？</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE 存储过程名称([参数列表])</span><br><span class="line">BEGIN</span><br><span class="line">    需要执行的语句</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<p><strong>调用：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CALL 存储过程([参数列表]);</span><br></pre></td></tr></table></figure>
<p>存储过程在执行中产生的所有结果集，全部将会被显示到客户端。</p>
<p><strong>关于存储过程的参数，需要注意的是：</strong></p>
<p>与存储函数不一样的是，存储过程可以指定参数类型，注意参数类型和数据类型是不一样的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">参数类型 参数名 数据类型</span><br></pre></td></tr></table></figure></p>
<p>参数类型有3钟：</p>
<ol>
<li>IN-只读取参数，对在过程中对参数的重新复制并不会改变在过程调出之后的结果。。</li>
<li>OUT-只修改参数，OUT参数类型的变量只能用于赋值，对类型的变量赋值是会被调用者看到的。</li>
<li>INOUT-上述两个的结合</li>
</ol>
<p>如果不指明，默认是IN，<em>因此，在存储函数中的参数类型只能是IN</em></p>
<p><strong>查看和删除存储过程：</strong></p>
<p>查看系统mysql中的存储过程：</p>
<ul>
<li>模糊查询：SHOW PROCEDURE STATUS [LIKE 需要匹配的函过程名]</li>
<li>精确查询：SHOW CREATE PROCEDURE 过程名</li>
</ul>
<p>删除存储函数：DROP PROCEDURE 过程名</p>
<p>在存储函数中的语法都可以使用到哦存储过程中</p>
<p><strong>存储函数和存储过程的区别在哪？</strong></p>
<ol>
<li>存储函数需要指明返回，存储过程不需要。</li>
<li>参数类型不一样。</li>
<li>存储函数只能返回一个值，存储过程可以通过OUT来返回多个值。</li>
<li>存储函数的函数体的执行不会显示到客户端，存储过程的会。</li>
<li>调用的方式不同。</li>
</ol>
<h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><p><strong>游标是什么？</strong></p>
<p>给变量赋值我们之前学过使用SET 和 “=” 给 “@”变量直接赋值，和使用INTO来赋值<br>但是这样结合SQL语句时要求每一列的返回只有一个值，这样很不灵活。<br>为了解决这个问题，mysql提供了“游标”，这个概念类似JAVA中的迭代器，可以一次性赋多个值。</p>
<p><strong>如何创建一个游标？</strong></p>
<p>DECLARE 游标名称 CURSOR FOR 查询语句;</p>
<p>游标指向查询结果的第一行</p>
<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delimiter $</span><br><span class="line">CREATE PROCEDURE cursor_demo()</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE t1_record_cursor CURSOR FOR SELECT m1, n1 FROM t1;</span><br><span class="line">END $</span><br></pre></td></tr></table></figure>
<p><strong>游标需要指定打开和关闭：</strong></p>
<p>OPEN 游标名称;<br>CLOSE 游标名称;</p>
<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delimiter $</span><br><span class="line">CREATE PROCEDURE cursor_demo()</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE t1_record_cursor CURSOR FOR SELECT m1, n1 FROM t1;</span><br><span class="line"></span><br><span class="line">    OPEN t1_record_cursor;</span><br><span class="line"></span><br><span class="line">    CLOSE t1_record_cursor;</span><br><span class="line">END $</span><br></pre></td></tr></table></figure>
<p><strong>游标怎么使用？</strong></p>
<p>FETCH 游标名 INTO 变量1, 变量2, … 变量n<br>将一行中的每一列赋值到对应的变量中</p>
<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delimiter $</span><br><span class="line">CREATE PROCEDURE cursor_demo()</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE m_value INT;</span><br><span class="line">    DECLARE n_value CHAR(1);</span><br><span class="line"></span><br><span class="line">    DECLARE t1_record_cursor CURSOR FOR SELECT m1, n1 FROM t1;</span><br><span class="line"></span><br><span class="line">    OPEN t1_record_cursor;</span><br><span class="line"></span><br><span class="line">    FETCH t1_record_cursor INTO m_value, n_value;</span><br><span class="line">    SELECT m_value, n_value;</span><br><span class="line"></span><br><span class="line">    CLOSE t1_record_cursor;</span><br><span class="line">END $</span><br></pre></td></tr></table></figure>
<p>现在只能取出一条<br>游标在使用“FETCH”之后自动转向下一行，没有下一行的时候指向NULL。</p>
<p><strong>那么当FETCH判断当前为NULL的时候，后面的语句还会执行吗？</strong></p>
<p>有下面两种语法：<br>DECLARE CONTINUE HANDLER FOR NOT FOUND 可执行语句;<br>DECLARE EXIT HANDLER FOR NOT FOUND 可执行语句;<br>这个语句的含义是使用“FETCH”时，如果检查到当前游标指向是null，则执行后面的语句。<br>上面两个的区别类似JAVA中的continue和break</p>
<p>案例1：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE cursor_demo()</span><br><span class="line">BEGIN</span><br><span class="line">    -- 声明变量</span><br><span class="line">    DECLARE m_value INT;</span><br><span class="line">    DECLARE n_value CHAR(1);</span><br><span class="line">    DECLARE not_done INT DEFAULT 1;</span><br><span class="line"></span><br><span class="line">    -- 声明游标</span><br><span class="line">    DECLARE t1_record_cursor CURSOR FOR SELECT m1, n1 FROM t1;</span><br><span class="line"></span><br><span class="line">    -- 在游标遍历完记录的时候将变量 not_done 的值设置为 0，并且继续执行后边的语句</span><br><span class="line">    DECLARE CONTINUE HANDLER FOR NOT FOUND SET not_done = 0;  </span><br><span class="line"></span><br><span class="line">    -- 使用游标遍历</span><br><span class="line">    OPEN t1_record_cursor;</span><br><span class="line"></span><br><span class="line">    WHILE not_done = 1 DO</span><br><span class="line">        FETCH t1_record_cursor INTO m_value, n_value;</span><br><span class="line">        SELECT m_value, n_value, not_done;</span><br><span class="line">    END WHILE;</span><br><span class="line"></span><br><span class="line">    CLOSE t1_record_cursor;</span><br><span class="line">END</span><br></pre></td></tr></table></figure></p>
<p>结果：</p>
<p><img src="/2018/09/29/MySQL/存储程序/2.png" alt="案例1"></p>
<p>分析一下：使用CONTINUE的方式，最后一行会执行两次，为什么？</p>
<p>案例2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE cursor_demo()</span><br><span class="line">BEGIN</span><br><span class="line">    -- 声明变量</span><br><span class="line">    DECLARE m_value INT;</span><br><span class="line">    DECLARE n_value CHAR(1);</span><br><span class="line">    DECLARE not_done INT DEFAULT 1;</span><br><span class="line"></span><br><span class="line">    -- 声明游标</span><br><span class="line">    DECLARE t1_record_cursor CURSOR FOR SELECT m1, n1 FROM t1;</span><br><span class="line"></span><br><span class="line">    -- 在游标遍历完记录的时候将变量 not_done 的值设置为 0，并且不再执行后边的语句</span><br><span class="line">    DECLARE EXIT HANDLER FOR NOT FOUND SET not_done = 0;</span><br><span class="line"></span><br><span class="line">    -- 使用游标遍历</span><br><span class="line">    OPEN t1_record_cursor;</span><br><span class="line"></span><br><span class="line">    WHILE not_done = 1 DO</span><br><span class="line">        FETCH t1_record_cursor INTO m_value, n_value;</span><br><span class="line">        SELECT m_value, n_value, not_done;</span><br><span class="line">    END WHILE;</span><br><span class="line"></span><br><span class="line">    CLOSE t1_record_cursor;</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p><strong>什么是触发器？</strong></p>
<p>在执行插入，更新，删除操作之前或者之后执行其它操作（比如校验数据）</p>
<p><strong>创建触发器：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER 触发器名</span><br><span class="line">&#123;BEFORE|AFTER&#125;          </span><br><span class="line">&#123;INSERT|DELETE|UPDATE&#125;</span><br><span class="line">ON 表名</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">    触发器内容</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<p>EACH ROW表示</p>
<ul>
<li>INSERT:表示新插入的数据。</li>
<li>DELETE:表示将要删除的那些数据。</li>
<li>UPDATE:表示将要更新的那些数据。</li>
</ul>
<p>如何操作还没有记录到数据库中的数据呢？</p>
<ul>
<li>OLD：操作记录之前的旧数据（对于INSERT而言不存在）</li>
<li>NEW：操作记录之前的新数据（对于DELETE而言不存在）</li>
</ul>
<p><strong>BEFORE和AFTER之间的区别到底是什么呢？</strong></p>
<p>理解的一个点在于当需要操作的数据记录到数据库中之后就不允许做修改。<br>一般需要更改要操作的数据时使用before。如果记录日志要使用after。</p>
<p>注意：</p>
<ol>
<li>触发器中不能有输出结果</li>
</ol>
<p><strong>删除和查看触发器：</strong></p>
<ul>
<li>查看当前数据库的触发器：SHOW TRIGGERS;</li>
<li>查看具体的触发器定义：SHOW CREATE TRIGGER 触发器名;</li>
<li>删除触发器：DROP TRIGGER 触发器名;</li>
</ul>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p><strong>什么是事件？</strong></p>
<p>指定一个事件或者某个周期指定一些操作称为事件。</p>
<p><strong>创建事件：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE EVENT 事件名</span><br><span class="line">ON SCHEDULE</span><br><span class="line">&#123;AT 某个确定的时间点 | EVERY 期望的时间间隔 [STARTS datetime][END datetime]&#125;</span><br><span class="line">DO</span><br><span class="line">BEGIN</span><br><span class="line">    具体的语句</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<ol>
<li>事件点：<br>AT ‘2018-03-10 15:48:54’<br>AT DATE_ADD(NOW(), INTERVAL 2 DAY)–表示两天后</li>
<li>周期<br>EVERY 1 HOUR<br>EVERY 1 HOUR STARTS ‘2018-03-10 15:48:54’ ENDS ‘2018-03-12 15:48:54’</li>
</ol>
<p><strong>查看和删除事件？</strong></p>
<ul>
<li>查看所有事件：SHOW EVENTS;</li>
<li>查看具体事件的定义：SHOW CREATE EVENT 事件名;</li>
<li>删除事件：DROP EVENT 事件名;</li>
</ul>
<p>事件需要手动启动：event_scheduler = ON</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL存储程序</tag>
      </tags>
  </entry>
  <entry>
    <title>11 持有对象</title>
    <url>/2018/10/23/THING%20IN%20JAVA/11%20%E6%8C%81%E6%9C%89%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="持有对象"><a href="#持有对象" class="headerlink" title="持有对象"></a>持有对象</h1><h2 id="为什么需要容器"><a href="#为什么需要容器" class="headerlink" title="为什么需要容器"></a>为什么需要容器</h2><p>有时候需要在程序运行的时候创建对象，这时候就无法通过一开始去new了，因此需要一个容器来动态的去保存在运行时候创建的对象，array类型是我们熟知的容器，数组将数字与对象联系起来：它保存类型明确的对象，查询对象时，不需要对结果做类型转换；它可以是多维的，可以保存基本类型的数据；但是，数组一旦生成，其容量不能改变。因此JAVA使用更多的集合类来处理这种情况。</p>
<h2 id="添加一组元素"><a href="#添加一组元素" class="headerlink" title="添加一组元素"></a>添加一组元素</h2><p>一般都是使用add方法向容器中一个一个的添加元素</p>
<p><strong>如何一次性添加多个元素？</strong></p>
<p>Collection（父类）中提供了接受其他容器来初始化它的构造器，只是这样的速度比较慢。<br>Collection（父类）还有一个addAll的方法，同样也是接受其他容器的参数一次性添加。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;Integer&gt; collection = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));     </span><br><span class="line">Integer[] moreInts = &#123; <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;     </span><br><span class="line">collection.addAll(Arrays.asList(moreInts));</span><br></pre></td></tr></table></figure></p>
<p>上面两种方法都是接受另一个容器对象，可能我希望还可以参数是数组，甚至是 一串以逗号分开的数字。</p>
<p><strong>那么如何将这串数组，或者数组转为容器呢？</strong></p>
<p>util包里有一个Arrays的工具包，它有一个asList的方法，可以将数组，或者一串以逗号分开的数字，转成列表:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] moreInts = &#123; <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line">Arrays.asList(moreInts);</span><br><span class="line">Arrays.asList(<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure></p>
<p>还有一个Conllections的工具类，可以进一步的减少添加一组数组对象的中间过程：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;Integer&gt; collection = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">Integer[] moreInts = &#123; <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line">Collections.addAll(collection, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>);</span><br><span class="line">Collections.addAll(collection, moreInts);</span><br></pre></td></tr></table></figure></p>
<p><strong>推荐使用Collections来添加元素，为什么？</strong></p>
<p>使用Collections結合空容器添加元素是最好的办法，因为直接使用Arrays.asList会有两个问题：</p>
<ol>
<li><p>使用Arrays.asList的时候，需要注意一个问题：它转换后的容器是可以修改元素值，但是不能修改元素的长度的，<strong>为啥？</strong><br>原因是Arrays.asList转换的容器基本底层形式是数组，它不能调整大小。<br><em>并且如果这个容器的元素和顺序被修改，直接会影响到原数组。</em></p>
</li>
<li><p>使用Arrays.asList的时候，还需要注意另外的一个问题：它会对列表的结果类型进行最佳猜测，不管我们指定它是怎样的类型，如果有冲突，会报错。<br>案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Snow</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Powder</span> <span class="keyword">extends</span> <span class="title">Snow</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Light</span> <span class="keyword">extends</span> <span class="title">Powder</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heavy</span> <span class="keyword">extends</span> <span class="title">Powder</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crusty</span> <span class="keyword">extends</span> <span class="title">Snow</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Slush</span> <span class="keyword">extends</span> <span class="title">Snow</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Snow&gt; snow2 = Arrays.asList(<span class="keyword">new</span> Light(), <span class="keyword">new</span> Heavy());<span class="comment">//编译报错</span></span><br><span class="line">List&lt;Snow&gt; snow1 = Arrays.asList(<span class="keyword">new</span> Crusty(), <span class="keyword">new</span> Slush(), <span class="keyword">new</span> Powder());<span class="comment">//编译成功</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>如何使用Collections防止出现这个问题？</strong><br>直接上源码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Snow&gt; snow3 = <span class="keyword">new</span> ArrayList&lt;Snow&gt;();     </span><br><span class="line">Collections.addAll(snow3, <span class="keyword">new</span> Light(), <span class="keyword">new</span> Heavy());</span><br></pre></td></tr></table></figure></p>
<h2 id="输入容器"><a href="#输入容器" class="headerlink" title="输入容器"></a>输入容器</h2><p>在打印数组的使用，会打印数组的一个引用，因此需要使用Arrays.toString方法先将数组转为字符串。</p>
<p><strong>容器呢？</strong></p>
<p>抱歉，让你失望了。<br>容器很好的重写了toString方法。<br>因此直接打印即可输出里面的元素。</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>HashMap:快速访问<br>TreeMap:“键”保持插入顺序<br>LinkedMap:保持插入顺序，并且提供快速访问。</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>使用ListIterator可以实现双向迭代，需要注意的一点是迭代器的指向是两个元素之前的位置。</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是描述后进先出的，栈是用Linklist实现的。</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列描述的是先进先出的元素弹出规则。<br>队列在并发编程里很重要，并且LinkedList实现了Quene接口。</p>
<p>优先级队列描述的是按优先级的元素弹出规则</p>
<p><strong>如何定义这个优先级？</strong><br>结合Comparator来定义，有一个构造器如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue(<span class="keyword">int</span> initialCapacity, Comparator&lt;? <span class="keyword">super</span> E&gt; comparator);</span><br></pre></td></tr></table></figure></p>
<h2 id="Collection和Iterator"><a href="#Collection和Iterator" class="headerlink" title="Collection和Iterator"></a>Collection和Iterator</h2><p><strong>Collection是什么？</strong></p>
<p>Collection接口是所有容器的共有接口，这个接口的表示是一个可以持有对象的容器。<br>他有一个AbstractCollection的子类，实现了Collection的绝大部分方法，<br>Iterator接口是迭代器模式，表示支持迭代。</p>
<p><strong>Collection支持迭代吗？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>由上可见，是支持的。</p>
<p><strong>为什么实现Iterable就支持迭代？</strong></p>
<p>因为Iterable接口中有一个返回Iterator接口的方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>Iterator接口有何用？</strong></p>
<p>这个接口中定义了next(),hasNext(),remove()三种方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"remove"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">while</span> (hasNext())</span><br><span class="line">            action.accept(next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一种迭代器模式，可以让所有实现该接口的对象有一种遍历自己内部“元素”而无需暴露具体实现细节的方法。</p>
<p><strong>为什么Collection不实现Iterator，而是实现Iterable？</strong></p>
<p>Iterable是Iterator的一个封装，目前看来有两个好处：</p>
<ol>
<li>Iterator中是由“指针”来指向迭代的元素，这样的一个问题是，我下一次一个新的迭代无法从头开始。</li>
<li>Iterable可以使用foreach操作来简化。</li>
</ol>
<p><strong>如何让新对象支持迭代？</strong></p>
<p>要么实现Collection,要么实现Iterable。<br>不建议实现Collection，因为他需要实现的方法较多,可以继承AbstractCollection：只是还是需要实现size()和iterator()两个方法。</p>
<h2 id="foreach和迭代器"><a href="#foreach和迭代器" class="headerlink" title="foreach和迭代器"></a>foreach和迭代器</h2><p><strong>什么情况下可以使用foreach？</strong></p>
<p>实现了Iterable接口就可以。<br>基本上所有的Collection都可以，除了Map之外。</p>
<p><strong>那Map如何迭代？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnvironmentVariables</span> </span>&#123;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">for</span>(Map.Entry entry: map.entrySet()) &#123;       </span><br><span class="line">      System.out.println(entry.getKey() + <span class="string">": "</span> + entry.getValue());     </span><br><span class="line">    &#125;   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>entrySet获得Entry类型的Set，然后遍历这个Set即可。</p>
<p><strong>foreach的迭代规则是如何的？</strong></p>
<p>foreach()实际上就是：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterable i;i.hasNext();)&#123;</span><br><span class="line">  Object o = i.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，规则是由Iterable中的iterator()来制定的。</p>
<p><strong>如何制定多个规则？</strong></p>
<p>分析一下这个问题的本质：</p>
<ol>
<li>这个类是现有的，我们不希望去更改它的源代码</li>
<li>本身有可能已经存在了一个规则，这时候不希望覆盖它。</li>
<li>实现的接口名和方法名一样</li>
<li>多个规则表示多重继承（接口）</li>
</ol>
<p>1点指明需要使用适配模式，使用继承方法的适配模式即可。<br>2，3，4点都指明应该使用内部类，更好的是匿名内部类。</p>
<p>案例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReversibleArrayList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ReversibleArrayList</span><span class="params">(Collection&lt;T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(c);</span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Iterable&lt;T&gt; <span class="title">reversed</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Iterable&lt;T&gt;() &#123;       </span><br><span class="line">      <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;         </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;T&gt;() &#123;           </span><br><span class="line">          <span class="keyword">int</span> current = size() - <span class="number">1</span>;           </span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> current &gt; -<span class="number">1</span>;</span><br><span class="line">          &#125;           </span><br><span class="line">          <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> get(current--);</span><br><span class="line">          &#125;           </span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Not implemented             </span></span><br><span class="line">            <span class="comment">//throw new UnsupportedOperationException();           </span></span><br><span class="line">          &#125;         </span><br><span class="line">        &#125;;       </span><br><span class="line">      &#125;     </span><br><span class="line">    &#125;;   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterMethodIdiom</span> </span>&#123;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     </span><br><span class="line">    ReversibleArrayList&lt;String&gt; ral =</span><br><span class="line">    <span class="keyword">new</span> ReversibleArrayList&lt;String&gt;(Arrays.asList(<span class="string">"To be or not to be"</span>.split(<span class="string">" "</span>)));   </span><br><span class="line">    <span class="comment">// Grabs the ordinary iterator via iterator():     </span></span><br><span class="line">    <span class="keyword">for</span>(String s : ral)       </span><br><span class="line">    System.out.print(s + <span class="string">" "</span>);     </span><br><span class="line">    System.out.println();     </span><br><span class="line">    <span class="comment">// Hand it the Iterable of your choice     </span></span><br><span class="line">    <span class="keyword">for</span>(String s : ral.reversed())       </span><br><span class="line">    System.out.print(s + <span class="string">" "</span>);   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">To be or not to be</span></span><br><span class="line"><span class="comment">be to not or be To</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Thinking in Java 读书笔记</category>
      </categories>
      <tags>
        <tag>JAVA编程思想</tag>
        <tag>Thinking in JAVA</tag>
        <tag>持有对象，容器</tag>
      </tags>
  </entry>
  <entry>
    <title>09 接口</title>
    <url>/2018/10/01/THING%20IN%20JAVA/09%20%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h2><p>使用接口可以实现完全解耦，解耦的字面意思就是解除耦合。</p>
<p><strong>什么是耦合？</strong></p>
<p>物理上的耦合是指：耦合是指两个或两个以上的体系或两种运动形式间通过相互作用而彼此影响以至联合起来的现象。<br>软件工程中的耦合是指：对象之间的耦合度就是对象之间的依赖性。通俗的说就是，我在一个具体的对象A里用了另一个具体的对象B。</p>
<p>耦合就是硬编码，把代码写死。</p>
<p><strong>耦合度高有什么影响？</strong></p>
<p>耦合度越高，代码之间的关联越大，影响是双向的，降低的代码的复用性和<br>比如在对象A中调用了对象B</p>
<ol>
<li><p>下对上的影响：修改B的代码（甚至是删掉B的代码）可能导致A中调用的B的方法丢失，造成错误。</p>
<blockquote>
<p>举个例子：电脑拔掉了鼠标依然可以运行，就是解耦。</p>
</blockquote>
</li>
<li><p>上对下的影响：A中的方法可能只适用于B，而不适用于其他的类。</p>
<blockquote>
<p>同样的例子：换个鼠标就用不了了。</p>
</blockquote>
</li>
</ol>
<p><strong>解耦的核心思想是什么？</strong></p>
<p>把关联依赖降到最低，实现模块化编程，而不至于牵一发而动全身，提高代码的复用和高可用，便于开发和维护。</p>
<p><strong>使用接口如何实现解耦了？</strong></p>
<p>我们先来看看没有使用接口的耦合案例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Upcase</span> <span class="keyword">extends</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">process</span><span class="params">(Object input)</span> </span>&#123; <span class="comment">// Covariant return     </span></span><br><span class="line">        <span class="keyword">return</span> ((String) input).toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Downcase</span> <span class="keyword">extends</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((String) input).toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Splitter</span> <span class="keyword">extends</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;     <span class="comment">// The split() argument divides a String into pieces:     </span></span><br><span class="line">        <span class="keyword">return</span> Arrays.toString(((String) input).split(<span class="string">" "</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apply</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Processor p, Object s)</span> </span>&#123;</span><br><span class="line">        print(<span class="string">"Using Processor "</span> + p.name());</span><br><span class="line">        print(p.process(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String s = <span class="string">"Disagreement with beliefs is by definition incorrect"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        process(<span class="keyword">new</span> Upcase(), s);</span><br><span class="line">        process(<span class="keyword">new</span> Downcase(), s);</span><br><span class="line">        process(<span class="keyword">new</span> Splitter(), s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面是使用继承实现的<em>策略设计模式</em></p>
<p><strong>什么是策略设计模式</strong></p>
<p>一个方法，由于传进来的参数的不同，表现不同的行为，这样的一种模式就是策略设计模式。<br>策略就是具体的参数对象，它是体现这个方法的不同的地方。</p>
<p><strong>哪里耦合了？</strong></p>
<p>之前的案例中的方式只能针对Processor以及它的子类，如果我的需求更改，要让另一个类Filter以及它的子类也能运用Apply中的process方法，这时，只能修改我们的Apply类或者另建一个新类。</p>
<p><strong>使用接口如何实现解耦？</strong></p>
<p>话不多说，直接上代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">process</span><span class="params">(Object input)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apply</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Processor p, Object s)</span> </span>&#123;</span><br><span class="line">        print(<span class="string">"Using Processor "</span> + p.name());</span><br><span class="line">        print(p.process(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果要让另一个类Filter以及它的子类也能运用Apply中的process方法，即让Filter也实现Processor即可。</p>
<p><strong>使用实现接口比继承类好（更加解耦）的原因是：</strong></p>
<ol>
<li>接口其实是一个中间商，它并不偏袒任何一方，只是它提供了一个约定，要求双方都去遵循这个约定：对于实现方而言，接口要求你必须实现了我这些约定的方法；对于调用方而言，接口要求你只能调用我约定的方法，无法得知更多的信息。</li>
</ol>
<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><ol start="2">
<li>类不存在多重继承，也就意味着他只有一个父类，也就意味着它只能展示一个Process的多态性，如果要求它同时展示Process2的多态性的时候，就不行了，这其实就是耦合的一种表现形式。</li>
</ol>
<p>接口可以继承，类可以实现多个接口。</p>
<h2 id="适配接口"><a href="#适配接口" class="headerlink" title="适配接口"></a>适配接口</h2><ol start="3">
<li>在我们之前提到的策略模式里，我们说让Filter也实现Processor就可以了，但是如果这个Filter是从其他地方引入进来的。而我们没法修改它的代码的时候怎么办？使用适配器模式，这也是接口完全解耦了的一个原因，类的话是无法实现适配器模式的。-</li>
</ol>
<p><strong>什么是适配器模式？</strong></p>
<p>适配器模式是<em>通过实现接口来包装一个已经存在的不兼容类，使其能和其它类中的方法兼容</em>的工作模式。<br>可以类比生活中插头的例子，香港的插头只适用于香港那边的接口，如果要把香港的插头插到国内，就需要适配器（这里也清楚为什么使用类无法做到了，因为类无法多重继承）。</p>
<p>一般都过组合或者继承的方式来实现。<br>继承:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AdaptedRandomDoubles extends RandomDoubles implements Readbale&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>组合:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AdaptedRandomDoubles implements Readbale&#123;</span><br><span class="line">  RandomDoubles randomDoubles = new RandomDoubles();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>使用组合和继承有什么区别？</strong></p>
<p>组合是对象适配器，只会包装对象使其工作。<br>继承是类适配器，能包装一个类以及它的所有子类。</p>
<p><strong>适配器如何解决了上述问题？</strong></p>
<p>直接上源码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomDoubles</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rand.nextDouble();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RandomDoubles rd = <span class="keyword">new</span> RandomDoubles();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) System.out.print(rd.next() + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一个没有实现Readable的类，如果想要Scanner中的方法去使用这个策略，需要使用适配器：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AdaptedRandomDoubles extends RandomDoubles implements Readbale</span><br></pre></td></tr></table></figure></p>
<h2 id="用接口实现工厂方法设计模式"><a href="#用接口实现工厂方法设计模式" class="headerlink" title="用接口实现工厂方法设计模式"></a>用接口实现工厂方法设计模式</h2><p><strong>工厂是指什么？</strong></p>
<p>工厂是用来创建对象的接口。</p>
<p><strong>什么是工厂方法设计模式？</strong></p>
<p>让实现工厂接口的子类去决定具体创建哪一个对象的模式就是工厂方法设计模式。<br>案例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Blacksmith</span> </span>&#123;</span><br><span class="line">  <span class="function">Weapon <span class="title">manufactureWeapon</span><span class="params">(WeaponType weaponType)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElfBlacksmith</span> <span class="keyword">implements</span> <span class="title">Blacksmith</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Weapon <span class="title">manufactureWeapon</span><span class="params">(WeaponType weaponType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ElfWeapon(weaponType);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrcBlacksmith</span> <span class="keyword">implements</span> <span class="title">Blacksmith</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Weapon <span class="title">manufactureWeapon</span><span class="params">(WeaponType weaponType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OrcWeapon(weaponType);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>为什么要使用工厂来创建对象？</strong></p>
<p>使用工厂模式的目的之一还是为了提高代码的复用，减少耦合。<br>如果不使用工厂模式，就会在代码中使用到很多的 new 构造器()。<br>倘若以后这些构造器发生变化，又或者我需要换用其他的构造器，这样就需要在代码中一一修改。<br>那么这时候就可以使用工厂方法解决这个问题。<br>把new的过程放到工厂里，我在其他地方放心的调用工厂即可。</p>
<p><strong>为什么不让类返回自己的实例？</strong></p>
<p>如果说使用工厂方法是为了new一个实例，那用下面的方法也可以实现：<br>将构造器私有化，然后暴露一个返回实例对象的方法（实际上这已经有些类似单例模式了），如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Weapon</span></span>&#123;</span><br><span class="line">  <span class="function">Weapon <span class="title">getWeapon</span> <span class="params">(WeaponType weaponType)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElfWeapon</span> <span class="keyword">implements</span> <span class="title">Weapon</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ElfWeapon</span><span class="params">(WeaponType weaponType)</span>_</span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Weapon <span class="title">getWeapon</span><span class="params">(WeaponType weaponType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ElfWeapon(weaponType);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在我认为，上诉方法只是工厂方法的一个变形，类自身作为自身的工厂，代码上可行，但是不符合面向对象的程序设计，但是我们可以这样改进：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Weapon</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElfBlacksmith</span> <span class="keyword">implements</span> <span class="title">Blacksmith</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Weapon <span class="title">manufactureWeapon</span><span class="params">(WeaponType weaponType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ElfWeapon(weaponType);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElfWeapon</span> <span class="keyword">implements</span> <span class="title">Weapon</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ElfWeapon</span><span class="params">(WeaponType weaponType)</span>_</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> GanmeFactory factory = <span class="keyword">new</span> ElfBlacksmith();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Weapon <span class="title">getWeapon</span><span class="params">(WeaponType weaponType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> factory.manufactureWeapon(weaponType);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是我们依然发现有一个遗憾，这个工厂类的定义似乎有些多余了，因为它只会被使用一次，所以依然有改进的余地，至于如何改进，会在匿名内部类中讲解。</p>
]]></content>
      <categories>
        <category>Thinking in Java 读书笔记</category>
      </categories>
      <tags>
        <tag>JAVA编程思想</tag>
        <tag>Thinking in JAVA</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title>14 类型信息</title>
    <url>/2018/11/02/THING%20IN%20JAVA/14%20%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<h1 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h1><p><strong>类型信息是什么？</strong></p>
<p>回顾一下java的类初始化和对象初始化：</p>
<ol>
<li>当首次调用静态方法，静态字段，构造器（可以看成静态方法）时，检查.class文件，若未发现，则编译源文件生成.class文件，然后加载生成Class对象，开始类初始化：按顺序执行所有的静态初始化。</li>
<li>之后就不会再做类初始化了，当调用new()的时候执行对象的初始化：先在堆上分配空间，这块空间会被清零，也就是开始赋默认值，执行非静态的初始化。</li>
<li>执行构造器。</li>
<li>将引用指向这个地址（这一步有可能重排序）</li>
</ol>
<p>.class文件是编译后产生的。<br>因此：这里的类型信息指的就是在类初始化的时候，加载完.class文件后，由JVM生成的Class类型实例。</p>
<h2 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h2><p><strong>java如何支持运行时类型检查？</strong></p>
<ol>
<li>RTTI：运行时类型信息</li>
<li>反射</li>
</ol>
<p><strong>RTTI的应用？</strong></p>
<p>JAVA中所有的类型转换，都会在运行时期做类型检查（比如判断能否转换），这就需要获取到对应的类型信息，这也是RTTI最基本的应用。<br>运行时类型检查是隐式的运用了RTTI<br>要想理解RTTI的工作原理，或者显式的使用RTTI，那么就要明白Class对象。</p>
<h2 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h2><p><strong>如何生成和使用Class对象？</strong></p>
<p>JAVA提供Class类来让程序员获取类信息，每一个类都会有一个Class对象。</p>
<p>如何生成Class对象。</p>
<ol>
<li>使用Class.forName()</li>
<li>使用类字面常量：类.class</li>
<li>使用对象中的方法：对象.getClass()<blockquote>
<p>使用getClass()是获取运行时的实际类型信息</p>
</blockquote>
</li>
</ol>
<p><strong>使用.class和使用Class.forName()生成Class对象有什么不同</strong></p>
<p>初始化的阶段不同，.class的类初始化（执行静态初始化块）是延迟性的，在访问他的静态方法或者非静态成员的时候才开始初始化。注意在访问静态常量的时候是不会执行<br>初始化的：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Initable</span> </span>&#123;   </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> staticFinal = <span class="number">47</span>;   <span class="comment">//静态常量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> staticFinal2 = ClassInitialization.rand.nextInt(<span class="number">1000</span>);   </span><br><span class="line">  <span class="keyword">static</span> &#123;    </span><br><span class="line">    System.out.println(<span class="string">"Initializing Initable"</span>);   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>为什么使用泛化的Class？</strong></p>
<p>给Class的引用加一个限定，让编译器做类型检查，这也是泛型的一个作用。<br>并且在使用newInstance()的时候也可以用具体类型的引用去接收。</p>
<p><strong>如果我们想放宽泛型的类型检查？</strong></p>
<p>使用父类为类型参数的泛型时行不通的。</p>
<p>分析下面两个向上转型的情形：<br>Number和Integer：可以向上转型<br>Class<number>和Class<integer>：不可以向上转型</integer></number></p>
<p>解决方案是使用通配符：Class&lt;?&gt;</p>
<p><strong>使用通配符的Class和平凡的Class的区别？</strong></p>
<p>仅仅时候&lt;?&gt;行和平凡的Class没有任何区别，只是这样表示我们是有意为之，而不是大意疏忽。<br>另外，&lt;?&gt;可以使用边界限定来进一步限定。</p>
<h2 id="类型转换前先做类型检查"><a href="#类型转换前先做类型检查" class="headerlink" title="类型转换前先做类型检查"></a>类型转换前先做类型检查</h2><p><strong>为什么要做类型检查？</strong></p>
<p>仅仅使用RTTI的话，可以支持类型检查，但是如果到了运行时期才发现类型不一致，会报错抛出ClassCastException异常。</p>
<p><strong>如何做类型检查？</strong></p>
<ol>
<li>使用instanceOf关键词（注意，这是一个关键字。） 对象 instanceOf 类型名：对象是该类型或者子类</li>
</ol>
<p><strong>instanceof的限制？</strong></p>
<p>这里的“类型名”无法放在容器中做迭代处理，如果需求需要计数，只是使用很多instanceOf来一一判断，这是不好的。</p>
<p><strong>如何优化？</strong></p>
<ol start="2">
<li><p>使用 Class对象.isInstance(对象)：对象是该类型或者子类<br>这样一来可以将多个Class对象存放到容器中，做遍历。</p>
</li>
<li><p>使用 Class对象 == Class对象 或者 Class对象.equle(Class对象)，这两个产生的效果一样;</p>
<blockquote>
<p>使用Class的话，是不涉及子类、父类的，就是类型比较。</p>
</blockquote>
</li>
</ol>
<p><strong>容器中的Class对象必须写死，如何进一步优化？</strong></p>
<ol start="3">
<li>使用 Class对象.isAssignableFrom(Class对象)：后者是前者类型或者其父类。<br>这样一来，前一个父级Class对象可以作为参数传递进来。</li>
</ol>
<h2 id="注册工厂"><a href="#注册工厂" class="headerlink" title="注册工厂"></a>注册工厂</h2><p>这个知识点没弄太明白，先只介绍，案例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Part</span> </span>&#123;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">return</span> getClass().getSimpleName();   </span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="keyword">static</span> List&lt;Factory&lt;? extends Part&gt;&gt; partFactories =     <span class="keyword">new</span> ArrayList&lt;Factory&lt;? extends Part&gt;&gt;();        </span><br><span class="line">  <span class="keyword">static</span> &#123;     </span><br><span class="line">    <span class="comment">// Collections.addAll() gives an "unchecked generic     </span></span><br><span class="line">    <span class="comment">// array creation ... for varargs parameter" warning.     </span></span><br><span class="line">    partFactories.add(<span class="keyword">new</span> FuelFilter.Factory());     </span><br><span class="line">    partFactories.add(<span class="keyword">new</span> AirFilter.Factory());     </span><br><span class="line">    partFactories.add(<span class="keyword">new</span> CabinAirFilter.Factory());     </span><br><span class="line">    partFactories.add(<span class="keyword">new</span> OilFilter.Factory());     </span><br><span class="line">    partFactories.add(<span class="keyword">new</span> FanBelt.Factory());     </span><br><span class="line">    partFactories.add(<span class="keyword">new</span> PowerSteeringBelt.Factory());     </span><br><span class="line">    partFactories.add(<span class="keyword">new</span> GeneratorBelt.Factory());   </span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Part <span class="title">createRandom</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">     <span class="keyword">int</span> n = rand.nextInt(partFactories.size());     </span><br><span class="line">     <span class="keyword">return</span> partFactories.get(n).create();   </span><br><span class="line">   &#125;</span><br><span class="line">  &#125;     </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Filter</span> <span class="keyword">extends</span> <span class="title">Part</span> </span>&#123;&#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">FuelFilter</span> <span class="keyword">extends</span> <span class="title">Filter</span> </span>&#123;   </span><br><span class="line">    <span class="comment">// Create a Class Factory for each specific type:   </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span>   <span class="keyword">implements</span> <span class="title">typeinfo</span>.<span class="title">factory</span>.<span class="title">Factory</span>&lt;<span class="title">FuelFilter</span>&gt; </span>&#123;     </span><br><span class="line">      <span class="function"><span class="keyword">public</span> FuelFilter <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FuelFilter();</span><br><span class="line">      &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">AirFilter</span> <span class="keyword">extends</span> <span class="title">Filter</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span>   <span class="keyword">implements</span> <span class="title">typeinfo</span>.<span class="title">factory</span>.<span class="title">Factory</span>&lt;<span class="title">AirFilter</span>&gt; </span>&#123;     </span><br><span class="line">      <span class="function"><span class="keyword">public</span> AirFilter <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AirFilter();</span><br><span class="line">      &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;      </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">CabinAirFilter</span> <span class="keyword">extends</span> <span class="title">Filter</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span>   <span class="keyword">implements</span> <span class="title">typeinfo</span>.<span class="title">factory</span>.<span class="title">Factory</span>&lt;<span class="title">CabinAirFilter</span>&gt; </span>&#123;     </span><br><span class="line">      <span class="function"><span class="keyword">public</span> CabinAirFilter <span class="title">create</span><span class="params">()</span> </span>&#123;      </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CabinAirFilter();     </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">OilFilter</span> <span class="keyword">extends</span> <span class="title">Filter</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span>   <span class="keyword">implements</span> <span class="title">typeinfo</span>.<span class="title">factory</span>.<span class="title">Factory</span>&lt;<span class="title">OilFilter</span>&gt; </span>&#123;    </span><br><span class="line">      <span class="function"><span class="keyword">public</span> OilFilter <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OilFilter();</span><br><span class="line">      &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;      </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Belt</span> <span class="keyword">extends</span> <span class="title">Part</span> </span>&#123;&#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">FanBelt</span> <span class="keyword">extends</span> <span class="title">Belt</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span>   <span class="keyword">implements</span> <span class="title">typeinfo</span>.<span class="title">factory</span>.<span class="title">Factory</span>&lt;<span class="title">FanBelt</span>&gt; </span>&#123;     </span><br><span class="line">      <span class="function"><span class="keyword">public</span> FanBelt <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanBelt();</span><br><span class="line">      &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">GeneratorBelt</span> <span class="keyword">extends</span> <span class="title">Belt</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span>   <span class="keyword">implements</span> <span class="title">typeinfo</span>.<span class="title">factory</span>.<span class="title">Factory</span>&lt;<span class="title">GeneratorBelt</span>&gt; </span>&#123;     </span><br><span class="line">      <span class="function"><span class="keyword">public</span> GeneratorBelt <span class="title">create</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GeneratorBelt();     </span><br><span class="line">      &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;      </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">PowerSteeringBelt</span> <span class="keyword">extends</span> <span class="title">Belt</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span>   <span class="keyword">implements</span> <span class="title">typeinfo</span>.<span class="title">factory</span>.<span class="title">Factory</span>&lt;<span class="title">PowerSteeringBelt</span>&gt; </span>&#123;     </span><br><span class="line">      <span class="function"><span class="keyword">public</span> PowerSteeringBelt <span class="title">create</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PowerSteeringBelt();     </span><br><span class="line">      &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;      </span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisteredFactories</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)       </span><br><span class="line">      System.out.println(Part.createRandom());   </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  Output: GeneratorBelt CabinAirFilter GeneratorBelt AirFilter PowerSteeringBelt CabinAirFilter FuelFilter PowerSteeringBelt PowerSteeringBelt FuelFilter */</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure></p>
<p>和之前在学习类型检查的时候定义的Pet和LiteralPetCreator的运用相比，有以下区别：</p>
<ol>
<li>需要生成对象的列表信息存放在基类中，而不是其他的类。</li>
<li>生成对象的方式不一样，注册工厂采用了工厂模式的方法。</li>
</ol>
<p><strong>使用new 和 newInstance()的区别</strong></p>
<p>new:效率较高，但其实是一种硬编码，耦合度较高，使用工厂方法减缓了这种硬编码，但也只是把耦合弄到了工厂中。<br>newInstance:所有Class都具有的方法，可以实现代码的自动化，实现完全耦合。</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>之前讲到的RTTI都存在一个限制，那就是都可以明确我们想要处理的类型是哪一种，如果出现下面几种情况(举例)：</p>
<ol>
<li>工具类中的一个方法，需要传入一个Class类型的参数，这时候不能明确需要处理的类型。</li>
<li>IOC编程。</li>
<li>.class文件通过网络传输过来。<br>这些时候就需要使用反射了：</li>
</ol>
<p>反射是使用Class和java.lang.reflect(包含Field，Method和Constructor)做支持。</p>
<p><strong>RTTI和反射的区别？</strong><br>RTTI实际上是一个来之C++的概念，是传统的获取类型信息的方式，获取类型名称，对比类型是否一致等等，而JAVA中的反射是一种新的获取类型信息的方式，功能比RTTI更强大，可以把使用到reflect的RTTI叫作反射，又或者都可以称之为反射，不要太纠结。</p>
<p><strong>反射的应用：</strong></p>
<ol>
<li>类方法生成器</li>
<li>代理</li>
</ol>
<p><strong>什么是代理模式？</strong></p>
<p>当您希望将额外的操作分离到与“真正的对象”不同的位置时，代理可能会很有帮助，特别是当您希望轻松地从不使用额外的操作更改为使用额外的操作时，反之亦然。</p>
<p>案例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">somethingElse</span><span class="params">(String arg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealObject</span> <span class="keyword">implements</span> <span class="title">Interface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        print(<span class="string">"doSomething"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">somethingElse</span><span class="params">(String arg)</span> </span>&#123;</span><br><span class="line">        print(<span class="string">"somethingElse "</span> + arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleProxy</span> <span class="keyword">implements</span> <span class="title">Interface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Interface proxied;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleProxy</span><span class="params">(Interface proxied)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.proxied = proxied;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        print(<span class="string">"SimpleProxy doSomething"</span>);</span><br><span class="line">        proxied.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">somethingElse</span><span class="params">(String arg)</span> </span>&#123;</span><br><span class="line">        print(<span class="string">"SimpleProxy somethingElse "</span> + arg);</span><br><span class="line">        proxied.somethingElse(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleProxyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">(Interface iface)</span> </span>&#123;</span><br><span class="line">        iface.doSomething();</span><br><span class="line">        iface.somethingElse(<span class="string">"bonobo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        consumer(<span class="keyword">new</span> RealObject());</span><br><span class="line">        consumer(<span class="keyword">new</span> SimpleProxy(<span class="keyword">new</span> RealObject()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">doSomething</span></span><br><span class="line"><span class="comment">somethingElse bonobo</span></span><br><span class="line"><span class="comment">SimpleProxy doSomething</span></span><br><span class="line"><span class="comment">doSomething</span></span><br><span class="line"><span class="comment">SimpleProxy somethingElse bonobo</span></span><br><span class="line"><span class="comment">somethingElse bonobo</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure></p>
<p>上面的代理方法稍微还有点缺陷，那就是需要每次都需要人为的去创建一个代理类，其实我们关注的只是代理了哪些操作，对于代理类的名字并不是那么的重要。<br>因此JAVA更进一步的完善了代理，使用反射的技术，实现了动态代理。</p>
<p><strong>如何实现了动态代理？</strong><br>JAVA使用了Proxy类来实现动态代理的功能，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;   </span><br><span class="line">  <span class="keyword">private</span> Object proxied;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxyHandler</span><span class="params">(Object proxied)</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">this</span>.proxied = proxied;   </span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;     </span><br><span class="line">    System.out.println(<span class="string">"**** proxy: "</span> + proxy.getClass() + <span class="string">", method: "</span> + method + <span class="string">", args: "</span> + args);     </span><br><span class="line">    <span class="keyword">if</span>(args != <span class="keyword">null</span>)       </span><br><span class="line">    <span class="keyword">for</span>(Object arg : args)         </span><br><span class="line">    System.out.println(<span class="string">"  "</span> + arg);    </span><br><span class="line">    <span class="keyword">return</span> method.invoke(proxied, args);   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;      </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleDynamicProxy</span> </span>&#123;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">(Interface iface)</span> </span>&#123;     </span><br><span class="line">    iface.doSomething();     </span><br><span class="line">    iface.somethingElse(<span class="string">"bonobo"</span>);   </span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     </span><br><span class="line">    RealObject real = <span class="keyword">new</span> RealObject();     </span><br><span class="line">    consumer(real);     </span><br><span class="line">    <span class="comment">// Insert a proxy and call again:     </span></span><br><span class="line">    Interface proxy = (Interface)Proxy.newProxyInstance(       </span><br><span class="line">    Interface.class.getClassLoader(),       </span><br><span class="line">    <span class="keyword">new</span> Class[]&#123; Interface.class &#125;,       </span><br><span class="line">    <span class="keyword">new</span> DynamicProxyHandler(real));     </span><br><span class="line">    consumer(proxy);   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Proxy中的静态方法newProxyInstance(类加载器，代理的接口，代理的逻辑处理类)可以用来生成代理类：</p>
<ol>
<li>类加载器：作用暂时未知，以后讨论。</li>
<li>代理的接口：一个Class数组。</li>
<li>代理的逻辑处理类，实现了InvocationHandler接口，需要提供一个带参数构造器，把真正的对象传递进去，还需要实现里面的invoke(Object proxy, Method method, Object[] args)方法，再在调用反射方法method.invoke(proxied, args)前后我们可以添加需要代理的操作。<blockquote>
<p>这里有个误区，就是构造器传进去的对象就是被代理的对象，注意到被代理的对象是method.invoke()中的proxied参数表示的对象，在这之间通过构造器穿进去的对象依然可以改变。</p>
</blockquote>
</li>
</ol>
<h2 id="空对象"><a href="#空对象" class="headerlink" title="空对象"></a>空对象</h2><p>null在程序中很容易引起问题，因此最好给一个类创建一个表示“空”的空对象，空对象实现了空接口。如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Null</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;   </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> String first;   </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> String last;   </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> String address;   </span><br><span class="line">  <span class="comment">// etc.   </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String first, String last, String address)</span></span>&#123;     </span><br><span class="line">    <span class="keyword">this</span>.first = first;     </span><br><span class="line">    <span class="keyword">this</span>.last = last;     </span><br><span class="line">    <span class="keyword">this</span>.address = address;   </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Person: "</span> + first + <span class="string">" "</span> + last + <span class="string">" "</span> + address;   </span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NullPerson</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Null</span> </span>&#123;     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NullPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(<span class="string">"None"</span>, <span class="string">"None"</span>, <span class="string">"None"</span>);</span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"NullPerson"</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Person NULL = <span class="keyword">new</span> NullPerson(); &#125;</span><br></pre></td></tr></table></figure></p>
<p>空对象的判断和null的判断没什么区别，只是在使用对象中的方法或者字段的时候，可以避免出现空指针异常。</p>
<h2 id="接口与类型信息"><a href="#接口与类型信息" class="headerlink" title="接口与类型信息"></a>接口与类型信息</h2><p><strong>通过RTII，绕过接口会增加耦合：</strong></p>
<p>之前说了使用接口可以实现完全解耦，因为接口相当于一个安全机制，不会涉及到真正的类的信息，也就无法在代码中使用真正对象的其他方法，无法做关系到某个具体对象的硬编码。<br>但事实真的是这样的吗？其实，<br>只要我们在代码中看到这个接口具体的类是什么，我们就可以使用instanceOf结合转型转变成真正的类型。<br>这样接口解耦就毫无意义了。</p>
<p><strong>如何防止这种情况？</strong></p>
<p>我们可能会想，如果防止转型的发生就可以杜绝这种操作了。</p>
<p><strong>如何防止转型的发生呢？</strong></p>
<p>把真正的类信息设置成包类型的，这样可以杜绝转型的发生。</p>
<p><strong>这样真的解决问题了吗？</strong></p>
<p>通过设置访问权限我可以无法访问到真正的类型，但是只要我能知道你的字段，方法名称是什么，我还是能使用反射来调用。</p>
<p>我们可能回想，<strong>能不能不让他看到我们类型的字段，方法名字了？</strong></p>
<p>比如只发布编译后的代码，其实也没用，因为通过反编译，我还是能知道原来的类型信息。<br>实际上<em>使用反射，没有任何类信息可以隐藏起来</em>。</p>
<p>如果执意使用反射，也就意味着没办法解耦了，那么也就得承受这种结果。<br>存在即合理，反射提供了一种后门，没准就能在某个时候解决特定的问题。</p>
]]></content>
      <categories>
        <category>Thinking in Java 读书笔记</category>
      </categories>
      <tags>
        <tag>JAVA编程思想</tag>
        <tag>Thinking in JAVA</tag>
        <tag>类型信息</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>12 异常</title>
    <url>/2018/10/25/THING%20IN%20JAVA/12%20%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>为什么需要异常机制？</strong></p>
<p>可以集中处理处理程序中出现的错误。<br>使程序员把精力花在要解决的问题上。<br>成功的情况只有一种，错误的情况是无限的（未知的才是最可怕的）。</p>
<p><strong>和约定返回一个错误码相比，有什么有优势？</strong></p>
<ol>
<li>可以用更优美的方式处理。</li>
<li>对于错误信息，我可以直接抛出，没有必要“先判断错误类型，然后返回该错误信息”（如C），因为我函数的返回类型有可能是有意义的，这样可以在外层统一处理所有被抛出的异常。</li>
<li>对于检查异常，会强迫程序员去处理，这样减缓了程序员的马虎不小心。</li>
<li>对于非检查异常，即便在运行时期发生了，未处理的程序员也可以通过异常信息很好的定位错误的位置。</li>
</ol>
<h2 id="基本异常"><a href="#基本异常" class="headerlink" title="基本异常"></a>基本异常</h2><ol>
<li>普通问题：在当前方法内可以处理异常。</li>
<li>异常情形：必须要抛出的情况。</li>
</ol>
<p>标准异常的构造器：</p>
<ol>
<li>默认构造器</li>
<li>接受字符串为参数的构造器</li>
</ol>
<p><strong>如何抛出异常？</strong></p>
<p>使用throws+异常抛出<br>在方法后面加throws是声明这个方法可能会抛出<br>实际上抛出不抛出由这个方法的实现而定</p>
<p><strong>抛出异常和方法返回的相似之处：</strong></p>
<p>他们都会从当前方法跳出，仅此而已。至于跳出后的落点，完全不一样。（异常在异常处理程序中落脚）</p>
<h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p>当前方法抛出了异常如果不处理，那么需要在方法后当前方法加throws是声明这个方法继续抛出，当前方法结束并且跳出，那么总要在某个地方处理被抛出的异常，否则就会一直跳出，知道终止程序。</p>
<p><strong>如果不希望终止程序，如何处理</strong></p>
<p>像C一样在源代码的后面放上一堆判断错误类型的代码并处理吗？不需要<br>在try{}里编写的代码会捕获异常，然后结合异常处理程序catch{}来处理异常。</p>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>实现Exception即可。</p>
<p><strong>如何打印异常信息？</strong><br>Throwable中有printStackTrace()方法，打印<em>从方法调用处到异常抛出处</em>的方法调用序列<br>Exception实现了Throwable<br>默认printStackTrace()是将信息输出到System.err中<br>使用printStackTrace(System.out)可以把异常序列输出到控制台。</p>
<h2 id="捕获所有异常"><a href="#捕获所有异常" class="headerlink" title="捕获所有异常"></a>捕获所有异常</h2><p><strong>什么是轨迹栈？</strong></p>
<p>轨迹栈可以理解为异常在被捕获打印出来的时候都经历了哪些方法，并且按照从里到外的顺序记录着（实际上就是方法栈的顺序）。</p>
<p><strong>如果我在捕获之后重新抛出，轨迹先改变了吗？</strong></p>
<p>我的理解是，这个异常对象没有改变重新被抛出，它记录的轨迹栈就没有变化，</p>
<p><strong>轨迹线没有变化如何理解？</strong></p>
<p>看案例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rethrowing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"originating the exception in f()"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"thrown from f()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Inside g(),e.printStackTrace()"</span>);</span><br><span class="line">            e.printStackTrace(System.out);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            g();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main: printStackTrace()"</span>);</span><br><span class="line">            e.printStackTrace(System.out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">originating the exception in f()</span></span><br><span class="line"><span class="comment">Inside g(),e.printStackTrace()</span></span><br><span class="line"><span class="comment">java.lang.Exception: thrown from f()         </span></span><br><span class="line"><span class="comment">    at Rethrowing.f(Rethrowing.java:7)         </span></span><br><span class="line"><span class="comment">    at Rethrowing.g(Rethrowing.java:11)         </span></span><br><span class="line"><span class="comment">    at Rethrowing.main(Rethrowing.java:29)</span></span><br><span class="line"><span class="comment">main: printStackTrace()</span></span><br><span class="line"><span class="comment">java.lang.Exception: thrown from f()         </span></span><br><span class="line"><span class="comment">    at Rethrowing.f(Rethrowing.java:7)         </span></span><br><span class="line"><span class="comment">    at Rethrowing.g(Rethrowing.java:11)         </span></span><br><span class="line"><span class="comment">    at Rethrowing.main(Rethrowing.java:29)</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，两个地方打印出来的异常轨迹线都是一样的。</p>
<p><strong>为什么？</strong></p>
<p>我的理解是：<br>我们知道有方法栈这么一个概念，<br>最开始main()入栈，<br>在main()中调用g()，g()入栈，<br>g()中调用f()，f()入栈<br>f()中抛出异常，该异常的轨迹栈就是当前的方法栈。</p>
<p><strong>如何修改轨迹栈？</strong></p>
<p>使用e.fillInStackTrace()方法，它的作用是重写<em>把当前的方法栈写入到原异常的轨迹栈中。</em><br>如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rethrowing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"originating the exception in f()"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"thrown from f()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Inside h(),e.printStackTrace()"</span>);</span><br><span class="line">            e.printStackTrace(System.out);</span><br><span class="line">            <span class="keyword">throw</span> (Exception) e.fillInStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            h();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main: printStackTrace()"</span>);</span><br><span class="line">            e.printStackTrace(System.out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">originating the exception in f()</span></span><br><span class="line"><span class="comment">Inside h(),e.printStackTrace()</span></span><br><span class="line"><span class="comment">java.lang.Exception: thrown from f()         </span></span><br><span class="line"><span class="comment">    at Rethrowing.f(Rethrowing.java:7)         </span></span><br><span class="line"><span class="comment">    at Rethrowing.h(Rethrowing.java:20)         </span></span><br><span class="line"><span class="comment">    at Rethrowing.main(Rethrowing.java:35)</span></span><br><span class="line"><span class="comment">main: printStackTrace()</span></span><br><span class="line"><span class="comment">java.lang.Exception: thrown from f()         </span></span><br><span class="line"><span class="comment">    at Rethrowing.h(Rethrowing.java:24)         </span></span><br><span class="line"><span class="comment">    at Rethrowing.main(Rethrowing.java:35)</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure></p>
<p>使用e.fillInStackTrace()方法和抛出一个新的异常结果是一样的。</p>
<p><strong>如何在打印一个异常的同时把它之前出现的异常信息也同时打印出来呢？</strong></p>
<p>使用<em>异常链</em><br>Error,Exception,RuntimeException可以使用构造器传入一个异常，构成异常链。<br>其它异常要使用initCause(e)来构成异常链。</p>
<h2 id="标准JAVA异常"><a href="#标准JAVA异常" class="headerlink" title="标准JAVA异常"></a>标准JAVA异常</h2><p><strong>异常的分类：</strong></p>
<p>Error:属于系统错误<br>Exception:属于编程错误</p>
<p><strong>所有的Exception都需要手动抛出吗？</strong></p>
<p>目前看来，所有的异常在被抛出后有两种解决方案：</p>
<ol>
<li>try-catch 捕获处理</li>
<li>继续抛出</li>
</ol>
<p>如果是这样，每一个对象在使用前都要处理“为NULL的异常”,或者继续抛出异常，但在代码里总需要有处理的地方，这还是会十分麻烦。<br>因此RuntimeException类型的异常JAVA会帮我们自动判断并抛出。</p>
<p><strong>JAVA帮我们抛出的异常如果没有处理会怎样？</strong></p>
<p>会一直抵达main()方法并抛出<br>最后JAVA发现是这个类型的异常后会在退出程序前调用printStachTrace（）方法。</p>
<p>也就是说运行时异常可以不用在代码中声明抛出和写处理程序，而检查异常这两个都是必有的。</p>
<h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p><strong>对于一些代码，无论try中的异常是否抛出，我们都希望在最后执行，怎么处理？</strong></p>
<p>使用finally{}<br>对于没有垃圾回收机制的语言来说，这种情况一般是处理内存的回收。<br>对于JAVA而言，用来清理除了内存之外的资源，譬如文件，网络连接，开关等等。</p>
<h2 id="异常的限制"><a href="#异常的限制" class="headerlink" title="异常的限制"></a>异常的限制</h2><p>重写方法时，只能抛出在该方法的基类版本中指定的异常。</p>
<p><strong>为啥？</strong><br>更好的支持多态。</p>
<h2 id="构造器和异常"><a href="#构造器和异常" class="headerlink" title="构造器和异常"></a>构造器和异常</h2><p>我们之前说过，在finally中的处理是执行完异常代码后，清理除内存之外的资源，但是有一个问题是：<br><strong>这些资源会被正确的清理吗？</strong></p>
<p>怎么理解这句话，这么一个情况，如果资源还没有被打开？需要被清理吗？不需要清理反而清理了，是不是就有问题了？</p>
<p><strong>什么时候资源不会被打开呢？</strong></p>
<p>在构造器方法里抛出了异常，这时候资源对象还未被创建。</p>
<p><strong>如何处理最安全？</strong></p>
<p>如果是单独捕获构造器抛出的异常并处理，也不是非常安全，因为有可能其它语句也会抛出这个异常，这时候就无法区分。<br>最好的解决办法是，使用嵌套try-finally</p>
<p><strong>为什么要使用嵌套？</strong></p>
<p>try和finally是绑定的，对于构造器的finally，我们希望区别开来：<br>在创建需要清理的对象之后，立即进入一个try-finally的语句。<br>这样如果创建对象失败了，<em>后面的的语句也就不会执行了。</em><br>这也是使用嵌套而不写分开写成多个try-finally的原因。</p>
<p>无论构造器会不会抛出异常都可以这样使用：<br>基本规则是：在创建需要清理的对象之后，立即进入一个try-finally的语句。</p>
<h2 id="检查异常"><a href="#检查异常" class="headerlink" title="检查异常"></a>检查异常</h2><p><strong>C如何处理错误？</strong></p>
<p>判断错误的类型并使用代码处理<br>程序员往往忽略这些错误的处理，之后出现问题的时候再调试找出问题。</p>
<p><strong>C++如何处理错误？</strong></p>
<p>C++有异常声明，表明当前方法有异常被抛出，至于处不处理是程序员的事。<br>有兴趣的再去更深入的了解</p>
<p><strong>被检查异常会有什么问题吗？</strong></p>
<p>强迫程序员必须要某个地方解决这个异常，但有时候这个异常的产生是由底层的代码抛出的，没有足够的条件去处理，这时候为了使程序继续运行，往往假装解决了，这时候异常就消失不见了，潜在的危急十分恐怖。<br>“吞食即伤害”<br>成功的情况往往只有一种，错误的情况是无限的（未知的才是最可怕的）。</p>
<p><strong>类型检查的弊端？</strong></p>
<p>java是一种静态类型语言，意味着在编译时期会对类型做检查，这虽然减少了很多错误的出现，但也一定程序上限制了程序员编码的自由，因此后面设计的泛型和反射都是弥补这种缺失的自由的。</p>
<p><strong>被检查异常无法时处理的时候怎么办？</strong></p>
<ol>
<li>在main()后抛出被检查的异常，异常信息会被打印到控制台中，作后续处理。</li>
<li>将被检查异常转为非检查异常，使用异常链记录之前的被检查的异常，在必要的时候使用getCause()重新抛出这些异常。</li>
</ol>
]]></content>
      <categories>
        <category>Thinking in Java 读书笔记</category>
      </categories>
      <tags>
        <tag>JAVA编程思想</tag>
        <tag>Thinking in JAVA</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络自顶向下：第一章-概论</title>
    <url>/2018/05/30/cmpNet/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%EF%BC%9A%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="1-什么是网络"><a href="#1-什么是网络" class="headerlink" title="1 什么是网络"></a>1 什么是网络</h1><h2 id="1-1-硬件和软件组成了计算机网络"><a href="#1-1-硬件和软件组成了计算机网络" class="headerlink" title="1.1 硬件和软件组成了计算机网络"></a>1.1 硬件和软件组成了计算机网络</h2><p><img src="/2018/05/30/cmpNet/计算机网络自顶向下：第一章-概论/计算机网络组成.png" alt="计算机网络组成"></p>
<p>终端系统用网络上的<strong>通信链路</strong>和<strong>分组交换器</strong>连接在一起</p>
<ul>
<li>通信链路：由不同类型的物理媒介构成，包括同轴电缆，铜线，光纤和无线电频谱。不同的链路能以不同的速率传递数据，单位是bit/s。这里链路并不是指一个具体的物理路线，而是一个抽象的含义。</li>
<li><p>分组交换器：将由输入通信链路中获取的分组转发到输出通信链路中,主要有两种：路由器和链路层交换器。链路层交换器一般用来访问网络，路由器一般用来组成网络核心（网络分为网络核心和网络边缘两个部分）。</p>
</li>
<li><p>终端系统通过 <strong>互联网服务供应商(ISP)</strong> 来访问互联网，IPS就是和一些在不同场合提供访问互联网方法的一些机构，譬如电信公司。</p>
</li>
<li><p>协议：控制终端系统，分组交换器或者其他互联网部分接受和发送信息。其中TCP和IP是两个主要协议：IP协议指定在路由器和终端系统之间发送和接收的数据包的格式。互联网的主要协议统称为TCP/IP。</p>
</li>
</ul>
<h2 id="1-2-作为服务分布式应用的基础设施"><a href="#1-2-作为服务分布式应用的基础设施" class="headerlink" title="1.2 作为服务分布式应用的基础设施"></a>1.2 作为服务分布式应用的基础设施</h2><p>我们也可以从一个完全不同的角度来描述网络，即作为向应用程序提供服务的基础架构。这些应用程序包括电子邮件，网上冲浪，社交网络，即时消息，IP语音（VoIP），视频流，分布式游戏，P2P文件共享，互联网电视，远程登录等等。<br>首先我们需要在终端上编写我们的应用程序，我们可以使用JAVA,C或者Python等语言，接着我们需要通过API来接入互联网。</p>
<ul>
<li>API：互联网API是发送程序必须遵循的一组规则，以便互联网可以将数据传送到目标程序。</li>
</ul>
<h2 id="1-3-什么是协议"><a href="#1-3-什么是协议" class="headerlink" title="1.3 什么是协议"></a>1.3 什么是协议</h2><p>用人类协议来类比，通常我们用“HI”来表示我们想要和别人交流，如果别人回复“HI”则表示愿意交流，若回复 “Don’t bother me!” or “I don’t speak English”则没有继续交流的必要了。</p>
<p><img src="/2018/05/30/cmpNet/计算机网络自顶向下：第一章-概论/协议.png" alt="计算机网络组成"></p>
<ul>
<li>协议：协议定义了两个或多个通信实体之间交换消息的格式和顺序，以及在传输和/或接收消息或其他事件时采取的行动。</li>
</ul>
<h1 id="2-网络边缘"><a href="#2-网络边缘" class="headerlink" title="2 网络边缘"></a>2 网络边缘</h1><p><img src="/2018/05/30/cmpNet/计算机网络自顶向下：第一章-概论/终端系统交互.png" alt="计算机网络组成"></p>
<p>如上图，电脑和其他网络设备被称为终端系统，因为他们处于网络的边缘部分。通常我们把主机也叫做终端系统，主机分为客户端和服务器。</p>
<ul>
<li>客户端：桌面，移动电脑，手机等等。</li>
<li>服务器：功能比较强大的机器。</li>
</ul>
<h2 id="2-1-网络接入"><a href="#2-1-网络接入" class="headerlink" title="2.1 网络接入"></a>2.1 网络接入</h2><p><img src="/2018/05/30/cmpNet/计算机网络自顶向下：第一章-概论/访问网络.png" alt="计算机网络组成"></p>
<p>如图：分为三种访问类型：家庭网络接入，企业网络接入，移动网络接入。</p>
<h3 id="2-1-2-家庭网络接入：DSL，Cable，FTTH，Dial-Up，and-Satellite"><a href="#2-1-2-家庭网络接入：DSL，Cable，FTTH，Dial-Up，and-Satellite" class="headerlink" title="2.1.2 家庭网络接入：DSL，Cable，FTTH，Dial-Up，and Satellite"></a>2.1.2 家庭网络接入：DSL，Cable，FTTH，Dial-Up，and Satellite</h3><p>如今，最主要的两种带宽住宅接入方式是DSL和Cable。</p>
<ol>
<li><p>通过数字用户线接入（DSL）：和电信公司提供的本地电话接入方式一致，共用已经存在的电话线。此时，电信公司同时也作为ISP。</p>
<p><img src="/2018/05/30/cmpNet/计算机网络自顶向下：第一章-概论/DSL网络接入方式.png" alt="计算机网络组成"></p>
<ul>
<li>DSL调制解调器：获取数字数据并将它转换成高频音（模拟信号）通过电话线路传输到电信公司中心办公室。</li>
<li>DSL接入复用器（DSLAM）：将模拟信号转换回数字信号。</li>
</ul>
<p>电话线中有3中不同的频率，以区别网络数据和电话信号：</p>
<ol>
<li>高速下载通道：50kHz-11MH</li>
<li>中速上传通道：4kHz-50kHz</li>
<li>普通双向电话通话：0-4kHz</li>
</ol>
</li>
<li><p>Cable：使用了有限电视公式已经存在的有限电视基础设施。</p>
<p><img src="/2018/05/30/cmpNet/计算机网络自顶向下：第一章-概论/HFC网络接入方式.png" alt="计算机网络组成"></p>
<ul>
<li>有线调制解调器：和DSL调制解调器作用一样，是一个外部设备，通过以太网接口端口连接PC。</li>
<li>有线调制解调器终端系统（CMTS）:和DSLAM作用一样。</li>
</ul>
<p>上面两种方式占90%，之外还有一种速度更快的接入方式。FTTH（fiber to the home）</p>
</li>
<li><p>FTTP(fiber to the home)</p>
<p>直接提供一个光纤路线从中心办公室连到家。<br>对于从CO到家的光纤分布，有几种不同的竞争技术，其中最简单的光分布网络是直纤，一条光纤从CO到一个家庭。然而，更普遍的是CO的每一条光纤都由多个家庭共享，直到离家庭足够近，才会被分割为各个家庭特别的光纤。有两种竞争的光分配网络体系结构执行这种分割：有源光网络（AONs）和无源光网络（PONs）。有源光网络本质上是交换的以太网，将在第五章讨论。接下来简单的讨论PONs。如下图：</p>
<p><img src="/2018/05/30/cmpNet/计算机网络自顶向下：第一章-概论/FTTP-PONs.png" alt="计算机网络组成"></p>
<p>每个家庭都有一个光纤网络终端（ONT），它通过专用光纤连接到一个邻居分离器。该分路器将多个家庭（通常少于100个）组合到单个共享光纤上，该光纤连接到电信公司的CO中的光线路终端器（OLT）。OLT提供光信号和电信号之间的转换，连接到通过电信路由器上网。</p>
</li>
</ol>
<h3 id="2-1-3-企业网络接入（家庭也有）：以太网和WIFI"><a href="#2-1-3-企业网络接入（家庭也有）：以太网和WIFI" class="headerlink" title="2.1.3 企业网络接入（家庭也有）：以太网和WIFI"></a>2.1.3 企业网络接入（家庭也有）：以太网和WIFI</h3><ol>
<li>以太网接入</li>
</ol>
<p>将在第五章具体讨论。</p>
<p><img src="/2018/05/30/cmpNet/计算机网络自顶向下：第一章-概论/以太网络接入.png" alt="计算机网络组成"></p>
<ol start="2">
<li>WIFI</li>
</ol>
<p>基于IEEE 802.11技术的无线局域网接入，通俗地称为WiFi，现在几乎遍布各处 - 大学，商务办公室，咖啡馆，机场，甚至飞机。</p>
<p>将在第六章具体讨论。</p>
<h3 id="2-1-3-广域无线接入：3G和LTE"><a href="#2-1-3-广域无线接入：3G和LTE" class="headerlink" title="2.1.3 广域无线接入：3G和LTE"></a>2.1.3 广域无线接入：3G和LTE</h3><p>将在第六章具体讨论。</p>
<h1 id="3-网络核心"><a href="#3-网络核心" class="headerlink" title="3 网络核心"></a>3 网络核心</h1><p>互联网终端系统的分组交换和链路网格</p>
<p><img src="/2018/05/30/cmpNet/计算机网络自顶向下：第一章-概论/网络核心.png" alt="计算机网络组成"></p>
<h2 id="3-1-分组交换"><a href="#3-1-分组交换" class="headerlink" title="3.1 分组交换"></a>3.1 分组交换</h2><p><img src="/2018/05/30/cmpNet/计算机网络自顶向下：第一章-概论/分组交换.png" alt="计算机网络组成"></p>
<ul>
<li>分组：源将长消息分解成已知的更小的数据块。</li>
<li>通信链路：由不同类型的物理媒介构成，包括同轴电缆，铜线，光纤和无线电频谱。不同的链路能以不同的速率传递数据，单位是bit/s。</li>
<li>分组交换器：将由输入通信链路中获取的分组转发到输出通信链路中,主要有两种：路由器和链路层交换器。链路层交换器一般用来访问网络，路由器一般用来组成网络核心（网络分为网络核心和网络边缘两个部分）。</li>
</ul>
<h3 id="3-1-1-存储转发传输"><a href="#3-1-1-存储转发传输" class="headerlink" title="3.1.1 存储转发传输"></a>3.1.1 存储转发传输</h3><p><img src="/2018/05/30/cmpNet/计算机网络自顶向下：第一章-概论/存储转发传输.png" alt="计算机网络组成"></p>
<p>每个分组交换器都采用了存储——转发的方式。<br>分组交换器必须接收整个分组，才能开始将分组的第一个比特发送到出站链路。因此，第一个比特到了分组交换器后必须等待其他所有的分组比特到来才能继续发送到下一个分组交换器中，所以在这个过程中就有存储——转发时延，也叫发送时延。</p>
<h3 id="3-1-2-排队时延和数据包丢失"><a href="#3-1-2-排队时延和数据包丢失" class="headerlink" title="3.1.2 排队时延和数据包丢失"></a>3.1.2 排队时延和数据包丢失</h3><p>每个分组交换器都有很多个相连的链路，每个链路都有一个输出缓存，来决定下一个将被发送的分组。因此除了存储——转发时延之外还有排队时延。排队时延依赖于网络的拥堵状态。<br>由于缓冲区空间的数量是有限的，到达的数据包可能会发现缓冲区已满，其他数据包正在等待传输。在这种情况下，会发生数据包丢失 - 到达的数据包或其中一个已排队的数据包将被丢弃。</p>
<h2 id="3-1-3-转发表和路由协议"><a href="#3-1-3-转发表和路由协议" class="headerlink" title="3.1.3 转发表和路由协议"></a>3.1.3 转发表和路由协议</h2><p>每一个终端系统都有一个地址叫IP地址。当源端系统想要将数据包发送到目标端系统时，源包括数据包报头中的目标IP地址。与邮政地址一样，该地址具有分层结构。当数据包到达网络中的路由器时，路由器检查数据包的目标地址的一部分，并将数据包转发给相邻的路由器。更具体地说，每个路由器都有一个转发表，用于将目标地址（或部分目标地址）映射到该路由器的出站链路。那么这个转发表是如何来的呢？<br>网络中有许多特殊的路由协议，用于自动设置转发表。比如，一个路由协议可能采用最短路算法来生成转发表。</p>
<h2 id="3-2-电路交换"><a href="#3-2-电路交换" class="headerlink" title="3.2 电路交换"></a>3.2 电路交换</h2><p>在电路交换网络中，为端系统之间的通信时提供的沿路径所需的资源（缓冲器，链路传输速率）被保留用于终端系统之间的通信会话期间。在分组交换网络中，这些资源不被保留; 会话的消息按需使用资源，因此可能不得不等待（即队列）访问通信链接。<br>作为一个简单的比喻，考虑两家餐厅，一家需要预订，另一家既不需要预订也不需要接受预订。对于需要预订的餐厅，我们必须在离开家之前经历呼叫的麻烦。但是，当我们到达餐厅时，我们原则上可以立即坐下来点餐。对于不需要预订的餐厅，我们无需费心预订餐桌。但是，当我们到达餐厅时，我们可能不得不等待桌子才能坐下。<br>电路交换中，在发送端能发送消息前，会在发送端和接收端中先建立一个连接，确认连接路线中哪些交换器会保持连接状态。同时，也会保持一个固定的链路传输速率（代表了一个链路传输容量的分数）。<br>之前我们说的电话网络就是采用的电路交换的方式。</p>
<p><img src="/2018/05/30/cmpNet/计算机网络自顶向下：第一章-概论/电路交换.png" alt="计算机网络组成"></p>
<p>如上图，有3台主机通过4个分组交换器和4个链路连接，每个链路有4个电路。当终端A要与终端B进行通讯时，网络先在两台主机之间建立一个连接，首先确认需要通过的分组交换器，然后确定选择连接的链路中的哪条电路，如第一条链路中选择了第二条电路，第二条链路中选择了第四条电路。此时整个电路交换连接的速率将会是总链路速率的四分之一。</p>
<h3 id="3-2-1-电路交换中的复用"><a href="#3-2-1-电路交换中的复用" class="headerlink" title="3.2.1 电路交换中的复用"></a>3.2.1 电路交换中的复用</h3><p><img src="/2018/05/30/cmpNet/计算机网络自顶向下：第一章-概论/FDM和TDM.png" alt="计算机网络组成"></p>
<p>链路中的电路采用频分复用（FDM）或者时分复用（TDM）来实施。</p>
<ul>
<li>FDM：链路频率范围在链路上建立的连接之间进行划分。</li>
<li>TDM：被分成固定持续时间的帧，并且每个帧被分成固定数量的时隙。</li>
</ul>
<h3 id="3-2-2-电路交换和分组交换的比较"><a href="#3-2-2-电路交换和分组交换的比较" class="headerlink" title="3.2.2 电路交换和分组交换的比较"></a>3.2.2 电路交换和分组交换的比较</h3><p>相比电路交换，分组交换不适合实时服务，比如打电话，视频通话，因为可能存在的时延（主要是排队时延）。而优点是：</p>
<ol>
<li>提供更好的共享传输容量。</li>
<li>更简单，更高效，实施成本更低。</li>
</ol>
<h1 id="4-时延"><a href="#4-时延" class="headerlink" title="4 时延"></a>4 时延</h1><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p><img src="/2018/05/30/cmpNet/计算机网络自顶向下：第一章-概论/1-1.png" alt="时延"></p>
<p>如上图：<br>延迟中最主要的是节点处理延迟、排队延迟、传输延迟（transmission ）和传播延迟（propagation ），这些延迟一起累积，从而给出总节点延迟。</p>
<ul>
<li>处理延时：检查表头，指导包的链路转发，字节级别错误检查等都属于节点处理延时，在网络中，这部分延时是微秒级别的。</li>
<li>排队延时，期望找到一个关于运输类型和强度的函数，微妙到毫秒级别。</li>
<li>传输延时，一个包的长度除以链路传输速率，微妙到毫秒级别。</li>
<li>传播延时，字节在链路传播的时间，取决链路的媒介（光纤或者双胶铜线，基本等于光速），毫秒级别。</li>
</ul>
<p>传输延时好比在高速公路上的中转站的耗时，传播延时好比在高速公路上的耗时。这部分总延时=传输延时+传播延时。<br>如果传输延时比传播延时高，那么就会出现，分组中的第一个字节已经到达下一个路由，而最后一个字节还没有从当前路由发出。</p>
<p>传播延时在总延时中占主要部分，传输延时根据链路的传输速率而变化，而处理延时微不足道。</p>
<p>最复杂的是排队延时，每个分组的排队延时都不一致（就和每个排队的人等待的时间都不一样），因此有以下的一些描述：平均延时，延时方差，延时高于某值的概率。<br>排队延时由分组到达队列的速率，链路传输速率和分组到达的方法（是周期性，还是突然增长）而决定。<br>周期性的情况下，到达速率和传输速率的比值称为流量强度(traffic intensity),这个量具有测量的含义。</p>
<ul>
<li>流量强度&gt;1，队列就会持续增加，排队延时会持续增加。</li>
<li>流量强度&lt;=1，分组周期性的到达不会有排队延时，但是如果很多分组同一时间一同到达的时候，依然会有分组问题。</li>
</ul>
<p>上述只是理想情况，实际上具有很强的随机性，因此交通强度就不会有很准确的意义，但是还是可以用来作大致的判断，当趋于0，排队时延趋于0，当趋于1，排队队列趋于无穷。<br><img src="/2018/05/30/cmpNet/计算机网络自顶向下：第一章-概论/1-2.png" alt="平均时延/交通强度"></p>
<h2 id="丢包"><a href="#丢包" class="headerlink" title="丢包"></a>丢包</h2><p>当分组队列达到容量时就会发生丢掉，防止丢包就需要重新发包。对包进行跟踪可以看到包的进度。<br>Traceroute 会记录两个终端之间每个路由的名字，IP，和每个路由会发送3次，因此还会记录3次时延。<br><img src="/2018/05/30/cmpNet/计算机网络自顶向下：第一章-概论/1-3.png" alt="Traceroute"></p>
<blockquote>
<p>注意，会出现第N个路由的时延大于第N+1个路由时延的情况。</p>
</blockquote>
<h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>吞吐量就是路由间的链路的最小的那一个传输速率。<br>一个文件从主机A传到主机B，主机B接收到的字节瞬时速率称为瞬时吞吐量，整个文件大小除以耗时成为平均吞吐量。<br>在文件传输的系统中，时延并不如吞吐量关键，</p>
<h2 id="网络层的传输"><a href="#网络层的传输" class="headerlink" title="网络层的传输"></a>网络层的传输</h2><p><img src="/2018/05/30/cmpNet/计算机网络自顶向下：第一章-概论/1-4.png" alt="网络层传输"></p>
<h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><ul>
<li>病毒：交互式的恶意软件，可自我复制。</li>
<li>蠕虫：非交互式的恶意软件，也可自我复制。</li>
<li>木马：破幻系统安全，提供恶意软件进入的入口。</li>
</ul>
<h3 id="DOS攻击"><a href="#DOS攻击" class="headerlink" title="DOS攻击"></a>DOS攻击</h3><ul>
<li>漏洞攻击：发送可以让服务崩溃的消息。</li>
<li>宽带溢出：发送大量的消息。</li>
<li>连接溢出：建立大量的连接。</li>
</ul>
<p>DDOS：分布式的DOS攻击，比较难防。</p>
<p>包拦截：使用包监听器（packet sniffer）获取网络中的包数据（无线，有线）<br>IP伪装：伪装成正确的IP来获取数据。</p>
]]></content>
      <categories>
        <category>计算机网络自顶向下</category>
      </categories>
      <tags>
        <tag>计算机网络自顶向下</tag>
      </tags>
  </entry>
  <entry>
    <title>06 函数重构</title>
    <url>/2019/01/08/refactoring/06%20%E5%87%BD%E6%95%B0%E9%87%8D%E6%9E%84/</url>
    <content><![CDATA[<h1 id="函数重构"><a href="#函数重构" class="headerlink" title="函数重构"></a>函数重构</h1><h2 id="Extract-Method（提炼方法）"><a href="#Extract-Method（提炼方法）" class="headerlink" title="Extract Method（提炼方法）"></a>Extract Method（提炼方法）</h2><p>problem:有一个可以组合在一起的代码片段。一大串代码，将想要注释的地方提炼成新的方法。<br>solution:将想要注释的地方提炼成新的方法，并且给一个好的命名，这点很重要。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">     printBanner();</span><br><span class="line">     <span class="comment">//print details</span></span><br><span class="line">     System.out.println (<span class="string">"name:"</span> + _name);</span><br><span class="line">     System.out.println (<span class="string">"amount"</span> + amount);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//======================after refactoring=========================</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">     printBanner();</span><br><span class="line">     printDetails(amount);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">printDetails</span> <span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">     System.out.println (<span class="string">"name:"</span> + _name);</span><br><span class="line">     System.out.println (<span class="string">"amount"</span> + amount);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>重构原因？</strong></p>
<ol>
<li>函数的粒度更小，被复用的几率更大。</li>
<li>命名好的函数，可以通过读名字就知道函数的作用，提高阅读效率。</li>
</ol>
<h2 id="Inline-Method（内联方法）"><a href="#Inline-Method（内联方法）" class="headerlink" title="Inline Method（内联方法）"></a>Inline Method（内联方法）</h2><p>problem:当方法体比方法本身更明显时，请使用此技术。<br>solution:在使用临时变量的地方，直接用给这个变量赋值的表达式代替。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRating</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (moreThanFiveLateDeliveries()) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">moreThanFiveLateDeliveries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> _numberOfLateDeliveries &gt; <span class="number">5</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//======================after refactoring=========================</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">getRating</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (_numberOfLateDeliveries &gt; <span class="number">5</span>) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>重构原因？</strong></p>
<p>并不是所有的语句都需要Extract Method，已经足够简单的不需要。</p>
<h2 id="Inline-Temp（内联变量）"><a href="#Inline-Temp（内联变量）" class="headerlink" title="Inline Temp（内联变量）"></a>Inline Temp（内联变量）</h2><p>problem:有一个临时变量，它分配了一个简单表达式的结果，仅此而已。<br>solution:用表达式本身替换对变量的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasDiscount</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> basePrice = order.basePrice();</span><br><span class="line">  <span class="keyword">return</span> basePrice &gt; <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//======================after refactoring=========================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasDiscount</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> order.basePrice() &gt; <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>重构原因？</strong></p>
<ol>
<li>并不是说所有的表达式都需要使用Extract Variable，已经足够简单的不需要。</li>
<li>减少局部变量，从而<em>减少对其他重构的限制</em>。<blockquote>
<p>我的理解是通过调用方法来获取值，解释为查询。Inline Temp不是必须的，它的原因是使用它的前提。</p>
</blockquote>
</li>
</ol>
<h2 id="Replace-Temp-with-Query-以查询代替临时变量"><a href="#Replace-Temp-with-Query-以查询代替临时变量" class="headerlink" title="Replace Temp with Query(以查询代替临时变量)"></a>Replace Temp with Query(以查询代替临时变量)</h2><p>problem:将表达式的结果放在局部变量中，以便以后在代码中使用。<br>solution:将整个表达式移动到单独的方法并从中返回结果。查询方法而不是使用变量。如有必要，将新方法合并到其他方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> basePrice = _quantity * _itemPrice;</span><br><span class="line"><span class="keyword">if</span> (basePrice &gt; <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> basePrice * <span class="number">0.95</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> basePrice * <span class="number">0.98</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//======================after refactoring=========================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (basePrice() &gt; <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> basePrice() * <span class="number">0.95</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> basePrice() * <span class="number">0.98</span>;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">basePrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _quantity * _itemPrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>重构原因？</strong></p>
<ol>
<li>以后变量的赋值逻辑可能会在多个不同方法中使用</li>
<li>如果想要使用Extract Method重构时，减少局部变量的限制，希望临时变量能在原来的方法和新方法中使用，这时候可以使用Replace Temp with Query。</li>
</ol>
<p><strong>变量要求只被赋值一次？</strong></p>
<p>因为如果被赋值多次，那么“提取右侧表达式”时应该选择哪一个呢？<br>这时候就需要采用其他的重构手法来解决了。</p>
<p><strong>代码清晰和性能的抉择？</strong></p>
<p>使用Replace Temp with Query会导致多次调用赋值表达式的逻辑，这会造成性能上的一个损失，但是一般不需要从性能上考虑，真的出现性能问题再反向处理也是十分容易的。</p>
<h2 id="Introduce-Explaining-Variable（引入解释性变量）"><a href="#Introduce-Explaining-Variable（引入解释性变量）" class="headerlink" title="Introduce Explaining Variable（引入解释性变量）"></a>Introduce Explaining Variable（引入解释性变量）</h2><p>problem:有一个很难理解的表达。<br>solution:将表达式或其部分的结果放在不言自明的单独变量中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> ( (platform.toUpperCase().indexOf(<span class="string">"MAC"</span>) &gt; -<span class="number">1</span>) &amp;&amp;</span><br><span class="line">     (browser.toUpperCase().indexOf(<span class="string">"IE"</span>) &gt; -<span class="number">1</span>) &amp;&amp;</span><br><span class="line">      wasInitialized() &amp;&amp; resize &gt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//======================after refactoring=========================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isMacOs     = platform.toUpperCase().indexOf(<span class="string">"MAC"</span>) &gt; -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isIEBrowser = browser.toUpperCase().indexOf(<span class="string">"IE"</span>)  &gt; -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> wasResized  = resize &gt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (isMacOs &amp;&amp; isIEBrowser &amp;&amp; wasInitialized() &amp;&amp; wasResized) &#123;</span><br><span class="line">   <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将一个复杂表达式的结果放进一个临时变量中，给一个好的命名以解释。</p>
<p><strong>重构原因？</strong></p>
<ol>
<li>使用变量名可以给复杂的表达式一个基础的解释，提高代码的可读性。</li>
<li>当使用Extract Method比较麻烦的时候。</li>
</ol>
<h2 id="Split-Temporary-Variable（剖解临时变量）"><a href="#Split-Temporary-Variable（剖解临时变量）" class="headerlink" title="Split Temporary Variable（剖解临时变量）"></a>Split Temporary Variable（剖解临时变量）</h2><p>problem:您有一个局部变量，用于在方法中存储各种中间值（循环变量除外）。<br>solution:对不同的值使用不同的变量。每个变量应该只负责一个特定的事情。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> temp = <span class="number">2</span> * (_height + _width);</span><br><span class="line">System.out.println (temp);</span><br><span class="line">temp = _height * _width;</span><br><span class="line">System.out.println (temp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//======================after refactoring=========================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> perimeter = <span class="number">2</span> * (_height + _width);</span><br><span class="line">System.out.println (perimeter);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> area = _height * _width;</span><br><span class="line">System.out.println (area);</span><br></pre></td></tr></table></figure>
<p><strong>什么是循环变量和结果收集变量？</strong></p>
<p>循环变量：记录循环的周期的变量i<br>结果收集变量：用于累加、字符串接合、写入stream或者向群集（collection）添加元素</p>
<p><strong>重构原因？</strong></p>
<p>不是循环变量和结果收集变量，被赋值多次，承担了多个职责，令代码阅读者糊涂。</p>
<h2 id="Remove-Assignments-to-Parameters（移除对参数的赋值动作）"><a href="#Remove-Assignments-to-Parameters（移除对参数的赋值动作）" class="headerlink" title="Remove Assignments to Parameters（移除对参数的赋值动作）"></a>Remove Assignments to Parameters（移除对参数的赋值动作）</h2><p>不要对参数进行赋值动作，以一个临时变量取代该参数的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">discount</span> <span class="params">(<span class="keyword">int</span> inputVal, <span class="keyword">int</span> quantity, <span class="keyword">int</span> yearToDate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inputVal &gt; <span class="number">50</span>) inputVal -= <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//======================after refactoring=========================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">discount</span> <span class="params">(<span class="keyword">int</span> inputVal, <span class="keyword">int</span> quantity, <span class="keyword">int</span> yearToDate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = inputVal;</span><br><span class="line">    <span class="keyword">if</span> (inputVal &gt; <span class="number">50</span>) result -= <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>重构原因？</strong></p>
<p>降低了代码的清晰度，而且混淆了pass by value（传值〕和pass by reference (传址）这两种参数传递方式。Java只采用pass by value传递方式。<br>在pass by value情况下，对参数的任何修改，都不会对调用端造成任何影响。那些用过pass by reference的人可能会在这一点上犯糊涂。<br>另一个让人糊涂的地方是函数本体内。如果你只以参数表示【被传递进来的东西】，那么代码会清晰得多，因为这种用法在所有语言中都表现出相同语义。</p>
<p><strong>什么是pass by value？</strong></p>
<p>含义是使它引用（参考、指涉、指向）另一个对象。<br>改变对象参数的内容是没有什么问题的。</p>
<h2 id="Replace-Method-with-Method-Object（以函数对象取代函数）"><a href="#Replace-Method-with-Method-Object（以函数对象取代函数）" class="headerlink" title="Replace Method with Method Object（以函数对象取代函数）"></a>Replace Method with Method Object（以函数对象取代函数）</h2><p>problem:你有一个很长的方法，局部变量是如此交织在一起，你不能应用Extract Method。<br>solution:将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的值域（field） 然后你可以在同一个对象中将这个大型函数分解为数个小型函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> primaryBasePrice;</span><br><span class="line">    <span class="keyword">double</span> secondaryBasePrice;</span><br><span class="line">    <span class="keyword">double</span> tertiaryBasePrice;</span><br><span class="line">    <span class="comment">// long computation.</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//======================after refactoring=========================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PriceCalculator(<span class="keyword">this</span>).compute();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriceCalculator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> primaryBasePrice;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> secondaryBasePrice;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> tertiaryBasePrice;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PriceCalculator</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// copy relevant information from order object.</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// long computation.</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/01/08/refactoring/06 函数重构/1.gif" alt=""></p>
<p><strong>为什么需要这么做？</strong></p>
<p>如果一个函数之中局部变量泛滥成灾, 那么想分解这个函数是非常困难的。Replace Temp with Query 可以助你减轻这一负担，但有时候你会发现根本无法拆解一个需要拆解的函数。</p>
<p><strong>如何操作？</strong></p>
<ul>
<li>建立一个新class，根据「待被处理之函数」的用途，为这个class命名。</li>
<li>在新class中建立一个final值域，用以保存原先大型函数所驻对象。我们将这个值域称为extract class「源对象」。同时，针对原（旧）函数的每个临时变量和每个参 数，在新中建立一个个对应的值域保存之。</li>
<li>在新class中建立一个构造函数（constructor），接收源对象及原函数的所有参数作为参数。</li>
<li>在新class中建立一个compute()函数。</li>
<li>将原（旧）函数的代码拷贝到compute()函数中。如果需要调用源对象的任何函数，请以「源对象」值域调用。</li>
<li>编译。</li>
<li>将旧函数的函数本体替换为这样一条语句：「创建上述新的一个新对象， 而后调用其中的compute()函数」。</li>
</ul>
<h2 id="Substitute-Algorithm（替换你的算法）"><a href="#Substitute-Algorithm（替换你的算法）" class="headerlink" title="Substitute Algorithm（替换你的算法）"></a>Substitute Algorithm（替换你的算法）</h2><p>把某个算法替换为另一个更清晰的算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">foundPerson</span><span class="params">(String[] people)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; people.length; i++) &#123;</span><br><span class="line">     <span class="keyword">if</span> (people[i].equals (<span class="string">"Don"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"Don"</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (people[i].equals (<span class="string">"John"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"John"</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (people[i].equals (<span class="string">"Kent"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"Kent"</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//======================after refactoring=========================</span></span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">foundPerson</span><span class="params">(String[] people)</span></span>&#123;</span><br><span class="line">    List candidates = Arrays.asList(<span class="keyword">new</span> String[] &#123;<span class="string">"Don"</span>, <span class="string">"John"</span>, <span class="string">"Kent"</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;people.length; i++)</span><br><span class="line">           <span class="keyword">if</span> (candidates.contains(people[i]))</span><br><span class="line">               <span class="keyword">return</span> people[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>重构 学习笔记</category>
      </categories>
      <tags>
        <tag>重构</tag>
        <tag>函数重构</tag>
      </tags>
  </entry>
  <entry>
    <title>02 信息的表示和处理</title>
    <url>/2018/05/10/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/02%20%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="信息的表示和处理"><a href="#信息的表示和处理" class="headerlink" title="信息的表示和处理"></a>信息的表示和处理</h1><p><strong>三种最重要的数字表示：</strong></p>
<ul>
<li><em>无符号编码</em>：基于传统的二进制表示，表示大于或者等于0的数。</li>
<li><em>补码编码</em>：表示有符号整数的最常见的方式，有符号整数就是可以为正或者为负的元素。</li>
<li><em>浮点数编码</em>：表示浮点数的科学计数法以二为基数的版本。<br></li>
</ul>
<p><strong>计算机的表示法会产生一些问题：</strong></p>
<ul>
<li>范围是有限的，当超过时就会发生<em>溢出</em>（overflow）。</li>
<li>整数满足运算性质（结合律，交互律等），浮点数不满足。</li>
</ul>
<p>本节主要介绍计算机中对数的编码和运算</p>
<h2 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h2><p>大部分计算机使用8位为一块，称为<em>字节</em>，作为最小的访问单位。<br>机器级程序将内存视为一个非常大的字节数组，称为<em>虚拟内存</em>。内存的每个字节都是由哦一个唯一的数字来标识，称为<em>地址</em>。所有可能的虚拟地址的集合称为<em>虚拟地址空间</em>。</p>
<h3 id="十六进制表示法"><a href="#十六进制表示法" class="headerlink" title="十六进制表示法"></a>十六进制表示法</h3><p>二进制太长，十进制不好转换成二进制，最好的方式是用十六进制来表示数。<br>二进制与十六进制之间的转换比较简单，其它进制转换为十进制用幂乘法，十进制转其它进制用模运算。</p>
<h3 id="字数据大小"><a href="#字数据大小" class="headerlink" title="字数据大小"></a>字数据大小</h3><p><em>字长</em>：指针数据的大小，决定了虚拟地址空间的最大大小。</p>
<table>
<thead>
<tr>
<th>有符号</th>
<th>无符号</th>
<th>32位</th>
<th>64位</th>
</tr>
</thead>
<tbody>
<tr>
<td>{signed} char</td>
<td>unsigned char</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>shrot</td>
<td>unsigned short</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>unsigned</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>unsigned long</td>
<td>4</td>
<td>8</td>
</tr>
<tr>
<td>int32_t</td>
<td>uint32_t</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>int64_t</td>
<td>uint64_t</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>char *</td>
<td></td>
<td>4</td>
<td>8</td>
</tr>
<tr>
<td>float</td>
<td></td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td></td>
<td>8</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>上表是C基本数据类型的典型大小，注意事项：</p>
<ul>
<li>char一般不区分符号</li>
<li>ISO C99引入了一类数据类型，不依赖“典型”数据大小和编译器环境，其中包括int32_t和int64_t。</li>
<li>对关键词的顺序以及是否省略可选关键词，C允许存在多种形式。</li>
</ul>
<h3 id="寻址和字节顺序"><a href="#寻址和字节顺序" class="headerlink" title="寻址和字节顺序"></a>寻址和字节顺序</h3><p><em>位</em>：[xn,…x1]<br>xn为<em>最高有效位</em>，x1为<em>最低有效位</em>。转换成字节（为8的倍数时）对应<em>最高有效字节</em>，和<em>最低有效字节</em>。<br><em>小端法</em>：在地址中有效字节从低到高。大端法相反。</p>
<p>字节顺序会影响的问题时：</p>
<ul>
<li>当传输和接受网络数据时</li>
<li>当阅读数据类型的字节序列时</li>
<li>当使用强制类型转型时</li>
</ul>
<h3 id="字符串的表示"><a href="#字符串的表示" class="headerlink" title="字符串的表示"></a>字符串的表示</h3><p>每一个字符都由标准字符编码来表示，最常见的是ASCII表。<br>使用ASCII表来进行编码的文件成为文本文件，其他的成为二进制文件。在使用ASCII编码的系统中，文本文件比二进制文件具有更强的平台独立性，因为不受字节顺序和字大小的约束。</p>
<h3 id="布尔代数简介"><a href="#布尔代数简介" class="headerlink" title="布尔代数简介"></a>布尔代数简介</h3><p>用于处理真和假，0和1的逻辑运算。拓展到多个就 叫做位向量，位向量一个很实用的作用是用来表示有限的集合，以及很方便的做集合之间的交，并，补。</p>
<h3 id="C语言中的布尔运算，逻辑运算，移位运算"><a href="#C语言中的布尔运算，逻辑运算，移位运算" class="headerlink" title="C语言中的布尔运算，逻辑运算，移位运算"></a>C语言中的布尔运算，逻辑运算，移位运算</h3><p>布尔：|，&amp;，~，^<br>逻辑：||，&amp;&amp;，!<br>移位运算：&lt;&lt;，&gt;&gt;，&gt;&gt;&gt;（java）</p>
<blockquote>
<p>对于左移运算，在低位补0.对于右移运算，一般都有逻辑右移（高位补0）和算术右移（高位补和最高有效位相同的数），对于确切的是哪一种，没有明确定义。但是，一般来说，对于有符号的数据，采用算术右移；无符号的采取逻辑右移。而在java中，明确表示&gt;&gt;表示算术右移；&gt;&gt;&gt;表示逻辑右移。</p>
</blockquote>
<blockquote>
<p>当移动的数大于数据本身的位数时，C语言会报错，而在java中要求采取模运算的方式来处理移动的位数。</p>
</blockquote>
<h2 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h2><p>无符号编码和补码只是两种二进制编码方式<br>对于补码而言，只是数字所表示的含义不同，是为了给计算机定义“负数”所采用的一种方式，但是它是符合正常的加减法规则的，因此在作计算时无需考虑其含义。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://latex.codecogs.com/gif.latex?B2T_{w}"></td>
<td>函数</td>
<td>二进制转补码</td>
</tr>
<tr>
<td><img src="https://latex.codecogs.com/gif.latex?B2U_{w}"></td>
<td>函数</td>
<td>二进制转无符号</td>
</tr>
<tr>
<td><img src="https://latex.codecogs.com/gif.latex?U2B_{w}"></td>
<td>函数</td>
<td>无符号转二进制</td>
</tr>
<tr>
<td><img src="https://latex.codecogs.com/gif.latex?U2T_{w}"></td>
<td>函数</td>
<td>无符号转补码</td>
</tr>
<tr>
<td><img src="https://latex.codecogs.com/gif.latex?T2B_{w}"></td>
<td>函数</td>
<td>补码转二进制</td>
</tr>
<tr>
<td><img src="https://latex.codecogs.com/gif.latex?T2U_{w}"></td>
<td>函数</td>
<td>补码转无符号</td>
</tr>
<tr>
<td><img src="https://latex.codecogs.com/gif.latex?TMin_{w}"></td>
<td>常数</td>
<td>最小补码值</td>
</tr>
<tr>
<td><img src="https://latex.codecogs.com/gif.latex?TMax_{w}"></td>
<td>常数</td>
<td>最大补码值</td>
</tr>
<tr>
<td><img src="https://latex.codecogs.com/gif.latex?UMax_{w}"></td>
<td>常数</td>
<td>最大无符号值</td>
</tr>
<tr>
<td><img src="https://latex.codecogs.com/gif.latex?+_{t}^{w}"></td>
<td>操作</td>
<td>补码加</td>
</tr>
<tr>
<td><img src="https://latex.codecogs.com/gif.latex?+_{u}^{w}"></td>
<td>操作</td>
<td>无符号加</td>
</tr>
<tr>
<td><img src="https://latex.codecogs.com/gif.latex?* _{t}^{w}"></td>
<td>操作</td>
<td>补码乘</td>
</tr>
<tr>
<td><img src="https://latex.codecogs.com/gif.latex?* _{u}^{w}"></td>
<td>操作</td>
<td>无符号乘</td>
</tr>
<tr>
<td><img src="https://latex.codecogs.com/gif.latex?-_{t}^{w}"></td>
<td>操作</td>
<td>补码减</td>
</tr>
<tr>
<td><img src="https://latex.codecogs.com/gif.latex?-_{t}^{w}"></td>
<td>操作</td>
<td>无符号减</td>
</tr>
</tbody>
</table>
<p>有符号的数和无符号的数之间存在隐式或者显式的转换。尤其注意在逻辑运算时，这种隐式的转换会带来一些非直观的效果，导致程序出现异常。</p>
<h3 id="无符号的编码"><a href="#无符号的编码" class="headerlink" title="无符号的编码"></a>无符号的编码</h3><p><img src="https://latex.codecogs.com/gif.latex?B2U_{w}(\overrightarrow{x})=\sum_{i=0}^{w-1}x_{i}2^{i}"></p>
<h3 id="补码编码"><a href="#补码编码" class="headerlink" title="补码编码"></a>补码编码</h3><p><img src="https://latex.codecogs.com/gif.latex?B2T_{w}(\overrightarrow{x})=-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_{i}2^{i}"></p>
<h3 id="无符号与补码之间的转换"><a href="#无符号与补码之间的转换" class="headerlink" title="无符号与补码之间的转换"></a>无符号与补码之间的转换</h3><p>首先，我们必须认清楚一个概念，就是无符号和补码之间的转换是以相同的二进制码为基础的不同的表示方法之间的转换，通过上面的补码和无符号的两个公司我们可以得到：</p>
<p><img src="https://latex.codecogs.com/gif.latex?B2T_{w}(\overrightarrow{x})=-x_{w-1}2^{w}&plus;B2U_{w}(\overrightarrow{x})"></p>
<h4 id="补码转无符号"><a href="#补码转无符号" class="headerlink" title="补码转无符号"></a>补码转无符号</h4><p><img src="https://latex.codecogs.com/gif.latex?T2U_{w}(x)=B2U_{w}(T2B_{w}(x))=x_{w-1}2^{w}&plus;x"></p>
<p>在补码范围内的非负数，对应的无符号一致；负数对应的无符号需要增加一个步长。</p>
<h4 id="无符号转补码"><a href="#无符号转补码" class="headerlink" title="无符号转补码"></a>无符号转补码</h4><p>为补码转无符号 公式的反函数：</p>
<p><img src="https://latex.codecogs.com/gif.latex?U2T_{w}(u)=-u_{w-1}2^{w}&plus;u"></p>
<p>在无符号范围内的小于补码最大值的数，对应的补码一致；大于补码最大值的数对应的无符号减少增加一个步长。</p>
<h3 id="位的扩展和截断"><a href="#位的扩展和截断" class="headerlink" title="位的扩展和截断"></a>位的扩展和截断</h3><p>扩展：</p>
<ul>
<li>补码在开头补符号位</li>
<li>无符号在开头补0.</li>
</ul>
<p>截断：<br>截断可以解释为先转换成无符号码进行模运算，再转成成对应的编码表示。</p>
<ul>
<li>无符号：<img src="https://latex.codecogs.com/gif.latex?B2U_{k}(u)[x_{k-1},x_{k-2},...,x_{0}]=B2U_{w}(w)[x_{w-1},x_{w-2},...,x_{0}]mod2^{k}"></li>
<li>补码：<img src="https://latex.codecogs.com/gif.latex?B2U_{k}(u)[x_{k-1},x_{k-2},...,x_{0}]=U2T_{k}(B2U_{w}(w)[x_{w-1},x_{w-2},...,x_{0}]mod2^{k})"></li>
</ul>
<h2 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h2><h3 id="无符号加法"><a href="#无符号加法" class="headerlink" title="无符号加法"></a>无符号加法</h3><p>在无符号的值范围内可以正常相加，当有溢出时，溢出的位截断，只保留定常的位。公式如下：<br><img src="https://latex.codecogs.com/gif.latex?x&plus;_{u}^{w}y=\begin{cases}&space;&&space;x&plus;y\text{&space;if&space;}&space;x&plus;y<2^{w}&space;\\&space;&&space;x&plus;y-2^{w}\text{&space;if&space;}&space;x&plus;y>=2^{w}&space;\end{cases}"></p>
<p>一般来说，当程序发生溢出，并不会报错，因此需要人为的去进行判断，判断的方法是：对x+y=s，若s&lt;x，则发生溢出。</p>
<p>模运算是一个阿贝尔群，因此满足交换律，结合律，并有一个单位元，且有逆元。公式如下：<br><img src="https://latex.codecogs.com/gif.latex?-_{u}^{w}x=\begin{cases}&space;&&space;x\text{&space;if&space;}&space;x=0&space;\\&space;&&space;2^{w}-x\text{&space;if&space;}&space;x>0&space;\end{cases}"></p>
<h3 id="补码加法"><a href="#补码加法" class="headerlink" title="补码加法"></a>补码加法</h3><p>无论是无符号加法还是补码加法或者是其它加法，在计算机底层都是同一种二进制的加法，而二进制的加法可以表现成无符号加法，因此补码的加法可以表现为先转换成无符号进行加法运算，截断后再转换成补码公式如下:</p>
<ul>
<li>对于补码加法的正溢出，可以理解为最高符号位上的0变成了1，因此从正数变成了负数，然后转补码（此时需要减去一个位长值）。</li>
<li>对于补码加法的负溢出，可以理解为在位之外多了一个1，截断即为做了模运算，然后转补码（此时不需要减去位长值，但是模运算的时候也相当于加上了位长值）。</li>
</ul>
<h4 id="补码的溢出判断"><a href="#补码的溢出判断" class="headerlink" title="补码的溢出判断"></a>补码的溢出判断</h4><p>对于x+y=s，当x&gt;0，y&gt;0时，s&lt;=0，发生了正溢出。当x&lt;0，y&lt;0时，s&gt;=0，发生了负溢出。</p>
<h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><p>首先我们得知道，对于无符号和有符号的底层乘法实现方式是不一样的， 具体是如何可以参考其他的书籍，在C语言中，w位的整数相乘后可能需要2w位来进行表示，而有符号和无符号被定义为相应的2w位二进制截断w位后的不同编码方式。而对它们来说，2w位的二进制可能不一样，但是截断后的w位恰巧都是相同的，这也就是所谓的<em>乘法的位级表示是一样的</em>，表示成定义即：给定位向量<img src="https://latex.codecogs.com/gif.latex?\vec{x}">和位向量<img src="https://latex.codecogs.com/gif.latex?\vec{y}">,他们的补码表示为x和y，无符号表示为x’和y’，因而有：<br><img src="https://latex.codecogs.com/gif.latex?T2B_{w}(x*_{w}^{t}y)=U2B_{w}(x'*_{w}^{u}y')"><br>在理解乘法公式之前，先提出模运算具有的一个性质：<img src="https://latex.codecogs.com/gif.latex?(x\cdot&space;y)mod2^w=(x'\cdot&space;y')mod2^w"></p>
<ul>
<li>无符号的乘法公式：<img src="https://latex.codecogs.com/gif.latex?x*_{w}^{u}y=(x\cdot&space;y)mod2^w"></li>
<li>补码的乘法公式：<img src="https://latex.codecogs.com/gif.latex?x*_{w}^{t}y=U2T_{w}((x\cdot&space;y)mod2^w)"></li>
</ul>
<p>一开始对补码公式一直乘法 不太理解，后来才明白，这样的表示，其实就是结合上面模运算的性质，先进性无符号的运算，再将无符号转换成补码。</p>
<h3 id="乘一个常数"><a href="#乘一个常数" class="headerlink" title="乘一个常数"></a>乘一个常数</h3><p>整数的乘法指令速度相当慢，需要10个或者更多的时钟周期，而其它的运算只需要一个。因而对于乘一个常数，我们往往用移位来实现。</p>
<ul>
<li>乘2的幂：无论是无符号还是补码，乘2的k次方等价于左移k位，发生溢出导致的结果也一样。</li>
<li>乘任意常数：如14=2^3+2^2+2，因此，x*2^14可以用(x&lt;&lt;3)+(x&lt;&lt;2)+(x&lt;&lt;1)来实现。</li>
</ul>
<h3 id="除一个2的幂"><a href="#除一个2的幂" class="headerlink" title="除一个2的幂"></a>除一个2的幂</h3><p>计算机中的除法是向下舍入正数值，向上舍入负数值，在使用右移来实现除2的幂时需要注意，因为右移只能产生向下舍入的结果，对于负数的向上舍入，需要先加上一个偏量，再做右移操作。</p>
<ul>
<li>无符号的除以2的k次幂：x&gt;&gt;k。</li>
<li>补码的除以2的k次幂：(x&lt;0?x+(1&lt;&lt;k)-1:x)&gt;&gt;k</li>
</ul>
<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><h3 id="定点表示法"><a href="#定点表示法" class="headerlink" title="定点表示法"></a>定点表示法</h3><ul>
<li>定点整数：纯整数，小数点定在最低有效位后。</li>
<li>定点小数：纯小数，小数点定在符号位之后，最高有效位之前。</li>
<li>定点浮点数：需要一个比例因子先转换成定点小数或者定点整数，运算后再根据比例因子还原成实际结果。比例因子的选择不当，往往会造成溢出或者降低有效精度。</li>
</ul>
<h3 id="IEEE浮点表示法"><a href="#IEEE浮点表示法" class="headerlink" title="IEEE浮点表示法"></a>IEEE浮点表示法</h3><p>公式：<img src="https://latex.codecogs.com/gif.latex?V=(-1)^{s}*M*2^{E}"></p>
<ul>
<li>s：符号，对于0的符号作位特殊情况处理。</li>
<li>M：尾数，二进制数,f为其二进制表示的小数,M=f或者是1+f。</li>
<li>E：阶码，2的E次幂。<blockquote>
<p>对于32位机器来说，s长1,M长8,E长23。对于64位的机器来说，s长1，M长11，E长52.</p>
</blockquote>
</li>
</ul>
<p><img src="/2018/05/10/系统原理/02 信息的表示和处理/01.png" alt="浮点表示法"></p>
<p>值分成三种情况</p>
<ul>
<li>规格化的值：阶码位不全为0或者1，这种情况下，M=1+f，阶码字段被解释为以偏置形式来表示有符号整数，也就是说阶码值E=e-Bias，其中e是无符号值，Bias是偏置值等于2^k-1-1（单精度127，双精度1023）由此产生的指数的取值范围：单精度：-126~127.双精度：-1022~1023.</li>
<li>非规格化的值：阶码位全为0，这种情况下，E=1-Bias，M=f。非规格化的值提供两个功能：①提供+0和-0的表示②提供了接近0的值均匀分布。</li>
<li>特殊值：阶码位全为1时。若尾数位全为0，根据符号表示正无穷或负无穷。若尾数位不全为0，表示NaN.</li>
</ul>
<p><img src="/2018/05/10/系统原理/02 信息的表示和处理/02.png" alt="浮点表示法"></p>
<p>三种情况的分布区域</p>
<p><img src="/2018/05/10/系统原理/02 信息的表示和处理/03.png" alt="浮点表示法"></p>
<p>案例：</p>
<p><img src="/2018/05/10/系统原理/02 信息的表示和处理/04.png" alt="浮点表示法"></p>
<h3 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h3><ul>
<li>偶数舍入：对于中间值，向偶数舍入，在小数舍入时，尤其要确认该小数是否中间值。</li>
<li>向零舍入：绝对值变小。</li>
<li>向上舍入：上确界。</li>
<li>向下舍入：下确界。</li>
</ul>
<h3 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h3><p>Round(x?Y)，满足交换律，不满足结合律，具备单调性。<br>这里书中也没有很具体，需要从其它地方获取详细的过程。</p>
<h3 id="C语言的浮点数"><a href="#C语言的浮点数" class="headerlink" title="C语言的浮点数"></a>C语言的浮点数</h3><p>C提供两种浮点是，float和double且大多情况下支持IEEE标准， 但C并没有强制要求符合IEEE标准，因此并没有标准方法改变舍入方式或者定义诸如-0, +∞+∞, −∞−∞或者NaN这些特殊值， 大多数系统提供相应头文件或库，但没有统一标准，可能细节有所不同。</p>
<p>强制转换的规则：</p>
<ul>
<li>从int到float，数字不会溢出，但可能被舍入。</li>
<li>从int/float转到double，因double精度更大，因此能保留精确的数值。</li>
<li>从double到float，可能溢出成为 ±∞±∞，也有可能因精度问题被舍入</li>
<li>从float/double转为int，值将向零舍入。进一步说，值可能会溢出（毕竟浮点数范围更大）。然而，C标准没有对此的规定。因此，有些诸如与Intel兼容的微处理器将整数最小值统一定义为整数不确定（integer indefinite）值，即溢出结果。例如对于32位数，TMin_32 = [10…000] = -2^31 = 2 147 483 648。</li>
</ul>
<h2 id="常用的移位运算"><a href="#常用的移位运算" class="headerlink" title="常用的移位运算"></a>常用的移位运算</h2><ul>
<li><p>数据位长：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sizeof(date)&lt;&lt;3（字节长×8个位）</span><br></pre></td></tr></table></figure>
</li>
<li><p>溢出判断：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t = a + b时，如果a，b异号（或者存在0），则肯定不会溢出。</span><br><span class="line">如果a，b均大于等于0，则t&lt;0就是正溢出，如果a，b均小于0，则t&gt;=0就是负溢出。</span><br><span class="line">于是，可以利用三个变量来表示是正溢出，负溢出还是无溢出。</span><br><span class="line">int w = sizeof(int)&lt;&lt;3;</span><br><span class="line">int t = x + y;</span><br><span class="line">int ans = x + y;</span><br><span class="line">x&gt;&gt;=(w-1);//11111111</span><br><span class="line">y&gt;&gt;=(w-1);//11111111</span><br><span class="line">t&gt;&gt;=(w-1);//00000000</span><br><span class="line">int pos_ovf = ~x&amp;~y&amp;t;//00000000</span><br><span class="line">int neg_ovf = x&amp;y&amp;~t;//11111111</span><br><span class="line">int novf = ~(pos_ovf|neg_ovf);//00000000</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对于有符号整数相减，溢出的规则可以总结为：</span><br><span class="line">t = a-b;</span><br><span class="line">如果a, b 同号，则肯定不会溢出。</span><br><span class="line">如果a&gt;=0 &amp;&amp; b&lt;0，则只有当t&lt;=0时才算溢出。</span><br><span class="line">如果a&lt;0 &amp;&amp; b&gt;=0，则只有当t&gt;=0时才算溢出。</span><br><span class="line">不过，上述t肯定不会等于0，因为当a，b不同号时：</span><br><span class="line">1) a!=b，因此a-b不会等于0。</span><br><span class="line">2) a-b &lt;= abs(a) + abs(b) &lt;= abs(TMax) + abs(TMin)=(2^w - 1)</span><br><span class="line">所以，a，b异号，t，b同号即可判定为溢出。</span><br><span class="line">int tsub_ovf(int x, int y)&#123;</span><br><span class="line">    int w = sizeof(int)&lt;&lt;3;</span><br><span class="line">    int t = x - y;</span><br><span class="line">    x&gt;&gt;=(w-1);</span><br><span class="line">    y&gt;&gt;=(w-1);</span><br><span class="line">    t&gt;&gt;=(w-1);</span><br><span class="line">    return (x != y) &amp;&amp; (y == t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机系统原理</category>
      </categories>
      <tags>
        <tag>计算机系统原理</tag>
        <tag>信息的表示和处理</tag>
      </tags>
  </entry>
  <entry>
    <title>08 异常控制流</title>
    <url>/2019/07/18/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/08%20%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</url>
    <content><![CDATA[<h1 id="异常控制流"><a href="#异常控制流" class="headerlink" title="异常控制流"></a>异常控制流</h1><p>本章的核心内容：</p>
<ol>
<li>了解什么是异常控制流（ECF）</li>
<li>了解系统中哪些功能是基于ECF实现的</li>
</ol>
<p><strong>什么是控制流？</strong></p>
<p>程序计数器中指令的序列叫<code>控制流</code></p>
<p><strong>什么是突变？</strong></p>
<p>指令是相邻的，我们说是“平滑的”<br>如果不相邻，就叫<code>突变</code><br>引起突变的可能有跳转、调用、返回等指令，这些都是必要的突变<br>也有一些突变是系统状态的变化导致的</p>
<p><strong>什么是异常控制流(ECF)？</strong></p>
<p>这些指令的突变叫做<code>异常控制流</code></p>
<p><strong>异常控制流会发生在计算机系统的哪些层次？</strong></p>
<p>硬件层：事件触发异常，控制流转移到异常处理程序<br>操作系统层：上下文切换让控制流在进程间切换<br>应用层：进程接受信号，控制流转移信号处理程序</p>
<p><strong>了解ECF的好处？</strong></p>
<ol>
<li>ECF是实现I/O，进程和虚拟内存的基本机制</li>
<li>理解程序和操作系统的交互，通过“陷阱”或者“系统调用”的ECF</li>
<li>编写shell程序，通过“上下文切换”的ECF</li>
<li>理解并发，ECF是实现并发的基本机制，如被中断的异常处理程序，时间上重叠的进程和线程，被中断后的信号处理程序</li>
<li>理解try、catch是怎么一回事，通过非本地跳转的ECF</li>
</ol>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><strong>什么是异常？</strong></p>
<p>ECF的一种形式，用来反映处理器状态的变化。<br>属于硬件层，但也有一部分由操作系统实现</p>
<p><strong>什么是事件？比如？</strong></p>
<p>处理器状态的变化称为<code>事件</code><br>比如：虚拟内存缺页、算术溢出、除零</p>
<p><strong>事件发生时如何处理？</strong></p>
<p>由处理器来检测事件的发生<br>通过异常表跳转到异常处理程序</p>
<p><img src="/2019/07/18/系统原理/08 异常控制流/01.png" alt="异常表"></p>
<p>完成处理后，有3中选择：</p>
<ol>
<li>返回到事件发生时正在执行的指令</li>
<li>返回到事件发生时的下一条指令</li>
<li>程序终止</li>
</ol>
<p><strong>异常和过程调用有什么区别？</strong></p>
<ol>
<li>异常有选择的把当前指令或者吓一跳指令压入栈</li>
<li>会把一些额外的处理器状态压入栈</li>
<li>如果控制流从用户程序转移到内核，那么栈是内核栈，而不是用户栈</li>
<li><em>异常处理程序运行在内核模式（见后文）</em></li>
</ol>
<p><strong>异常的类别？</strong></p>
<p>中断（interrupt）、陷阱(trap)、故障(fault)、终止(abort)</p>
<p><img src="/2019/07/18/系统原理/08 异常控制流/02.png" alt="异常"></p>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>中断是异步发生的，是来自处理器外部I/O设备的信号的结果<br>所谓异步，是指并非由指令造成，而是任意时间的外部因素</p>
<p>流程：<br><img src="/2019/07/18/系统原理/08 异常控制流/03.png" alt="中断"></p>
<h3 id="陷阱和系统调用"><a href="#陷阱和系统调用" class="headerlink" title="陷阱和系统调用"></a>陷阱和系统调用</h3><p>陷阱是有意的异常（故意的跳转），是指令执行的结果<br>譬如：执行”syscall n”指令会导致一个到陷阱处理程序的跳转<br>由此可见，陷阱的一个重要用户的让用户程序调用内核函数，叫做<code>系统调用</code><br>如：读文件、创建进程、加载进程、终止进程</p>
<p><img src="/2019/07/18/系统原理/08 异常控制流/04.png" alt="陷阱"></p>
<p><strong>什么是errno？</strong></p>
<p>Linux中系统调用的错误都存储于errno中，errno由操作系统维护，存储就近发生的错误，即下一次的错误码会覆盖掉上一次的错误。<br>Linux中的strerror(errno)可以返回某个errno值的文本描述</p>
<h3 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h3><p>故障是由指令错误引起的<br>故障处理程序能处理，则重新执行指令，否则，返回到内核中的abort历程</p>
<p><img src="/2019/07/18/系统原理/08 异常控制流/05.png" alt="陷阱"></p>
<h3 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h3><p>终止由不可恢复的致命错误导致，一般是硬件错误<br>譬如DRAM、SRAM位损坏</p>
<p><img src="/2019/07/18/系统原理/08 异常控制流/06.png" alt="陷阱"></p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>异常控制流是操作系统内核得以提供<code>进程</code>概念的基本构造块</p>
<p><strong>什么是进程？</strong></p>
<p><code>进程</code>就是执行中的一个程序实例</p>
<p><strong>什么是上下文？</strong></p>
<p><code>上下文</code>是一个进程运行所需要的各种状态<br>譬如：内存中的代码和数据、栈、寄存器、程序计数器、环境变量、打开文件描述符集合</p>
<blockquote>
<p>一个进程的上下文可以分为三个部分:用户级上下文、寄存器上下文以及系统级上下文。<br>用户级上下文: 正文、数据、用户堆栈以及共享存储区；<br>寄存器上下文: 通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)；<br>系统级上下文: 进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈。</p>
</blockquote>
<p><strong>进程提供给应用程序的两个抽象是？</strong></p>
<ol>
<li>一个独立的<code>逻辑控制流</code></li>
<li>一个私用的<code>虚拟地址空间</code></li>
</ol>
<p><strong>什么是逻辑控制流？</strong></p>
<p>一个进程运行所独有的PC序列叫做<code>逻辑流</code></p>
<p><img src="/2019/07/18/系统原理/08 异常控制流/07.png" alt="逻辑流"></p>
<p><strong>什么是并发流？多任务？</strong></p>
<p>两个在时间上有重叠的逻辑流称为<code>并发流</code><br>从宏观上看，进程间的轮流执行叫<code>多任务</code></p>
<p><strong>什么是用户模式和内核模式？</strong></p>
<p>为了进一步完善进程的概念，处理器需要提供一种机制，来限制进程能够执行的指令和能够访问的地址空间<br>处理器通过某个寄存器中的一个模式位为来提供这种机制，也就是用户模式和内核模式的概念<br>用户模式：无法执行特权指令（停止处理器，修改位模式），也无法访问内核地址空间中代码和数据（只能通过系统调用）<br>内核模式：能够执行所有和指令和访问机型所有的地址空间</p>
<p><strong>进入内核模式的方式有哪些？</strong></p>
<p>唯一的方式就是通过中断、陷阱这样的异常</p>
<p><strong>linux的/proc文件系统有什么用？</strong></p>
<p>提供一个后门，让进程在用户模式下安全的访问内核数据结构的内容（譬如CPU类型，内存段）</p>
<p><strong>什么是调度？</strong></p>
<p>内核决定在某时刻执行一个新的进程叫做<code>调度</code></p>
<p><strong>什么是上下文切换？</strong></p>
<p>属于操作系统层的异常控制流，基于硬件层的异常控制流之上（所以上下文切换也是发生在内核模式），用来实现多任务</p>
<ol>
<li>保存当前进程上下文</li>
<li>恢复另一个进程的上下文</li>
<li>控制转移</li>
</ol>
<p><img src="/2019/07/18/系统原理/08 异常控制流/08.png" alt="上下文切换"></p>
<p><strong>引起上下文切换的情况？</strong></p>
<ol>
<li>系统调用（陷阱）：系统调用因为等待某个事件而发生阻塞，那么内核可以让当前进程休眠，切换到另一个进程；比如read文件阻塞被动休眠，再比如sleep主动休眠。</li>
<li>中断：所有的计算机都会有某种周期性的定时器中断机制，中断后进行上下文切换</li>
</ol>
<h2 id="系统调用错误处理"><a href="#系统调用错误处理" class="headerlink" title="系统调用错误处理"></a>系统调用错误处理</h2><p><strong>什么是错误包装函数？</strong></p>
<p>对系统调用进行一次包装，包装函数中检查错误</p>
<p><strong>为什么要使用错误包装函数？</strong></p>
<p>系统调用出错会设置errno值<br>如果每次都去检查错误，代码会变得臃肿难懂<br>使用错误包装函数能使代码变得简洁</p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>每一个进程都有一个进程id(pid)</p>
<p><strong>进程的三种状态是？</strong></p>
<ul>
<li>运行：正在CPU上执行或者等待被内核调度</li>
<li>停止：进程被挂起，无法被调度，等待被唤醒</li>
<li>终止：进程死掉了</li>
</ul>
<p><strong>有哪些因素会导致进程终止？</strong></p>
<ol>
<li>收到一个终止进程的信号</li>
<li>从主程序返回</li>
<li>调用exit函数</li>
</ol>
<p><strong>fork函数具有什么功能？</strong></p>
<p>创建一个新的运行的子进程</p>
<p><strong>fork后的子进程和父进程有什么关联和区别？</strong></p>
<p>最大的区别就是PID不同</p>
<ol>
<li>调用fork函数会有两次返回，父进程中返回子进程的PID，子进程中返回0</li>
<li>并发执行，新创建的子进程和父进程会并发的执行</li>
<li>相同但是独立的虚拟地址空间</li>
<li>共享文件，子进程可以读写父进程中打开的共享文件</li>
</ol>
<p><img src="/2019/07/18/系统原理/08 异常控制流/09.png" alt="fork进程图"></p>
<p><strong>子进程终止如何处理？</strong></p>
<p>终止的进程不会立即在系统中消失，而是等待被父进程<code>回收</code><br>如果父进程先终止，内核会安排init进程称为孤儿进程的“养父”<br>init进程pid为1，是所有进程的祖先</p>
<p><strong>回收僵尸进程的相关函数？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statusp, <span class="keyword">int</span> options);</span><br><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">int</span> *statusp);                        <span class="comment">//等价于pid_t waitpid(-1, &amp;statusp, 0);</span></span><br></pre></td></tr></table></figure>
<p>等待一个集合中的子进程终止并回收<br>如果没有子进程，则返回-1，设置errno为ECHILD<br>如果被信号中断，则返回-1，设置errno为EINTR</p>
<ul>
<li>pid：等待集<ol>
<li>pid &gt; 0：等待集是编号为pid的进程</li>
<li>pid = -1：等待集是父进程所有的子进程</li>
</ol>
</li>
<li>options：修改函数行为<ol>
<li>默认(0)：挂机调用进程，直到等待集中的一个子进程终止</li>
<li>WNOHANG：立即返回（都没终止返回0）</li>
<li>WUNTRACED：挂机调用进程，直到等待集中的一个子进程终止或停止</li>
<li>WCONTINUED：挂机调用进程，直到等待集中的一个子进程终止或者一个停止的子进程重新执行</li>
</ol>
</li>
<li>statusp：返回状态<ol>
<li>WIFEXITED(status)：如果子进程正常结束，它就返回真；否则返回假。</li>
<li>WEXITSTATUS(status)：如果WIFEXITED(status)为真，则可以用该宏取得子进程exit()返回的结束代码。</li>
<li>WIFSIGNALED(status)：如果子进程因为一个未捕获的信号而终止，它就返回真；否则返回假。</li>
<li>WTERMSIG(status)：如果WIFSIGNALED(status)为真，则可以用该宏获得导致子进程终止的信号代码。</li>
<li>WIFSTOPPED(status)：如果当前子进程被暂停了，则返回真；否则返回假。</li>
<li>WSTOPSIG(status)：如果WIFSTOPPED(status)为真，则可以使用该宏获得导致子进程暂停的信号代码。</li>
</ol>
</li>
</ul>
<p><strong>进程休眠的相关函数？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> secs)</span></span>;    <span class="comment">//等待时间到或者被信号中断</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pause</span><span class="params">(<span class="keyword">void</span>)</span></span>;                          <span class="comment">//一致挂起知道被信号中断</span></span><br></pre></td></tr></table></figure>
<p><strong>execve函数具有什么样的功能？</strong></p>
<p>在当前的进程的上下文中加载并运行一个新程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *argv[], <span class="keyword">const</span> <span class="keyword">char</span> *envp[])</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>filename：可执行的文件名</li>
<li>argv[]：参数列表</li>
<li>envp[]：环境变量列表</li>
</ul>
<p><img src="/2019/07/18/系统原理/08 异常控制流/10.png" alt="fork进程图"></p>
<p><strong>程序和进程有什么区别？</strong></p>
<p>程序运行在进程的上下文中</p>
<p>案例：结合fork和execve实现一个简单的shell</p>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p><strong>什么是信号？和异常的区别？</strong></p>
<p>信号是应用层的异常，信号是进程上下文中的某个状态，对应一种底层事件<br>底层事件是处理器通知到内核，由内核异常处理程序处理的，这些用户进程是看不到的<br>信号是操作系统提供给进程的一种机制，让进程可以知道发生了这些异常事件</p>
<p><img src="/2019/07/18/系统原理/08 异常控制流/11.png" alt="信号"></p>
<p><strong>发送信号和接受信号的表现形式是什么？</strong></p>
<ul>
<li>发送信号：内核更新了进程上下文中的某个状态<ol>
<li>检测到一个系统事件</li>
<li>调用了kill函数</li>
</ol>
</li>
<li>接受信号：目的进程被内核强迫以某种方式处理信号，忽略、终止、或者执行信号处理程序</li>
</ul>
<p>发个发出了但未接收的信号是待处理信号<br>每种类型的待处理信号只有一个，多于的呗丢弃<br>信号被阻塞，意味着信号可以被发送，但是不会被接收。</p>
<p><strong>什么是进程组？</strong></p>
<p>每个进程都只属于一个进程中<br>默认情况下，一个子进程继承父进程的进程组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> getpgrp(<span class="keyword">void</span>)                 <span class="comment">//获取当前进程的进程组id</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span>  <span class="comment">//将进程pid的进程组改为pgid</span></span></span><br></pre></td></tr></table></figure>
<p><strong>什么是<code>作业</code>？</strong></p>
<p>linux的一条命令行就是一个“作业”<br>同时只能有一个前台作业和多个后台作业</p>
<p><img src="/2019/07/18/系统原理/08 异常控制流/12.png" alt="信号"></p>
<p><strong>具体的发送信号的方式有哪些？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">linux&gt;/bin/kill <span class="number">-9</span> (-)<span class="number">15213</span>           <span class="comment">//发送信号给进程（组）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> secs)</span> <span class="comment">//定时发送SIGALRM信号</span></span></span><br></pre></td></tr></table></figure>
<p><strong>接受信号时机是什么时候？以及如何处理？</strong></p>
<p>接受信号的时机是从内核模式切换到用户模式时(从系统调用返回或者上下文切换)，去检查待处理且未阻塞的信号集合，选择其中的某个信号k<br>指定下面的某个行为：</p>
<ol>
<li>终止</li>
<li>终止并转储内存</li>
<li>挂起，等待重启</li>
<li>忽略</li>
<li>信号处理程序<br>默认行为可以修改</li>
</ol>
<p><strong>如何修改信号的默认行为？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* handler = SIG_IGN：忽略</span></span><br><span class="line"><span class="comment">* handler = SIG_DFL：恢复默认</span></span><br><span class="line"><span class="comment">* handler = 函数指针：信号处理程序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">sighandler_t</span> signal(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span><br></pre></td></tr></table></figure>
<p><img src="/2019/07/18/系统原理/08 异常控制流/13.png" alt="信号处理程序"></p>
<p><strong>具体的阻塞信号的方法？</strong></p>
<ul>
<li>隐式阻塞机制：正在被处理的信号默认被阻塞</li>
<li>显式阻塞机制：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* set    操作集</span></span><br><span class="line"><span class="comment">* oldset 以往的阻塞集</span></span><br><span class="line"><span class="comment">* how = SIG_BLOCK：把操作集添加到阻塞集中</span></span><br><span class="line"><span class="comment">* how = SIG_UNBLOCK：把操作集从阻塞集中删除</span></span><br><span class="line"><span class="comment">* how = SETMASK：阻塞集=操作集</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">( <span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> <span class="built_in">set</span>, <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> oset )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span><span class="comment">//清空操作集</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span><span class="comment">//用所有信号填充操作集</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span><span class="comment">//添加</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span><span class="comment">//删除</span></span></span><br></pre></td></tr></table></figure>
<p><strong>编写信号处理函数的难点是什么？</strong></p>
<ol>
<li>处理程序和主程序共享全局变量</li>
<li>接受信号的规则有违直觉</li>
<li>不同的系统由不同的信号处理语义</li>
</ol>
<p><strong>编写信号处理函数保守规则是什么？</strong></p>
<ol>
<li>处理程序尽可能简单</li>
<li>使用安全的函数</li>
<li>保存和恢复errno</li>
<li>阻塞其他的信号，保护对共享变量的访问</li>
<li>用volatile声明，立刻刷新主存</li>
</ol>
<p><strong>信号的接口规则会导致怎样的意外错误？</strong></p>
<p>如果用信号处理程序来处理排队问题<br>由于信号的非排队机制会直接导致严重的错误</p>
<p><strong>信号处理函数的系统兼容性问题是什么？</strong></p>
<ol>
<li>signal语义不同：有的是一次性的，每次都需要去重新修改</li>
<li>有些系统调用可能会被信号处理中断，因此需要手动的去重启</li>
</ol>
<p><strong>如何解决这些兼容性问题？</strong></p>
<p>使用signal的包装函数</p>
<p><strong>什么情况下需要等待信号被接收？</strong></p>
<p>比如，维护唯一的前台作业</p>
<p><strong>如何显示的等待信号？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigsuspend</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *mask)</span><span class="comment">//用mask暂时替换当前的阻塞集合，挂起并等待信号的接受</span></span></span><br></pre></td></tr></table></figure>
<h2 id="非本地跳转"><a href="#非本地跳转" class="headerlink" title="非本地跳转"></a>非本地跳转</h2><p><strong>什么是非本地跳转？</strong></p>
<p>非本地跳转是一种用户级的异常控制流形式<br>可以从某一个函数的某处直接转移到另一个函数的某处，不需要进过栈进出<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span>                   <span class="comment">//在env缓存区保存当前的调用环境</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigsetjmp</span><span class="params">(sigjmp_buf env, <span class="keyword">int</span> retval)</span> <span class="comment">//从env中恢复调用环境，从setjmp返回，返回值是retval</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong>非本地跳转有哪些重要的应用？</strong></p>
<h2 id="操作进程的工具"><a href="#操作进程的工具" class="headerlink" title="操作进程的工具"></a>操作进程的工具</h2><p>STRACE:打印出一个正在运行的进程和子进程调用的每个系统调用的轨迹<br>PS:列出当前所有的进程（包括僵尸进程）<br>TOP:打出当前进程资源使用信息<br>PMAP:显示进程的内存映射</p>
]]></content>
      <categories>
        <category>计算机系统原理</category>
      </categories>
      <tags>
        <tag>计算机系统原理</tag>
        <tag>异常控制流</tag>
      </tags>
  </entry>
  <entry>
    <title>07 链接</title>
    <url>/2019/07/24/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/07%20%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>本章的核心内容：</p>
<ol>
<li>如何把多个源代码文件合并成一个最终可执行的文件</li>
<li>符号（变量，函数等）的定义和声明在合并过程中的表现形式</li>
<li>了解<code>链接</code>过程中的<code>符号解析</code>和<code>重定位</code>的作用</li>
<li>了解<code>静态链接库</code>和<code>动态链接库</code>的区别</li>
</ol>
<h2 id="编译器驱动程序"><a href="#编译器驱动程序" class="headerlink" title="编译器驱动程序"></a>编译器驱动程序</h2><p>示例代码：</p>
<p><img src="/2019/07/24/系统原理/07 链接/01.png" alt="示例代码"></p>
<p><strong>源代码转换成可执行代码的步骤？</strong></p>
<ul>
<li>一步到位：gcc -Og -o prog main.c sum.c</li>
<li>预处理：gcc cpp main.c /tmp/main.i</li>
<li>编译：cc1 /tmp/main.i -Og -o /tmp/main.s</li>
<li>汇编：as -o /tmp/main.o /tmp/main.s</li>
<li>链接：ld -o prog /tmp/main.o /tmp/sum.o</li>
</ul>
<p><strong>链接在其中的作用？</strong></p>
<p>把多个源代码文件合并成一个最终可执行的文件</p>
<p><img src="/2019/07/24/系统原理/07 链接/02.png" alt="静态链接"></p>
<h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p><strong>链接器必须完成的两个主要任务？</strong></p>
<ol>
<li>符号解析</li>
<li>重定位<blockquote>
<p>现在不理解没关系，之后会详细的说明</p>
</blockquote>
</li>
</ol>
<h2 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h2><p><strong>目标文件有哪些类？</strong></p>
<ol>
<li>可重定位目标文件：需要在链接时和其他的可重定位目标文件合并为一个可执行的目标文件。</li>
<li>可执行的目标文件：可以直接加载到内存并执行</li>
<li>共享目标文件：一种特殊的可重定位目标文件，可以在加载或者运行时被动态的加载到内存中进行链接。</li>
</ol>
<h2 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h2><p>典型的可重新定位的目标文件（ELF）的格式？</p>
<p><img src="/2019/07/24/系统原理/07 链接/03.png" alt="可重定位目标文件"></p>
<h2 id="符号和符号表"><a href="#符号和符号表" class="headerlink" title="符号和符号表"></a>符号和符号表</h2><p><strong>符号表的意义？</strong></p>
<p>对于机器而言，没有变量和函数的区别，统称为符号。<br>所有在目标模块中引用到的符号都会记录在符号表中，同时关联该符号的定义位置（或者未定义）</p>
<p><strong>符号表在哪？都有哪些信息？</strong></p>
<p>符号表在.symtab节中<br>包含所有在目标模块中引用的符号<br>不包含局部变量</p>
<p><strong>符号表中的符号都有哪些类型？</strong></p>
<ol>
<li>全局符号：当前模块定义，可被其他模块引用</li>
<li>外部符号：其他模块定义，被当前模块引用</li>
<li>局部符号：由static修饰的全局变量，当前模块定义，不可被其他模块引用</li>
</ol>
<p><strong>符号表中每一条的格式？</strong></p>
<p><img src="/2019/07/24/系统原理/07 链接/04.png" alt="符号表条目"></p>
<p>section说明符号在哪一节中<br>有三个虚拟的节：</p>
<ol>
<li>UNDEF：未定义的符号</li>
<li>COMMON：未初始化的符号</li>
<li>ABS：不该被重定位的符号</li>
</ol>
<p>案例：readelf命令可以查看文件符号表</p>
<p><img src="/2019/07/24/系统原理/07 链接/05.png" alt="案例"></p>
<h2 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h2><p><strong>什么是符号解析？为什么需要符号解析？</strong></p>
<p>由于引用了外部定义的符号，所以在链接的时候需要从其他模块中寻找到符号的定义位置，并且关联起来<br>这个过程就叫做符号解析</p>
<p><strong>如何解析多重定义的全局变量？</strong></p>
<p>意思是：如果符号在多个地方被定义，如何解析？</p>
<p>根据符号的定义方式，分为：</p>
<ul>
<li>强符号：函数和已初始化的全局变量，或者未初始化的static符号</li>
<li>弱符号：未初始化的全局变量</li>
</ul>
<p>解析规则如下：</p>
<ol>
<li>不允许有多个同名的强符号</li>
<li>如果有一个强符号和多个弱符号同名，选择强符号</li>
<li>如果有多个弱符号，任意选择一个</li>
</ol>
<p><strong>符号表中section属性中COMMON和.bss区别体现在？</strong></p>
<p>COMMON：未初始化的全局变量，为弱符号<br>.bss：初始化为0的全局变量或者static变量，为强符号</p>
<p><strong>规则2和规则3造成的潜藏错误？</strong></p>
<p>未使用本模块中定义的符号，而修改了其他模块的符号<br>造成了未知的数据错误</p>
<p><strong>什么是静态库？为什么需要静态库？</strong></p>
<p>将所有相关的模块打包成一个单独的文件，称为静态库<br>如果没有静态库：</p>
<ol>
<li>每次都需要链接很多个模块，容易出错而且耗时</li>
<li>链接一个超大的模块（只会其中的一小部分），占用了不必要的空间，同样也耗时</li>
</ol>
<p>而使用静态库，目标文件会去静态库中找自己需要的模块</p>
<p><strong>如何创建静态库？</strong></p>
<p>使用ar命令，静态库以.a表示<br>ar rcs my.a main.o sum.o</p>
<p><strong>如何利用静态库来进行链接（链接的步骤）？</strong></p>
<p>链接器从左到右扫描所有的目标文件，维护三个集合：</p>
<ol>
<li>文件集合E：集合中的文件会合并</li>
<li>未解析的符号集合U</li>
<li>已定义的符号集合D</li>
</ol>
<p>链接过程：</p>
<ol>
<li>对于每个输入文件f，如果是可重定位文件，则添加到E中，修改U和D</li>
<li>如果是静态库，则尝试匹配U中的符号，如果匹配到，则把对应的模块加入到E中，修改U和D</li>
<li>结束时，如果U非空，则报错。否则，重定位E中的目标文件</li>
</ol>
<p><strong>链接静态库的顺序问题？</strong></p>
<p>链接器从左到右扫描，因此要确保需要的符号在后续目标文件中出现</p>
<h2 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h2><p><strong>为什么需要重定位？</strong></p>
<p>未合并的代码和数据内存位置都是不确切的，因此指令中的内存地址以及数据节的内存位置也无法确定<br>重定位的目的就是合并代码，并且确定内存地址<br><code>重定位条目</code>就是所有内存需要确定的地点</p>
<p><strong>重定位的步骤？</strong></p>
<ol>
<li>重定位节和符号定义：根据合并时的模块节和符号定义的相对未知进行重定位</li>
<li>重定位所有的符号引用：根据<code>重定位条目</code>进行重定位</li>
</ol>
<p><strong>重定位的地址计算？</strong></p>
<p><img src="/2019/07/24/系统原理/07 链接/06.png" alt="重定位条目"></p>
<p>ELF有32种多重定位类型，比如：</p>
<ol>
<li>R_X86_64_PC32：重定位一个使用32位PC相对地址的引用</li>
<li>R_X86_64_32：重定位一个使用32位绝对地址的引用</li>
</ol>
<p><img src="/2019/07/24/系统原理/07 链接/07.png" alt="重定位算法"></p>
<h2 id="可执行文件"><a href="#可执行文件" class="headerlink" title="可执行文件"></a>可执行文件</h2><p><strong>可执行文件的格式？</strong></p>
<p><img src="/2019/07/24/系统原理/07 链接/08.png" alt="可执行文件"></p>
<p><strong>可执行文件加载后的内存分布？</strong></p>
<p><img src="/2019/07/24/系统原理/07 链接/09.png" alt="可执行文件"></p>
<h2 id="加载可执行文件"><a href="#加载可执行文件" class="headerlink" title="加载可执行文件"></a>加载可执行文件</h2><p>加载器是内核代码，任何程序都可以通过execve函数调用。</p>
<ol>
<li>加载器创建虚拟空间</li>
<li>将可执行文件的片复制到代码段和数据段</li>
<li>加载器跳转到程序的入口_start函数（ctrl.o中定义）</li>
<li>_start函数调用系统启动函数__libc_start_main函数（libc.so中定义）</li>
<li>__libc_start_main函数初始化执行环境，调用用户层的Main函数</li>
</ol>
<blockquote>
<p>要理解加载的实际工作，需要理解进程、虚拟内存和内存映射的概念</p>
</blockquote>
<h2 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h2><p><strong>静态库的弊端？</strong></p>
<ol>
<li>静态库需要定期维护和更新，因此必须以某种方式了解到静态库的更新状态，然后显式的重新链接</li>
<li>对于每一个程序都会使用到的函数，比如printf和scanf，每一个进程都会去保存这一部分代码，这是对内存的一种浪费。</li>
</ol>
<p><strong>什么是动态共享库？</strong></p>
<p>一种特殊的目标模块，在程序加载或者运行时，加载到任意的内存地址，并与程序进行链接，是所有程序都可以共享的一段内存地址。</p>
<p><img src="/2019/07/24/系统原理/07 链接/10.png" alt="动态共享库"></p>
<p><strong>如何创建动态共享库和使用动态共享库？</strong></p>
<p>动态共享库文件以.so结尾<br>可以通过命令来进行创建和使用</p>
<p><strong>如何显式地使用动态共享库？</strong></p>
<p>通过命令进行动态链接是隐式的，将符号解析全部交给动态链接器，在程序加载到内存之后就完成符号解析。<br>在代码中声明链接称为显式链接，符号解析需要手动调用动态链接器开放出来的接口，在接口执行时才进行符号解析。<br>显式链接最大的好处就是：即便动态共享库更新了，也无需重新编译整个程序。</p>
<p>在目标模块变成可执行文件后，其指令就不允许被修改了，那么<strong>这种执行后（加载、运行）才进行链接的方式是如何实现的？</strong></p>
<h2 id="位置无关代码"><a href="#位置无关代码" class="headerlink" title="位置无关代码"></a>位置无关代码</h2><p><strong>动态链接共享库有哪些难点？</strong></p>
<p>最大的难点是动态共享库在内存中存在的位置<br>如果给动态共享库预留专用的地址空间，问题是即使这部分空间没被用到，也会被无故占用浪费。并且随着更新迭代不好管理。</p>
<p><strong>如何解决上述问题？</strong></p>
<p>需要一种方式，是的无论共享库放在内存中的哪个位置，它的代码段都可以被多个进程共享<br>这种链接时无需重定位，而可以加载的代码就是<code>位置无关代码(PIC)</code></p>
<p><strong>无需重定位意味着什么？</strong></p>
<p>不进行重定位意味着无法在链接时就确定内存地址（虚拟内存）</p>
<p><strong>位置无关代码需要解决的问题？</strong></p>
<p>共享模块只有加载后内存地址才能确定<br>也就是说共享模块只能将重定位（动态重定位）的过程放到加载之后<br><em>PIC加载之后如何进行重定位</em>，正是目前需要解决的问题</p>
<p><strong>PIC数据如何被引用？</strong></p>
<p>PIC的实现基于<em>数据段和代码段的距离总是不变</em>以及<em>数据段可以被修改</em>这两个特性</p>
<p>在数据段中创建一个表——<code>全局偏移量表(GOT)</code>——因而让表项的地址来作为“代替地址”<br>因为常见情形是PIC中引用其他PIC，所以这个“代替地址”一般也无法确定内存地址（绝对地址）<br>在链接时，如果发现引用了一个PIC中的数据，则先使用一个“代替地址”，这个“代替地址”最终一定能定位到正确的PIC数据地址</p>
<p><strong>GOT表中何时得到正确的地址呢？</strong></p>
<p>在生成GOT表项的同时，会生成一条动态重定位项<br>在加载时，动态链接器会根据动态重定位项去获取正确的PIC数据地址</p>
<p><img src="/2019/07/24/系统原理/07 链接/11.png" alt="PIC数据引用"></p>
<p><strong>PIC函数如何被引用？</strong></p>
<p>也需要使用到GOT表<br>除此之外，为了实现延迟加载（第一次调用时才加载），还需要用到<code>过程链接表(PLT)</code></p>
<p><img src="/2019/07/24/系统原理/07 链接/12.png" alt="GPT和PLT的协作"></p>
<h2 id="库打桩机制"><a href="#库打桩机制" class="headerlink" title="库打桩机制"></a>库打桩机制</h2><p>库打桩有什么用？</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://juejin.im/post/5a4b8e40f265da43231b5919" target="_blank" rel="noopener">图解重定位</a></li>
<li><a href="https://juejin.im/entry/5b0582dc6fb9a07aaa11a2bd" target="_blank" rel="noopener">位置无关代码案例分析</a></li>
<li><a href="https://www.zhihu.com/question/21249496" target="_blank" rel="noopener">为什么需要使用到GOT和PLT</a></li>
</ol>
]]></content>
      <categories>
        <category>计算机系统原理</category>
      </categories>
      <tags>
        <tag>计算机系统原理</tag>
        <tag>链接</tag>
      </tags>
  </entry>
  <entry>
    <title>12并发编程</title>
    <url>/2019/09/16/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/12%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><p>本章的核心内容：</p>
<ol>
<li>实现并发的三种方式（进程、IO复用、线程），以及他们的优缺点</li>
<li>如何使用信号量来处理资源互斥、共享问题</li>
<li>认识不安全和死锁的概念</li>
</ol>
<p><strong>并发在哪些情况下有用？</strong></p>
<ul>
<li>访问慢速I/O设备。</li>
<li>与人交互。</li>
<li>通过推迟工作以降低延迟。</li>
<li>服务多个网络客户端。</li>
<li>在多核机器上进行并行计算。</li>
</ul>
<p><strong>实现并发有哪些方式？</strong></p>
<ul>
<li>进程。用这种方法，每个逻辑控制流都是一个进程，由内核来调度和维护。因为进程有独立的虚拟地址空间，想要和其他流通信，控制流必须使用某种显式的进程间通信机制。</li>
<li>I/O多路复用。在这种形式的并发编程中，应用程序在一个进程的上下文中显式地调度它们自己的逻辑流。逻辑流被模型化为状态机，数据到达文件描述符后，主程序显式地从一个状态转换到另一个状态。因为程序是一个单进程，所以所有的流都共享同一地址空间。</li>
<li>线程。线程是运行在一个单一进程上下文中的逻辑流，由内核进行调度。你可以把线程看成是其他两种方式的混合体，像进程流一样由内核进行调度，而像I/O多路复用流一样共享同一虚拟地址空间。</li>
</ul>
<h2 id="基于进程的并发编程"><a href="#基于进程的并发编程" class="headerlink" title="基于进程的并发编程"></a>基于进程的并发编程</h2><p><strong>如何工作？</strong></p>
<p>构造并发编程最简单的方法就是用进程，使用那些大家都很熟悉的函数，像fork、exec和waitpid。</p>
<p>步骤：</p>
<ol>
<li>服务器监听一个监听描述符上的连接请求。</li>
<li>服务器接受了客户端1的连接请求，并返回一个已连接描述符。</li>
<li>在接受了连接请求之后，服务器派生一个子进程，这个子进程获得服务器描述符表的完整拷贝。子进程关闭它的拷贝中的监听描述符3，而父进程关闭它的已连接描述符4的拷贝，因为不再需要这些描述符了。</li>
<li>子进程正忙于为客户端提供服务，父进程继续监听新的请求。</li>
</ol>
<p><img src="/2019/09/16/系统原理/12并发编程/01.png" alt="基于进程的并发编程"></p>
<p><img src="/2019/09/16/系统原理/12并发编程/02.png" alt="基于进程的并发编程"></p>
<p>注意点：</p>
<ol>
<li>首先，通常服务器会运行很长的时间，所以我们必须要包括一个SIGCHLD处理程序，来回收僵死子进程的资源。因为当SIGCHLD处理程序执行时，SIGCHLD信号时阻塞的，而Unix信号时不排队的，所以SIGCHLD处理程序必须准备好回收多个僵死子进程的资源。</li>
<li>其次，子进程必须关闭它们各自的connfd拷贝。就像我们已经提到过的，这对父进程而言尤为重要，它必须关闭它的已连接描述符，以避免存储器泄漏。</li>
<li>最后，因为套接字的文件表表项中的引用计数，直到父子进程的connfd都关闭了，到客户端的连接才会终止。</li>
</ol>
<p><strong>优缺点？</strong></p>
<p>共享文件表，但是不共享用户地址空间。</p>
<ul>
<li>优点：不会出现“一个进程不可能不小心覆盖另一个进程的虚拟存储器”的问题</li>
<li>缺点：独立的地址空间使得进程共享状态信息变得更加困难。为了共享信息，它们必须使用显式的IPC（进程间通信）机制。基于进程的设计的另一个缺点是，它们往往比较慢，因为进程控制和IPC的开销很高。</li>
</ul>
<p>案例：<br><img src="/2019/09/16/系统原理/12并发编程/03.png" alt="基于进程的并发编程"></p>
<h2 id="基于I-O多路复用的并发编程"><a href="#基于I-O多路复用的并发编程" class="headerlink" title="基于I/O多路复用的并发编程"></a>基于I/O多路复用的并发编程</h2><p><strong>什么是I/O多路复用？</strong></p>
<p>Unix网络编程给IO分了5种IO模型，其中包含阻塞IO、非阻塞IO、IO多路复用：</p>
<ul>
<li>阻塞IO:进程发起IO系统调用后，进程被阻塞，转到内核空间处理，整个IO处理完毕后返回进程。操作成功则进程获取到数据。</li>
<li>非阻塞IO:进程发起IO系统调用后，如果内核缓冲区没有数据，需要到IO设备中读取，进程返回一个错误而不会被阻塞；进程发起IO系统调用后，如果内核缓冲区有数据，内核就会把数据返回进程。</li>
<li>IO多路复用: 多个的进程的IO可以注册到一个复用器（select）上，然后用一个进程调用该select， select会监听所有注册进来的IO；</li>
</ul>
<blockquote>
<p>更多详细参见：<a href="https://blog.csdn.net/tjiyu/article/details/52959418" target="_blank" rel="noopener">IO模型</a></p>
</blockquote>
<p><strong>什么是事件驱动程序？</strong></p>
<p>事件推动逻辑的执行，一般可以模型化状态机。</p>
<p><strong>工作方式？</strong></p>
<p>使用select</p>
<p><img src="/2019/09/16/系统原理/12并发编程/04.png" alt="O多路复用的并发编程"></p>
<p>优点：</p>
<ol>
<li>使用事件驱动编程，这样比基于进程的设计给了程序更多的对程序行为的控制。</li>
<li>一个基于I/O多路复用的事件驱动服务器是运行在单一进程上下文中的，因此每个逻辑流都访问该进程的全部地址空间。这使得在流之间共享数据变得很容易</li>
</ol>
<p>缺点：</p>
<ol>
<li>事件驱动设计的一个明星的缺点就是编码复杂。我们的事件驱动的并发服务器需要比基于进程的多三倍。</li>
<li>不能充分利用多核处理器。</li>
</ol>
<h2 id="基于线程的并发编程"><a href="#基于线程的并发编程" class="headerlink" title="基于线程的并发编程"></a>基于线程的并发编程</h2><p><strong>使用线程的好处？</strong></p>
<ol>
<li>因为一个线程的上下文要比一个进程的上下文小很多，线程的上下文切换要比进程的上下文切换快得多。</li>
<li>每个对等线程都能读写相同的共享数据</li>
</ol>
<p><img src="/2019/09/16/系统原理/12并发编程/05.png" alt="线程并发执行"></p>
<p>api：</p>
<ul>
<li>pthread_create()：创建一个线程</li>
<li>pthread_exit()：终止当前线程</li>
<li>pthread_cancel()：请求中断另外一个线程的运行。</li>
<li>pthread_join()：阻塞当前的线程，直到另外一个线程运行结束</li>
<li>pthread_detach()：分离线程，分离后不需要被其他线程回收，终止时自行回收</li>
</ul>
<p>案例：</p>
<p><img src="/2019/09/16/系统原理/12并发编程/06.png" alt="线程并发执行"></p>
<h2 id="多线程程序中的共享变量"><a href="#多线程程序中的共享变量" class="headerlink" title="多线程程序中的共享变量"></a>多线程程序中的共享变量</h2><p><strong>线程的基础内存内存模型是什么？</strong></p>
<p>一组并发线程运行在一个进程的上下文中。  每个线程都有它自己独自的线程上下文，包括线程ID、栈、栈指针、程序计数器、条件码和通用目的寄存器值。每个线程和其他线程一起共享进程上下文的剩余部分。这包括整个用户虚拟地址空间，它是由只读文本（代码）、读/写数据、堆以及所有的共享库代码和数据区域组成的。线程也共享同样的打开文件的集合。</p>
<p>各自独立的线程栈的存储器模型不是那么整齐清楚的。这些栈被保存在虚拟地址空间的栈区域中，并且通常是被相应的线程独立地访问的。我们说通常而不是总是，是因为不同的线程栈是不对其他线程设防的。所以，如果一个线程以某种方式得到一个指向其他线程栈的指针，那么它就可以读写这个栈的任何部分。</p>
<p><strong>根据这个模型，变量实例是如何映射到内存的？</strong></p>
<ul>
<li>全局变量：定义在函数之外的变量。在运行时，虚拟存储器的读/写区域只包含每个全局变量的一个实例，任何线程都可以引用。</li>
<li>本地自动变量：定义在函数内部但是没有static属性的变量。在运行时，每个线程的栈都包含它自己的所有本地自动变量的实例。即使当多个线程执行同一个线程例程时也是如此。</li>
<li>本地静态变量：定义在函数内部并有static属性的变量。和全局变量一样，虚拟存储器的读/写区域只包含在程序中声明的每个本地静态变量的一个实例。</li>
</ul>
<p><strong>有多少线程引用这些实例？</strong></p>
<p>一个变量是共享的，当且仅当它的一个实例被一个以上的线程引用。</p>
<h2 id="用信号量同步线程"><a href="#用信号量同步线程" class="headerlink" title="用信号量同步线程"></a>用信号量同步线程</h2><p><strong>共享变量带来的问题？</strong></p>
<p>共享变量引入了同步错误。</p>
<p>譬如下面一段代码：i++（注意这不是一个原子操作）</p>
<p><img src="/2019/09/16/系统原理/12并发编程/07.png" alt="同步问题代码"></p>
<p><img src="/2019/09/16/系统原理/12并发编程/08.png" alt="同步问题"></p>
<p><strong>如何分析同步错误的问题？</strong></p>
<p>可以使用线程进度图来分析，如下：</p>
<p><img src="/2019/09/16/系统原理/12并发编程/09.png" alt="进度图"></p>
<p>对每个线程而言，操作共享变量的指令区间叫做<code>临界区</code><br>两个临界区的交集称作<code>不安全区</code></p>
<p><img src="/2019/09/16/系统原理/12并发编程/10.png" alt="不安全区"></p>
<p><strong>什么是信号量？</strong></p>
<p>信号量是一个非负整数，关键在于对信号量的操作（增减）是原子的</p>
<p><strong>如何使用信号量解决同步问题？</strong></p>
<p>只用0和1两种值的信号量叫二元信号量，也叫互斥锁<br>用互斥锁把临界区代码包起来</p>
<p><img src="/2019/09/16/系统原理/12并发编程/11.png" alt="信号量"></p>
<p>上面的代码使得线程的轨迹无法进入不安全区</p>
<p><img src="/2019/09/16/系统原理/12并发编程/12.png" alt="禁止区"></p>
<p><strong>如何使用信号量来处理共享资源的访问问题？</strong></p>
<p>信号量&gt;1</p>
<p><strong>生产者——消费者问题？</strong></p>
<p><img src="/2019/09/16/系统原理/12并发编程/13.png" alt="生产者——消费者问题"></p>
<p>有限缓存抽象如下：<br><img src="/2019/09/16/系统原理/12并发编程/14.png" alt="有限缓存"></p>
<p>生产和消费方式如下：<br><img src="/2019/09/16/系统原理/12并发编程/15.png" alt="生产——消费"></p>
<p><strong>读者——写者问题？</strong></p>
<p>修改对象的线程叫做写者；只读对象的线程叫做读者。<br>写着必须拥有对对象的独占访问，而读者可以和无限多个其他读者共享对象。</p>
<p>分两类：</p>
<ul>
<li>读者优先，要求不要让读者等待，除非已经把使用对象的权限赋予了一个写者。</li>
<li>写者优先，要求一定能写者准备好可以写，它就会尽可能地完成它的写操作。</li>
</ul>
<p>第一类解决方案如下：</p>
<p><img src="/2019/09/16/系统原理/12并发编程/16.png" alt="读者优先"></p>
<p><strong>什么是饥饿？</strong></p>
<p>线程无限制阻塞，无法进展。比如上面的写者就有可能永远拿不到锁</p>
<h2 id="综合：基于预线程化的并发服务器"><a href="#综合：基于预线程化的并发服务器" class="headerlink" title="综合：基于预线程化的并发服务器"></a>综合：基于预线程化的并发服务器</h2><p><strong>什么是预线程化？</strong></p>
<p><img src="/2019/09/16/系统原理/12并发编程/17.png" alt="预线程化"></p>
<p>案例：</p>
<h2 id="使用线程提高并行性"><a href="#使用线程提高并行性" class="headerlink" title="使用线程提高并行性"></a>使用线程提高并行性</h2><p><strong>顺序、并发、并行之间是什么关系？</strong></p>
<p><img src="/2019/09/16/系统原理/12并发编程/18.png" alt="顺序、并发、并行"></p>
<p><strong>多线程在多核下的性能一定更好吗？</strong></p>
<p>多核下同步操作的性能消耗更大，因此要尽可能避免</p>
<p><strong>线程越多性能越好吗？</strong></p>
<p><img src="/2019/09/16/系统原理/12并发编程/19.png" alt="刻画并行程序的性能"></p>
<p>时间上升，是因为没有阻塞的环境下，一个核的多线程上下文切换导致<br>所以，并行程序常常是每个核一个线程</p>
<h2 id="其他并发问题"><a href="#其他并发问题" class="headerlink" title="其他并发问题"></a>其他并发问题</h2><p><strong>什么是线程不安全的？</strong></p>
<p>一个函数被称为线程安全的，当且仅当被多个并发线程反复地调用时，它会一直产生正确的结果。如果一个函数不是线程安全的，我们就说它是线程不安全的。</p>
<p><strong>线程不安全的函数类有哪些？**</strong></p>
<ol>
<li>不保护共享变量的函数。</li>
<li>保持跨越多个调用的状态的函数。如伪随机数生成器</li>
<li>返回指向静态变量的指针的函数。</li>
<li>调用线程不安全函数的函数。</li>
</ol>
<p>解决方案：除了第二种必须修改源码外：其余的都可以采用“加锁-拷贝技术”：线程不安全函数与互斥锁联系起来，在每一个调用位置，对互斥锁加锁，调用线程不安全函数，将函数返回的结果拷贝到一个私有的存储器位置，然后对互斥锁解锁。</p>
<p><strong>什么是可重入函数？和线程安全函数有啥区别？</strong></p>
<p>当它们被多个线程调用时，不会引用共享数据。</p>
<p><img src="/2019/09/16/系统原理/12并发编程/20.png" alt="可重入函数"></p>
<p><strong>如何通过线程进程图来判断死锁？</strong></p>
<p><img src="/2019/09/16/系统原理/12并发编程/21.png" alt="死锁进度图"></p>
<p><strong>避免死锁的加锁规则？</strong></p>
<p>每个线程都是以相同的顺序获得互斥锁</p>
<blockquote>
<p>上面结论有证实</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机系统原理</category>
      </categories>
      <tags>
        <tag>计算机系统原理</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>09 虚拟内存</title>
    <url>/2019/08/27/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/09%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p>本章的核心内容：</p>
<ol>
<li>虚拟内存是如何工作的</li>
<li>应用程序如何使用和管理虚拟内存</li>
</ol>
<h2 id="物理和虚拟寻址"><a href="#物理和虚拟寻址" class="headerlink" title="物理和虚拟寻址"></a>物理和虚拟寻址</h2><p><strong>虚拟寻址的简单过程？</strong></p>
<p>CPU中的内存管理单元（MMU）利用存放在主存中的查询表来动态翻译虚拟地址</p>
<p><img src="/2019/08/27/系统原理/09 虚拟内存/01.png" alt="简单的虚拟寻址系统"></p>
<h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><p><strong>如何理解虚拟地址和物理地址的区别？</strong></p>
<p>物理地址是实际的物理内存空间地址<br>虚拟地址是利用磁盘生成的逻辑内存空间</p>
<p><strong>为什么需要引入虚拟内存的机制？</strong></p>
<p>没有虚拟内存，程序员需要自己去管理物理地址，因此每次都需要人为地去计算和分配地址，这是一项复杂而且繁琐的工作。<br>虚拟内存的好处有：</p>
<ol>
<li>让主存作为虚拟内存的缓存，更好的发挥稀缺的主存空间的作用</li>
<li>虚拟内存把内存的管理交给操作系统，不需要程序员去分配内存，提高了工作的效率和内存的安全。</li>
<li>固定的虚拟内存空间简化了程序的编译、链接、加载等等</li>
</ol>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p><strong>什么是虚拟内存？</strong></p>
<p>概念上来说，虚拟内存是一个存放在磁盘上N个连续字节大小的数组。<br>这个数组的内容被缓存在主存中</p>
<p><strong>如何理解虚拟页的存在？</strong></p>
<p>和其他缓存一样，数据被分割为块来作为传输单元<br>虚拟页中的块也被称为虚拟页(VP)<br>与之在主存上对应的叫物理页(PP)</p>
<blockquote>
<p>虚拟内存的出现比缓存要早，所以这里延续传统，并没有使用虚拟块</p>
</blockquote>
<p><strong>虚拟页的三种不相交状态是？</strong></p>
<ul>
<li>未分配：虚拟内存中未分配（未使用，没有任何数据关联）的页</li>
<li>未缓存：虚拟内存中已分配的页</li>
<li>已缓存：缓存在主存的已分配虚拟空间</li>
</ul>
<p><strong>如何区分SRAM和DRAM？</strong></p>
<p>为了区分不同的缓存</p>
<ul>
<li>SRAM：L1,L2,L3高速缓存</li>
<li>DRAM：虚拟内存的缓存——主存</li>
</ul>
<p><strong>DRAM为什么不命中处罚很大？</strong></p>
<p>DRAM比SRAM慢10倍<br>读写磁盘要比DRAM慢大约100000多倍</p>
<p><strong>DRAM为了减少不命中处罚的手段？</strong></p>
<ol>
<li>采用较大的块（虚拟页）</li>
<li>DRAM采用全相联的方式（没有组之间的区别）</li>
<li>采用更复杂精密的替换算法</li>
<li>DRAM总是采用写回的方式</li>
</ol>
<p><strong>如何管理虚拟内存在DRAM中的缓存（是否命中，地址转换，替换策略）？</strong></p>
<p>使用<code>页表</code>进行管理<br>页表是虚拟页和物理页的一个映射关系，除此还可以维护页的其他属性。<br>虚拟页的每一页都对应页表中的一个条目（PTE）</p>
<p><strong>条目与虚拟页三种状态的对应？</strong></p>
<ol>
<li>有效位为1：已缓存</li>
<li>有效位为0，空地址：表示未分配页</li>
<li>有效位为0，有数据：表示未缓存</li>
</ol>
<p><img src="/2019/08/27/系统原理/09 虚拟内存/02.png" alt="页表"></p>
<p><strong>如何处理命中、缺页？</strong></p>
<p><img src="/2019/08/27/系统原理/09 虚拟内存/03.png" alt="页命中"></p>
<p>命中未缓存的表条目叫做<code>缺页</code></p>
<p><img src="/2019/08/27/系统原理/09 虚拟内存/04.png" alt="缺页"></p>
<p><img src="/2019/08/27/系统原理/09 虚拟内存/05.png" alt="缺页异常处理"></p>
<p><strong>为什么虚拟内存需要读写磁盘，性能反而更好？</strong></p>
<p>良好的局部性是缓存良好工作的唯一保证</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p><strong>虚拟页如何简化了内存的管理？</strong></p>
<ol>
<li>简化链接：独立的内存空间简化了链接器的设计和实现，固定的内存格式（如代码段总是从虚拟地址0x400000开始），把实际物理地址的分配问题交给底层，专注于链接的算法。链接完成时即可确定部分静态的内存地址</li>
<li>简化加载：更容易加载可执行文件和共享对象文件，只需要分配目标文件中固定的节即可</li>
<li>简化内存分配： 用户不需要通过实际的物理内存去计算空闲内存，让这些都交给操作系统去实现</li>
</ol>
<h2 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h2><p><strong>如何进行内存的保护？</strong></p>
<p>PTE中有3个权限字段，控制读、写和访问</p>
<p><img src="/2019/08/27/系统原理/09 虚拟内存/06.png" alt="内存保护"></p>
<h2 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h2><p><strong>如何从虚拟地址转换成物理地址？</strong></p>
<p><img src="/2019/08/27/系统原理/09 虚拟内存/07.png" alt="地址翻译"></p>
<p><strong>页面命中时如何转换？</strong></p>
<p><img src="/2019/08/27/系统原理/09 虚拟内存/08.png" alt="页面命中"></p>
<p><strong>缺页时如何转换？</strong></p>
<p><img src="/2019/08/27/系统原理/09 虚拟内存/09.png" alt="缺页"></p>
<p><strong>地址转换如何和高速缓存结合？</strong></p>
<p><img src="/2019/08/27/系统原理/09 虚拟内存/10.png" alt="VM与高速缓存的结合"></p>
<p><strong>如何进一步减小地址转换的开销？</strong></p>
<p>在MMU中建立一个PTE的缓存，称为<code>翻译后备缓存器（TLB）</code><br>和一般的缓存一样，采用组相联的方式<br>使用VPN进行索引</p>
<p><img src="/2019/08/27/系统原理/09 虚拟内存/11.png" alt="TLB"></p>
<p><img src="/2019/08/27/系统原理/09 虚拟内存/12.png" alt="TLB命中和不命中"></p>
<p><strong>如何減少页表占用的内存空间？</strong></p>
<p>一个32位的虚拟空间，4KB的页大小，4字节的PTE<br>那么每个进程都需要一个4MB的页表<br>这样下去内存还是吃不消</p>
<p>常见的压缩方式是采用层次结构的页表</p>
<p><img src="/2019/08/27/系统原理/09 虚拟内存/13.png" alt="多级页表"></p>
<ol>
<li>如果上级页表中的PTE是空的，那么相应的二级页表就不存在</li>
<li>只有一级页表才总需要在主存中，其他级页表按需调入调出</li>
</ol>
<p><strong>多级页表如何寻址？</strong></p>
<p>MMU必须访问多个PTE</p>
<p><img src="/2019/08/27/系统原理/09 虚拟内存/14.png" alt="多级页表的寻址"></p>
<p><strong>这种空间的压缩导致了更多次的内存访问，需要付出多少的时间代价？</strong></p>
<p>由于不同层次的PTE都可以在TLB中缓存<br>所以多级页表的地址翻译并不会比单级页表慢很多</p>
<p>综合：案例分析</p>
<h2 id="实际案例研究——运行linux的intel-core-i7"><a href="#实际案例研究——运行linux的intel-core-i7" class="headerlink" title="实际案例研究——运行linux的intel core i7"></a>实际案例研究——运行linux的intel core i7</h2><p><strong>core i7的地址翻译？</strong></p>
<p><strong>Linux的虚拟内存结构？</strong></p>
<p><img src="/2019/08/27/系统原理/09 虚拟内存/15.png" alt="一个Linux进程的虚拟内存"></p>
<p><strong>Linux如何组织虚拟内存？</strong></p>
<p>Linux使用区域（段）来组织虚拟内存<br>Linux为每个进程都维护这一个任务结构（task_struct源码）</p>
<p><img src="/2019/08/27/系统原理/09 虚拟内存/16.png" alt="Linux使用区域（段）来组织虚拟内存"></p>
<p>Linux在进程的上下文中维护</p>
<p><strong>Linux中使用区域组织虚拟内存的意义？</strong></p>
<ol>
<li>将功能相同的虚拟页组织起来</li>
<li>允许虚拟地址空间有空隙，不需要去记录不存在数据的虚拟页</li>
<li>记录了每个区域的权限</li>
</ol>
<p><strong>Linux中如何处理缺页？</strong></p>
<p><img src="/2019/08/27/系统原理/09 虚拟内存/17.png" alt="Linux缺页"></p>
<h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p><strong>什么是内存映射？</strong></p>
<p>将一个虚拟内存区域和磁盘上的对象关联起来，以初始化虚拟内存区域的内容，这个过程就叫<code>内存映射</code><br>可以简单的理解为初始化虚拟内存</p>
<p><strong>哪些硬盘对象可以进行内存映射？</strong></p>
<ol>
<li>普通文件对象（包括之前说的可执行文件），按需调度（发生缺页时才放到物理内存中）</li>
<li>匿名文件：由内核创建，当引用到匿名文件的虚拟页时，只会用二进制零覆盖牺牲页（如果牺牲页有修改，则换出），然后更新页表，不会有实际的数据传输，所以也叫请求二进制零的页。</li>
</ol>
<p><strong>如何管理共享对象的虚拟内存？</strong></p>
<p><img src="/2019/08/27/系统原理/09 虚拟内存/18.png" alt="共享对象"></p>
<p><strong>如何管理私有对象的虚拟内存？</strong></p>
<p><img src="/2019/08/27/系统原理/09 虚拟内存/19.png" alt="私有对象"></p>
<p><strong>fork函数如何管理虚拟内存？</strong></p>
<p>fork之后，拷贝原进程的虚拟空间，并将两个进程的虚拟页都设置为只读，写时复制</p>
<p><strong>execve函数如何管理虚拟内存？</strong></p>
<ol>
<li>删除已经在的用户区域</li>
<li>映射私有区域（新程序的代码、数据、bss和栈区域）</li>
<li>映射共享区域</li>
<li>设置程序计数器（PC）:指向代码区域的入口点</li>
</ol>
<p><img src="/2019/08/27/系统原理/09 虚拟内存/20.png" alt="加载器内存映射"></p>
<p>用户级内存映射：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* start:内存中的建议起始位置</span><br><span class="line">* length:分配长度</span><br><span class="line">* prot:内存权限</span><br><span class="line">* flags:对象类型（匿名？私有？写时复制？）</span><br><span class="line">* fd:文件（0表示匿名对象文件）</span><br><span class="line">* offset:文件偏移</span><br><span class="line">*/</span><br><span class="line">void mmap(void *start,  size_t length, int prot, int flags, int fd, off_t offset);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* start:内存中的开始位置</span><br><span class="line">* length:长度</span><br><span class="line">*/</span><br><span class="line">int munmap(voit *start, size_t length);</span><br></pre></td></tr></table></figure>
<h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><p><strong>什么是动态内存分配器？</strong></p>
<p>动态内存分配器维护一个进程的虚拟内存区域，称为堆<br>堆中分为不同大小的块来进行管理<br>有已分配和空闲两种状态</p>
<p><strong>为什么要使用动态分配？</strong></p>
<p>使用动态内存分配管理堆更方便，也有更好的可移植性。</p>
<p>分配器有两种风格：</p>
<ul>
<li>显式分配器：要求应用显式的释放已分配块</li>
<li>隐式分配器：分配器检查无用块并释放</li>
</ul>
<p>相关细节：</p>
<ol>
<li>mallco要求的内存过大，返回null并设置errno</li>
<li>mallco不初始化，初始化调用calloc</li>
<li>重新分配调用realloc</li>
</ol>
<p><strong>动态内存分配的要求和目标？</strong></p>
<p>要求：</p>
<ol>
<li>分配请求必须有相应的释放请求</li>
<li>分配请求需要立即执行，不允许重新排列或者缓存</li>
<li>只操作堆空间</li>
<li>对齐块</li>
<li>不允许修改已分配块</li>
</ol>
<p>目标：</p>
<ol>
<li>单位时间内完成的请求数尽可能多</li>
<li>堆的利用率尽可能大（已分配块的有效负载占比尽可能多）</li>
</ol>
<p>什么是外部碎片和内部碎片？</p>
<ul>
<li>内部碎片：已分配块大小和有效负载大小之差</li>
<li>外部碎片：分散的空闲块</li>
</ul>
<p><strong>实现动态分配器需要考虑哪些问题？</strong></p>
<ol>
<li>空闲块组织：我们如何记录空闲块？</li>
<li>放置：我们如何选择一个合适的空闲块来放置一个新分配的块？</li>
<li>分割：在我们将一个新分配的块放置到某个空闲块之后，我们如何处理这个空闲块中的剩余部分？</li>
<li>合并：我们如何处理一个刚刚被释放的块？</li>
</ol>
<p><strong>如何记录空闲块？</strong></p>
<p><img src="/2019/08/27/系统原理/09 虚拟内存/21.png" alt="一个简单的堆块的结构"></p>
<ol>
<li>一个块由字的头部、有效载荷以及可能的额外的填充组成。</li>
<li>头部编码了这个块的大小（包括头部和所有的填充）以及该块的状态（已分配或者空闲的）。</li>
<li>上图显示的是该块强加了一个双子的对齐约束条件（一个字为2B），该块的大小就总是8的倍数，则块大小的最低3位总是0。</li>
<li>这里的填充有两个原因：<ul>
<li>分配器的策略，用于对抗外部碎片。</li>
<li>满足对齐要求。</li>
</ul>
</li>
</ol>
<p><img src="/2019/08/27/系统原理/09 虚拟内存/22.png" alt="隐式空闲链表"></p>
<ol>
<li>空闲块是通过头部中的大小字段隐含地连接着的。</li>
<li>后面的已分配但是大小为0的头部做为隐式链表的结尾标志。</li>
</ol>
<p><img src="/2019/08/27/系统原理/09 虚拟内存/23.png" alt="显式式空闲链表"></p>
<p>每个空闲块中，都包含一个前驱和后继指针</p>
<p><strong>如何放置新的请求块？</strong></p>
<p>放置策略：</p>
<ol>
<li>首次适配：从头开始搜索空间链表，选择第一个合适的空闲块。</li>
<li>下一次适配：和首次适配很相识，只不过不是链表开始出开始每次搜索，而是从上一次查询结束的地方开始。</li>
<li>最佳适配：搜索每一个空闲块，选择合适所需请求大小的最小空闲块。</li>
</ol>
<p>优点：</p>
<ol>
<li>首次优点：将大的空间块保留在列表的后面，缺点：靠近列表起始处留下空闲块的碎片，增加了对较大块的搜索时间。</li>
<li>下次：knuth提出，比首次运行快一些，尤其是列表前面布满许多小的碎片时，然而下次比首次利用率要低得多。</li>
<li>最佳：利用率最高，但由于对堆的彻底的搜索，时间复杂度高；</li>
</ol>
<p><strong>如何分割空闲块？</strong></p>
<p>一旦分割器找到一个匹配的空闲块，他就必须做另一个决定，那就是分配这个 空闲块中多少空间，一个是选择整个空间，简单快捷，但缺点是内部碎片，如果放置策略趋于产生好的匹配，额外的内部碎片可以接受；</p>
<p>然而，如果匹配的不太好，那么分配器通常会选择讲这个空间块分割为两个部分，一个部分为分配块，另外变成一个空的空闲块。</p>
<p><strong>如果分配器不能为请求找到合适的空闲块将发生什么？</strong></p>
<p>为了解决假碎片的问题，任何实际的分配器都必须合并相邻的空闲块，这个过程叫做合并，这就出现一个重要策略决定，也就是在每次一个块释放时，就合并所有的空闲块？还是推迟合并，知道某个请求分配失败，然后再去扫描整个堆，合并所有空闲块。</p>
<p><strong>合并后的内存块也不够用怎么办？</strong></p>
<p>然而这样还是不能得到足够大的块，分配器就会想内核请求额外的堆空间。</p>
<h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p><img src="/2019/08/27/系统原理/09 虚拟内存/24.png" alt="可达图"></p>
<ul>
<li>堆节点：已分配块</li>
<li>根节点：寄存器中的变量、栈中的变量、虚拟内存读写区域的全局变量</li>
</ul>
<p><strong>分配的内存未回收会有什么影响？</strong></p>
<p>内存将不够</p>
<p><strong>简要描述标记&amp;清理回收算法？</strong></p>
<p><img src="/2019/08/27/系统原理/09 虚拟内存/25.png" alt="算法函数"><br><img src="/2019/08/27/系统原理/09 虚拟内存/26.png" alt="伪代码"><br><img src="/2019/08/27/系统原理/09 虚拟内存/27.png" alt="示例"></p>
<p><strong>C中的标记&amp;回收算法有什么难题？</strong></p>
<p>C无法区别是指针还是一个常量</p>
<h2 id="C中常见的与内存相关的问题"><a href="#C中常见的与内存相关的问题" class="headerlink" title="C中常见的与内存相关的问题"></a>C中常见的与内存相关的问题</h2>]]></content>
      <categories>
        <category>计算机系统原理</category>
      </categories>
      <tags>
        <tag>计算机系统原理</tag>
        <tag>虚拟内存</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式模式</title>
    <url>/2020/05/11/Design%20Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><blockquote>
<p>提供一个方法顺序的访问一个聚合对象中的各个元素，而不暴露其内部的表示。</p>
</blockquote>
<p><img src="/2020/05/11/Design Patterns/设计模式/设计模式Png/迭代器模式结构图.png" alt="迭代器模式结构图" style="zoom: 50%;"></p>
<ul>
<li><p>Aggregate接口：需要遍历的对象的“集合”（抽象）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> iterator <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Iterator：遍历的方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>迭代器模式的意义？</strong></p>
<p>把存取数据的结构和遍历数据的方式分离开，使得使用者无需关注我是使用什么存储结构而可以遍历我的对象。<br>通俗点说，考虑这样两个对象：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AMenu</span></span>&#123;</span><br><span class="line">  ArrayList&lt;Food&gt; menu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMenu</span></span>&#123;</span><br><span class="line">  Food[] menu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>传统的遍历方式，现在有一个服务员，需要打印两个菜单：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Waitress</span></span>&#123;</span><br><span class="line">  AMenu A = <span class="keyword">new</span> AMenu();</span><br><span class="line">  BMenu B = <span class="keyword">new</span> BMenu();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">printMenu</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//遍历两个菜单中的数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有两个问题：</p>
<ol>
<li>Waitress可以直接访问菜单对象中的数据，不满足封装的定义。</li>
<li>对于两个菜单就需要写两种遍历方式，增加菜单就需要再增加遍历的方法，不符合开闭原则，这是一段易变的代码，应该抽取出来。</li>
<li>上述创建对象的方式不对，不符合依赖转置原则，应该面对接口编程，同时可以使用工厂模式来处理易变代码。</li>
</ol>
<p>对于遍历的部分，就可以使用迭代器模式进行优化。</p>
<p>优化后：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AMenu</span></span>&#123;</span><br><span class="line">  ArrayList&lt;Food&gt; menu;</span><br><span class="line">  <span class="function">Iterator <span class="title">iterator</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMenu</span></span>&#123;</span><br><span class="line">  Food[] menu;</span><br><span class="line">  <span class="function">Iterator <span class="title">iterator</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Waitress</span></span>&#123;</span><br><span class="line">  AMenu A = <span class="keyword">new</span> AMenu();</span><br><span class="line">  BMenu B = <span class="keyword">new</span> BMenu();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">printMenu</span><span class="params">()</span></span>&#123;</span><br><span class="line">    print(A.iterator());</span><br><span class="line">    print(B.iterator());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Iterator it)</span></span>&#123;</span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码还可以优化，每个菜单都要打印一次，不符合开闭原则，不如把所用菜单放到List中，再使用一次迭代器。</p>
<p><strong>如何菜单中又有菜单，如何遍历每一个菜品？</strong></p>
<p>想象一下这个菜单类，他既拥有菜品类，又有本类。如何设计？如何遍历？<br>难道说，需要每次都使用If判断一下所调用的对象类型么？这样处理无论是在新增菜品，还是在遍历菜单的时候都会非常的麻烦。</p>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p><img src="/2020/05/11/Design Patterns/设计模式/设计模式Png/建造者模式结构图.png" alt="建造者模式结构图" style="zoom:80%;"></p>
<p><strong>如何理解“构建”和“表示”</strong></p>
<p>构建表示：创建一个对象组件的过程<br>表示：将组件按各种规则组合后的最终产品</p>
<p><strong>不使用建造者模式会有什么问题？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">createPaersonA()&#123;</span><br><span class="line">    Person A = <span class="keyword">new</span> Person();</span><br><span class="line">    buildHead(A);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>表示一个作用于某对象结构中的各元素的操作，可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
<ol>
<li>解耦数据结构和操作（算法），使得操作易扩展</li>
<li>适用于数据结构比较固定，操作异变</li>
</ol>
<p><img src="/2020/05/11/Design Patterns/设计模式/设计模式Png/访问者模式结构图.png" alt="访问者模式结构图" style="zoom:80%;"></p>
<h3 id="概念分析"><a href="#概念分析" class="headerlink" title="概念分析"></a>概念分析</h3><p>实现男人和女人在不同行为下的不同社会舆论：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BasePerson</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String action;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> action;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BasePerson <span class="title">setAction</span><span class="params">(String action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.action = action;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getConclusion</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">BasePerson</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getConclusion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(getAction().equals(<span class="string">"成功"</span>))&#123;</span><br><span class="line">         <span class="comment">//100行代码</span></span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span>(getAction().equals(<span class="string">"失败"</span>))&#123;</span><br><span class="line">         <span class="comment">//100行代码</span></span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span>(getAction().equals(<span class="string">"恋爱"</span>))&#123;</span><br><span class="line">         <span class="comment">//100行代码</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">BasePerson</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getConclusion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(getAction().equals(<span class="string">"成功"</span>))&#123;</span><br><span class="line">          <span class="comment">//100行代码</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(getAction().equals(<span class="string">"失败"</span>))&#123;</span><br><span class="line">          <span class="comment">//100行代码</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(getAction().equals(<span class="string">"恋爱"</span>))&#123;</span><br><span class="line">          <span class="comment">//100行代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题：每增加一种新的行为（如结婚），男人的女人的数据结构中的行为代码就需要进行一定的修改，不符合开闭原则</p>
<p>第一次改进：使用行为类来实现</p>
<p><img src="/2020/05/11/Design Patterns/设计模式/设计模式Png/访问者模式类图.png" alt="访问者模式结构图" style="zoom: 50%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getConclusionForMan</span><span class="params">(Man man)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getConclusionForWoman</span><span class="params">(Woman woman)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Action action)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Success</span> <span class="keyword">extends</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getConclusionForMan</span><span class="params">(Man man)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getConclusionForWoman</span><span class="params">(Woman woman)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Action action)</span> </span>&#123;</span><br><span class="line">        action.getConclusionForMan(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Action action)</span> </span>&#123;</span><br><span class="line">        action.getConclusionForWoman(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectStruct</span> </span>&#123;</span><br><span class="line">    List&lt;Person&gt; people = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        people.add(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        people.remove(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Action action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Person person : people) &#123;</span><br><span class="line">            person.accept(action);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好处：如果要增加对“结婚”对比，只需要增加“结婚”的行为类，不需要改动以往的任何类的代码。</p>
<p><strong>访问者模式的局限（或者说使用范围）？</strong></p>
<p>如上面例子中，如果人的性别不只是男女，而是更多，那么每一个Action中都需要增加对应的操作，显然不符合开闭原则。因此，访问者的使用方位是访问的对象（这里称为数据结构）需要是比较稳定。</p>
<p><strong>为什么需要使用访问者模式？</strong></p>
<p>访问者模式的目的是将处理方法从数据中分离出来，分为<code>数据结构</code>和<code>访问者（操作）</code>，很多系统都可以按照算法和数据结构分开，数据结构是比较稳定的，而算法易于变化，这时使用访问者模式就非常合适。</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p><strong>工厂模式解决什么问题？</strong></p>
<p>解决“new”的具体对象生成方式。<br>工厂的意义就是把创建的过程封装起来，把对象的生成和使用分离开来。<br>客户不关心生产过程，只在乎结果。<br>生活中也常常将生产和使用分开，因为彼此有不同的收益。</p>
<p><strong>new有什么问题？</strong></p>
<p>new实际上是一种硬编码，是代码中易变的一部分，不符合两个设计原则：</p>
<ol>
<li>把易变的部分独立出来。</li>
<li>代码应该对修改关闭，对扩展打开。</li>
</ol>
<p>这两个原则都意味着 new 是一种不太好的方式</p>
<p><strong>不适用工厂会有什么问题？</strong></p>
<p>接下里分析一些案例代码来进一步体会：</p>
<p>问题代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPizza</span> </span>&#123;</span><br><span class="line">    <span class="function">Pizza <span class="title">orderPizza</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Pizza pizza;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">"cheese"</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"pepperoni"</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> PepperoniPizza();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.bos();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的问题是，没有对修改关闭。</p>
<p><strong>如何第一次优化？</strong></p>
<p>把易变的部分提取出来封装:</p>
<h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line">    SimplePizzaFactory factory = <span class="keyword">new</span> SimplePizzaFactory();</span><br><span class="line">    <span class="function">Pizza <span class="title">orderPizza</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Pizza pizza = factory.creatPizza(type);</span><br><span class="line"></span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.bos();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimplePizzaFactory</span></span>&#123;</span><br><span class="line">    <span class="function">Pizza <span class="title">creatPizza</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        Pizza pizza;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">"cheese"</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"pepperoni"</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> PepperoniPizza();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的方法叫做简单工厂，并不属于一种设计模式，但是是比较常用的手法。<br>额外的一个好处是，可以让这段代码在其他地方复用。<br>简单工厂的定义只有一个工厂类，不好拓展。</p>
<blockquote>
<p>可以使用static修辞符，叫做静态工厂，好处是不用创建对象，坏处是无法使用继承来改变创建方式。</p>
</blockquote>
<p><strong>如何第二次优化？</strong></p>
<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p><img src="/2020/05/11/Design Patterns/设计模式/设计模式Png/工厂方法模式结构图.png" alt="工厂方法模式结构图" style="zoom:80%;"></p>
<p>成为设计模式的是工厂方法，和简单工厂本质上是一样的，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line">    <span class="function">Pizza <span class="title">orderPizza</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Pizza pizza = creatPizza(type);</span><br><span class="line"></span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.bos();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Pizza <span class="title">creatPizza</span><span class="params">(String type)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChinesePizzaStore</span> <span class="keyword">extends</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line">    <span class="function">Pizza <span class="title">creatPizza</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        Pizza pizza;</span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">"cheese"</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"pepperoni"</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> PepperoniPizza();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，最主要是由 组合 变为了 继承。可以通过继承子类进行拓展。</p>
<p>上面的工厂都只是创建了一个产品对象，而生活中的工厂可以生产一簇产品（比如各种汽车工厂）。</p>
<p><strong>如何第三次优化？</strong></p>
<p>其实就是从简单工厂方法中提炼出抽象工厂，再抽象接口中定义多个产品。</p>
<p><strong>工厂方法模式和泛型</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//Product</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface Converter&lt;S, T&gt; &#123;</span><br><span class="line"></span><br><span class="line">	T convert(S source);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Creator</span><br><span class="line">public interface ConverterFactory&lt;S, R&gt; &#123;</span><br><span class="line"></span><br><span class="line">	&lt;T extends R&gt; Converter&lt;S, T&gt; getConverter(Class&lt;T&gt; targetType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ContreteCreator</span><br><span class="line">final class NumberToNumberConverterFactory implements ConverterFactory&lt;Number, Number&gt;&#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public &lt;T extends Number&gt; Converter&lt;Number, T&gt; getConverter(Class&lt;T&gt; targetType) &#123;</span><br><span class="line">		return new NumberToNumber&lt;&gt;(targetType);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//ContreteProduct</span><br><span class="line">	private static final class NumberToNumber&lt;T extends Number&gt; implements Converter&lt;Number, T&gt; &#123;</span><br><span class="line"></span><br><span class="line">		private final Class&lt;T&gt; targetType;</span><br><span class="line"></span><br><span class="line">		public NumberToNumber(Class&lt;T&gt; targetType) &#123;</span><br><span class="line">			this.targetType = targetType;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public T convert(Number source) &#123;</span><br><span class="line">			return NumberUtils.convertNumberToTargetClass(source, this.targetType);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PizzaIngredientFactory</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Dough <span class="title">createDough</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Sauce <span class="title">createSauce</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Cheese <span class="title">createCheese</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">public</span> Veggies[] createVeggies();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Pepperoni <span class="title">createPerpperoni</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象方法在产品的维度上更进一步。</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p><img src="/2020/05/11/Design Patterns/设计模式/设计模式Png/观察者模式结构图.png" alt="观察者模式结构图" style="zoom:80%;"></p>
<p>也叫“发布订阅模式”</p>
<blockquote>
<p>对象之间一对多的依赖，当一个对象的状态发生变化的时候，依赖它的对象都会收到通知，并且自动更新。</p>
</blockquote>
<p>被观察者不需要知道具体的观察者都有哪些，因为保存的是接口列表，面向接口编程，也就是松耦合。<br>至于为什么使用接口可以解耦，请看我之前关于“接口”的部分</p>
<blockquote>
<p>设计原则：减少紧耦合的代码</p>
</blockquote>
<p>生活案例:<br>我订阅了一家报社，报社每次更新就会通知我，之后有两种方案：</p>
<ol>
<li>推：直接把所有新报纸发给我</li>
<li>拉：由我去选取感兴趣的报纸。<br>如果不想收到通知了就退订。</li>
</ol>
<p>程序案例：</p>
<ol>
<li><p>JAVA内置的观察者模式</p>
</li>
<li><p>监听器：使用事件来处理状态的变化（事实上等价于由事件来触发state的改变）</p>
<p> 监听器（观察者）</p>
<p> 主题分解为事件、事件源、事件发布器：</p>
<p> 事件（状态变化的抽象），事件源（事件发生的对象），事件发布器（负责注册监听器、触发事件、消息通知）</p>
</li>
</ol>
<p>观察者模式典型实现方式：</p>
<ol>
<li>定义2个接口：观察者（通知）接口、被观察者（主题）接口</li>
<li>定义2个类，观察者对象实现观察者接口、主题类实现被观者接口</li>
<li>主题类注册自己需要通知的观察者</li>
<li>主题类某个业务逻辑发生时通知观察者对象，每个观察者执行自己的业务逻辑。</li>
</ol>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p><img src="/2020/05/11/Design Patterns/设计模式/设计模式Png/命令模式结构图.png" alt="命令模式结构图" style="zoom:80%;"></p>
<p><strong>命令模式解决什么问题？</strong></p>
<p>命令模式是一个行为模式<br>所谓行为，就是某个对象实现了某个功能的一个过程，比如灯开了，音乐响了，厨师开始炒肉了….<br>从对象语言的角度看，就是一个对象执行了一个方法。</p>
<p>命令模式解决的两个问题：</p>
<ol>
<li><p>将行为的定义和行为的执行解耦</p>
<p><strong>解耦的意义？</strong></p>
<p>命令执行者不需要关心行为的定义是什么，只需要在某个条件触发时去执行；<br>行为的定义只需要满足一定的格式就可以得到拓展。符合开闭的原则。</p>
</li>
<li><p>将行为抽象成命令，进行统一的管理控制</p>
<p><strong>抽象成命令的意义？</strong></p>
<p>可以采用各种数据结构各种算法来操作这些命令，实现更多的功能，譬如撤销，队列，池等等。</p>
</li>
</ol>
<h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p>最核心的肯定是命令的抽象：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在可以分两个层面来分析命令模式的工作：</p>
<ol>
<li>命令的具体定义</li>
<li>管理控制命令</li>
</ol>
<p>这两个问题是互相独立的，互不干扰。</p>
<h4 id="命令的具体定义"><a href="#命令的具体定义" class="headerlink" title="命令的具体定义"></a>命令的具体定义</h4><p><strong>命令的具体定义？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line"></span><br><span class="line">    ConcreteCommand(Receiver receiver)&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">          receiver.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>命令一般并不实现具体的行为，具体行为是由真正的执行者去实现的。<br>当然命令本身也可以成为真正的执行者。</p>
<p>执行者：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行者一般来源于第三方</p>
<p><strong>如何将执行者和命令绑定起来？</strong></p>
<p>因此需要在命令对象中保存真正的执行者对象，命令作为一个委托者来调用执行者的方法。<br>将执行者和命令绑定起来的地方成为Client</p>
<p>Client：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    Command command1 = <span class="keyword">new</span> ConcreteCommand1(Receiver1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>执行者和命令的关系：</strong></p>
<p>有上面封装的过程可以看到，执行者和命令之间是什么紧密的，基本上可以认为一个行为就需要一个新的命令去封装。<br>但是，这些过程对于调用方来说都是看不见的，调用者也不需要去关心命令的具体实现。<br>因而一旦命令被封装好，就按照命令的属性来进行操作。</p>
<h4 id="管理控制命令"><a href="#管理控制命令" class="headerlink" title="管理控制命令"></a>管理控制命令</h4><p>调用方操作的命令都是抽象的，符合依赖转置原则。<br>对于调用方而言，所有的命令都是一些具有方法的普通对象。<br>调用方将所有的命令采用合适的数据结构保存起来，然后根据功能去操作这些命令。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">    Command[] commands;</span><br><span class="line">    Map&lt;Command&gt; commandMap = HashMap&lt;&gt;();</span><br><span class="line">    List&lt;Command&gt; stack = <span class="keyword">new</span> LinkList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">setCommand</span><span class="params">(Integer index, Command command)</span></span>&#123;</span><br><span class="line">        commands[index] = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">addCommand</span><span class="params">(Command command)</span></span>&#123;</span><br><span class="line">        stack.add(command);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">fun1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">fun2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">fun3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常见的管理命令的操作：撤销，队列，宏<br>常见的命令模式案例：线程池</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p><img src="/2020/05/11/Design Patterns/设计模式/设计模式Png/image-20200414143748792.png" alt="代理模式结构图" style="zoom:80%;"></p>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><blockquote>
<p>将对象组合成树形结构以表示‘部分-整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
</blockquote>
<p><img src="/2020/05/11/Design Patterns/设计模式/设计模式Png/image-20200414150736625.png" alt="组合模式结构图" style="zoom: 50%;"></p>
<p>需求中是体现部分与整体层次的结构时，以及希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑组合模式了。</p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p><img src="/2020/05/11/Design Patterns/设计模式/设计模式Png/image-20200414151726166.png" alt="策略模式结构图" style="zoom:80%;"></p>
<p>策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。</p>
<p>当不同的行为堆砌在一个类中时，就很难避免使用条件语句来选择合适的行为。将这些行为封装在一个个独立的Strategy类中，可以在使用这些行为的类中消除条件语句。</p>
<p>只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性。　　</p>
<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p><img src="/2020/05/11/Design Patterns/设计模式/设计模式Png/image-20200414152704891.png" alt="模板方法模式结构图" style="zoom:80%;"></p>
<blockquote>
<p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
</blockquote>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><blockquote>
<p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
</blockquote>
<p><img src="/2020/05/11/Design Patterns/设计模式/设计模式Png/image-20200414153205473.png" alt="原型模式结构图" style="zoom:80%;"></p>
<p>实现clone()方式时需要考虑深复制和浅复制的问题</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><blockquote>
<p>将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
</blockquote>
<p><img src="/2020/05/11/Design Patterns/设计模式/设计模式Png/image-20200414154224168.png" alt="适配器模式结构图" style="zoom:80%;"></p>
<p>系统的数据和行为都正确，但接口不符时，我们应该考虑用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。适配器模式主要应用于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况。</p>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><blockquote>
<p>开闭原则：不允许修改，只允许扩展。</p>
</blockquote>
<p><img src="/2020/05/11/Design Patterns/设计模式/设计模式Png/装饰者模式结构图.png" alt="装饰者模式结构图" style="zoom:80%;"></p>
<p><strong>符合开闭原则的好处？</strong></p>
<p>可容易应对易变的代码，接受新的功能，而不破坏以前的功能。<br>装饰者模式完全符合开闭原则</p>
<p>并不是代码中的每个部分都需要满足开闭原则，那样只会增加代码的复杂度，没有任何好处。需要处理的地方是代码中比较重要的<em>易变</em>部分，针对这一部分运用开闭原则更有益于维护。</p>
<p><strong>使用场景</strong></p>
<ol>
<li>为了方便统一管理，把多个不同的类，适配成同一个类进行管理，如GenericConverter</li>
</ol>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><blockquote>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
</blockquote>
<p><img src="/2020/05/11/Design Patterns/设计模式/设计模式Png/image-20200414154818159.png" alt="单例模式结构图" style="zoom:80%;"></p>
<p>注意单例中的多线程安全问题</p>
<p>解决方案：</p>
<ol>
<li>双重锁</li>
<li>静态初始化</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>（二）垃圾收集器和内存分配策略</title>
    <url>/2019/10/14/JVM/%EF%BC%88%E4%BA%8C%EF%BC%89%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h1 id="垃圾收集器和内存分配策略"><a href="#垃圾收集器和内存分配策略" class="headerlink" title="垃圾收集器和内存分配策略"></a>垃圾收集器和内存分配策略</h1><p>本章的核心内容：</p>
<ol>
<li>垃圾回收算法和常见的垃圾回收器</li>
<li>堆内存自动分配的一些规则</li>
</ol>
<p><strong>哪些内存需要回收？</strong></p>
<p>程序计数器、本地方法栈和虚拟机栈是随着线程的产生而产生，随着线程的消亡而消亡的，这几部分的内存分配和回收是确定好了的，随方法结束或线程结束时，内存就紧跟着回收了。</p>
<p>而Java堆和方法区不一样。一个接口中多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在运行期间才知道会创建哪些对象，故内存回收与分配重点关注的是堆内存和方法区内存。</p>
<ul>
<li>方法区：永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。</li>
<li>堆：其中存放的是对象实例，对于对象实例的回收，我们首先要判断哪些对象是“存活的”，对于那部分“死亡的”对象，就是我们要回收的。判断对象的存活有两种方法：<ol>
<li>引用计数算法</li>
<li>可达性分析算法</li>
</ol>
</li>
</ul>
<p><strong>什么时候回收？</strong></p>
<p>不足以分配新内存时</p>
<h2 id="对象已死吗"><a href="#对象已死吗" class="headerlink" title="对象已死吗"></a>对象已死吗</h2><p><strong>如何判断对象是否还有用？</strong></p>
<ul>
<li><p>引用计数法：给对象添加一个引用计数器, 每当有一个地方引用它时, 计数器值+1, 引用失效, -1, 为0的对象不能被使用。</p>
<ol>
<li>优势：实现简单，效率高。</li>
<li>无法解决对象相互引用的问题——会导致对象的引用虽然存在，但是已经不可能再被使用，却无法被回收。</li>
</ol>
</li>
<li><p>可达性分析：通过一系列的称为”GC Roots”的对象作为起始点, 从这些节点开始向下搜索, 搜索走过的路径称为引用链(Reference Chain), 当一个对象到GC Roots不可达(也就是不存在引用链)的时候, 证明对象是不可用的。</p>
</li>
</ul>
<p><img src="/2019/10/14/JVM/（二）垃圾收集器和内存分配策略/01.png" alt="可达性分析"></p>
<p><strong>哪些对象可以作为GC Roots？</strong></p>
<ol>
<li>方法区: 类静态属性引用的对象;</li>
<li>方法区: 常量引用的对象;</li>
<li>虚拟机栈(本地变量表)中引用的对象.</li>
<li>本地方法栈JNI(Native方法)中引用的对象。</li>
</ol>
<p><strong>对引用的理解？</strong></p>
<p>为了描述“当内存空间还足够时，则能保留在内存之屮；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象”。在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference)、软引用（Soft Reference)、弱引用（Weak Reference)、虚引用（Phantom Reference)4种，这4种引用强度依次逐渐减弱。</p>
<p><img src="/2019/10/14/JVM/（二）垃圾收集器和内存分配策略/02.png" alt="引用类型"></p>
<p><strong>可达性分析中一个对象的死亡需要经历哪些过程？</strong></p>
<p>会经历两次标记：</p>
<ol>
<li>进行可达性分析，第一次标记不可达的对象，并把“覆盖了finalize()方法且未执行该方法”的对象加入F-Quene队列中。</li>
<li>启动低优先级的线程，“尝试”执行F-Quene队列中的finalize()方法，若自救（与可达引用链上的任一对象关联）失败，则进行第二次标记。<blockquote>
<p>注意：每个对象finalize()方法只是可能执行，并不能保证执行</p>
</blockquote>
</li>
</ol>
<p><strong>方法区需要被回收吗？</strong></p>
<p>没有规定，可以回收，但是回收率很低，实现回收机制，性价比不高<br>永久代的回收主要是“废弃常量”和“无用的类”</p>
<p><strong>如何判断一个常量是否“废弃常量”？</strong></p>
<p>假如有个字符串“abc”进入常量池，没有任何地方引用到该常量</p>
<p><strong>如何判断一个类是否“废弃类”？</strong></p>
<ol>
<li>所有实例已被回收</li>
<li>该类的加载器已被回收</li>
<li>该类对应的Class对象没有任何地方被引用，也没有任何地方用过反射访问该类<br>满足上诉3个条件就有可能被回收</li>
</ol>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><p>分为标记和清除两个阶段，先标记出需要回收的对象（可达性分析算法或者引用计数算法），在标记完成后统一回收所有被标记的对象。</p>
<p>不足之处：效率问题，标记和清除效率都不高。空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾回收动作。</p>
<p><img src="/2019/10/14/JVM/（二）垃圾收集器和内存分配策略/03.png" alt="标记清除算法"></p>
<h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>将可用内存划分为大小相等的两块，每次只使用其中的一块。当这块用完了，就将还存活的复制到另一块上，然后将这一块一次性清除。商业虚拟机都是采用该方法来回收新生代，新生代98%都是朝生夕死的。将内存分为较大Eden和两个较小的survivor空间。每次使用其中一块Eden和survivor，回收时将存活的对象一次性地复制到另一块survivor中，再清理掉之前的。HotSpot虚拟机Eden与Survivor默认的大小比例为8:1:1。survivor空间不够时，需要依赖其他内存（老年代）进行分配担保，即让对象进入老年代。</p>
<p>不足之处：复制在对象存活率较高时效率很低。不适合老年代</p>
<p><img src="/2019/10/14/JVM/（二）垃圾收集器和内存分配策略/04.png" alt="复制算法"></p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>标记过程同标记清除一样，但不是直接对可回收对象进行清理，而是让存活对象朝着一端移动，然后直接清理掉端边界外的内存。</p>
<p><img src="/2019/10/14/JVM/（二）垃圾收集器和内存分配策略/05.png" alt="复制算法"></p>
<h3 id="分代算法"><a href="#分代算法" class="headerlink" title="分代算法"></a>分代算法</h3><p>根据各年代特点分别采用最适当的GC算法。在新生代:中每次垃圾收集都能发现大批对象已死, 只有少量存活. 因此选用复制算法, 只需要付出少量存活对象的复制成本就可以完成收集。在老年代: 因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清理”或“标记—整理”算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存。即：</p>
<p>新生代：存活率低，使用复制算法<br>老年代：存活率高，使用“标记-整理”或“标记-清除”算法</p>
<h2 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h2><p><strong>什么是“Stop The World”？</strong></p>
<p>可达性分析对执行时间的敏感还体现在GC停顿上，因为这项分析工作在一个能确保一致性的快照中进行——这里“一致性”的意思是指在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果准确性就无法得到保证。这点是导致GC进行时必须停顿所有Java执行线程（Sun将这件事情称为“Stop The World”）的其中一个重要原因，即使是在号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</p>
<p><strong>如何枚举根节点？</strong></p>
<p>在HotSpot的实现中，是使用一组称为OopMap的数据结构来达到这个目的的，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。</p>
<p>问题：可能导致引用关系变化的指令非常多，如果为每一个指令都生成对应的OopMap，将需要大量的空间，<strong>怎么办？</strong></p>
<p>实际上，HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint）</p>
<p><strong>如何选定安全点？</strong></p>
<p>Safepoint的选定即不能太少以致于让GC等待时间太长，也不能过于频繁以至于过分增大运行时的负荷。所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的——因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。</p>
<p><strong>如何在GC时，让所有线程都在安全点停下？</strong></p>
<p>这里有两种方案可供选择：</p>
<ul>
<li>抢先式中断（Preemptive Suspension）：抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让他“跑”到安全点上。</li>
<li>主动式中断（Voluntary Suspension）：主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单的设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。<blockquote>
<p>现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。</p>
</blockquote>
</li>
</ul>
<p><strong>如果程序不被执行呢？</strong></p>
<p>所谓的程序不执行就是没有分配CPU时间，典型的例子就是线程处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全的地方去中断挂起，JVM也显然不太可能等待线程重新被分配CPU时间。对于这种情况，就需要安全区域（Safe Region）来解决。</p>
<p>  安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。我们也可以把Safe Region看作是被扩展了的Safepoint。</p>
<p>在线程执行到Safe Region中的代码中，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，他要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则他就必须等待直到收到可以安全离开Safe Region的信号为止。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>没有最好的收集器，只有最适合的收集器；</p>
<p><img src="/2019/10/14/JVM/（二）垃圾收集器和内存分配策略/06.png" alt="垃圾收集器"></p>
<h3 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3><p>用于新生代，采取复制算法</p>
<p>特点：最悠久，最基本的收集器；单线程收集器，只使用一个CPU或一条收集线程去完成垃圾收集工作，且在收集时，必须暂停其他所有的工作线程，直到收集结束。在进行垃圾收集时必须暂停其他所有的工作线程，即“Stop The World”。依然是虚拟机运行在Client模式下的默认新生代收集器。简单而高效。<br>不足：“Stop The World”给用户带来不好的体验</p>
<p><img src="/2019/10/14/JVM/（二）垃圾收集器和内存分配策略/07.png" alt="Serial"></p>
<h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><p>用于新生代，采用复制算法</p>
<p>特点：Serial收集器的多线程版，多条线程进行垃圾收集。其余和Serial收集器一样。目前唯一能与CMS收集器配合工作。</p>
<blockquote>
<p>采用多线程只会在多核的情况下才会有比较好的性能，可以使用-XX:ParallelGCThreads来限制线程数</p>
</blockquote>
<p><img src="/2019/10/14/JVM/（二）垃圾收集器和内存分配策略/08.png" alt="ParNew"></p>
<h3 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h3><p>用于新生代，采用复制算法</p>
<p>特点：目标是达到一个可控制的吞吐量——CPU用于运行用户代码的时间与CPU总消耗时间的比值（吞吐量=运行用户代码的时间/（运行用户代码的时间+垃圾收集的时间））。</p>
<p>停顿时间越短，越适用需要与用户交互的程序。而高吞吐量可以高效的利用CPU时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的程序。</p>
<blockquote>
<p>-XX:MaxGCPauseMillis设置停顿时间，以牺牲吞吐量和新生代空间为代价。-XX:GCTimeRatio设置吞吐量</p>
</blockquote>
<p><img src="/2019/10/14/JVM/（二）垃圾收集器和内存分配策略/09.png" alt="Parallel Scavenge"></p>
<h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p>用于老年代，使用“标记-整理”算法。</p>
<p>可以与JDK1.5及之前的Parallel Scavenge搭配使用；也可以作为CMS收集器的后备预案，在并发收集发生Concureent Mode Failure时使用。</p>
<h3 id="ParNew-Old-收集器"><a href="#ParNew-Old-收集器" class="headerlink" title="ParNew Old 收集器"></a>ParNew Old 收集器</h3><p>用于老年代，使用“标记-整理”算法。</p>
<p>JDK1.6前，Parallel Scavenge只能与老年代收集器Serial Old（PS MarkSweep）组合，由于Serial Old无法充分利用服务器多CPU的处理能力，会拖累整体性能。</p>
<p>JDK1.6后，Parallel Scavenge可与Parallel Old组合，达到名副其实的“吞吐量优先”，在注重吞吐量以及CPU资源敏感的场合可以优先考虑这个组合。</p>
<h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p>用于老年代，使用“标记—清除”算法。</p>
<p>特点：以获取最短回收停顿时间、低延迟为目标，适用于重视服务响应速度的应用。</p>
<p>主要过程为一下四步：</p>
<ol>
<li>初始标记；Stop the World，仅标记GCRoots能关联的对象，速度很快。</li>
<li>并发标记；进行GCRootsTracing的过程。</li>
<li>重新标记；Stop the World，修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。比1长但远比2短。</li>
<li>并发清除；</li>
</ol>
<p><img src="/2019/10/14/JVM/（二）垃圾收集器和内存分配策略/10.png" alt="Parallel Scavenge"></p>
<p>缺点：</p>
<ol>
<li>CMS对CPU资源非常敏感。</li>
<li>CMS无法处理浮动垃圾（Floating Garbage）——并发清楚阶段产生的垃圾，可能出现Concurrent Mode Failure失败(CMS运行期间预留的内存无法满足用户线程的需求)而导致另一次Full GC的产生。</li>
<li>CMS是标记清除，会产生大量碎片空间，对大对象内存分配带来麻烦。<blockquote>
<p>默认是老年开使用了68%开始收集，可以使用-XX:CMSInitiatingOccupancyFraction来设置，太高了容易出现Concurrent Mode Failure</p>
</blockquote>
</li>
</ol>
<h3 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h3><p>与其他基于分代的收集器不同，G1将整个Java堆划分为多个大小相等的独立区域Region，新生代和老年代不再是物理隔离的。</p>
<p>从整体来看：“标记-整理” 算法<br>从局部（两个Region之间）来看：“复制”算法</p>
<p>G1为什么能建立可预测的停顿时间模型？<br>如何维护每个Region之间的引用关系？</p>
<h3 id="理解GC日志"><a href="#理解GC日志" class="headerlink" title="理解GC日志"></a>理解GC日志</h3><p><a href="https://blog.csdn.net/TimHeath/article/details/53053106" target="_blank" rel="noopener">参考</a></p>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><ul>
<li>新生代GC（Minor GC）：发生在新生代的垃圾收集动作，非常频繁，一般回收速度也比较快。</li>
<li>老年代GC（Major GC/Full GC）：发生在老年代的垃圾收集动作，一般会伴随Minor GC 速度一般比Minor GC慢上10倍以上。</li>
</ul>
<p><strong>新生代晋升老年代的条件？</strong></p>
<ol>
<li>优先在Eden区分配（如果启动本地线程分配缓冲TLAB-Thread Local Allocation Buffer，则优先在TLAB）如果Eden区满，则触发一次Minor GC。使用-XX:SurvivorRatio设置比例</li>
<li>大对象直接进入老年代；大对象，即大量连续内存空间的Java对象，最典型的是那种很长的字符串及数组。这样做的好处是减少复制。使用-XX:PretenureSizeThreshold设置阈值</li>
<li>长期存活的对象将进入老年代：设置对象年龄计数器。对象在Eden出生并经过第一次MinorGC后仍存活，年龄+1，移入Survivor区。以后每经过一次MinorGC年龄加一，当达到15时（默认的）就进入老年代。使用-XX:MaxTenureingThreshold设置进入年龄</li>
<li>动态对象年龄判定：并不是对象年龄必须达到最大阈值才会进入老年代。如果survivor空间中相同年龄所有对象大小总和大于其空间的一般，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到阈值时才进入。</li>
<li>空间分配担保：发生minorGC之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，成立，MinorGC可以确保是安全的。不成立，则检查HandlePromotionFailure设置值是否允许担保失败。允许，则检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小。大于将尝试MinorGC，小于或者不允许冒险，也要进行一次FullGC。老年代分配担保，将survivor无法容纳的对象直接进入老年代。依然担保失败，则只好在失败后重新发起一次Full GC。使用-XX:HandlePromotionFailure来设置是否允许担保失败</li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>（七）虚拟机字节码执行引擎</title>
    <url>/2019/11/20/JVM/%EF%BC%88%E4%B8%83%EF%BC%89%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<h1 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h1><p>本节主要内容：</p>
<ol>
<li>了解虚拟机运行时栈帧结构</li>
<li>了解方法定位的过程：解析和分派</li>
<li>了解jvm对动态类型语言的支持</li>
<li>了解jvm的基于栈的字节码解释执行引擎</li>
</ol>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>虚拟机和物理机的区别？</strong></p>
<p>物理机的执行引擎是由硬件实现（exe文件，可执行二进制）的，和物理机的执行过程不同的是虚拟机的执行引擎由于自己实现的。</p>
<h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><p>相关说明：每一个线程都有一个栈,也就是前文中提到的虚拟机栈，栈中的基本元素我们称之为栈帧。栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构。每个栈帧都包括了一下几部分：局部变量表、操作数栈、动态连接、方法的返回地址 和一些额外的附加信息。<code>栈帧中需要多大的局部变量表和多深的操作数栈在编译代码的过程中已经完全确定，并写入到方法表的Code属性中</code>。在活动的线程中，位于当前栈顶的栈帧才是有效的，称之为当前帧，与这个栈帧相关联的方法称为当前方法。执行引擎运行的所有字节码指令只针对当前栈帧进行操作。需要注意的是一个栈中能容纳的栈帧是受限，过深的方法调用可能会导<br>致StackOverFlowError，当然，我们可以认为设置栈的大小。其模型示意图大体如下：</p>
<p><img src="/2019/11/20/JVM/（七）虚拟机字节码执行引擎/01.png" alt="运行时栈帧结构"></p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p><strong>局部变量表法的存放？</strong></p>
<p>局部变量表中存储入参、局部变量、异常<br>code属性中的指令会使用到局部变量表<br>一个存储单位称为Slot</p>
<p><strong>一个Slot的大小？能存放哪些数据类型？</strong></p>
<p>虚拟机规范并没有明确规定一个Slot的大小，只是很有导向性地说到每个 Slot 都应该能存储一个 boolean、byte、char、short、int、float、reference 或 returnAddress 类型的数据(32位或者更小)，而 long 和 double（64位）可以使用两个slot去存储。</p>
<p><strong>reference类型表示什么？</strong></p>
<p>虚拟机规范并没有明确指明它的长度，也没有明确指明它的数据结构，但是虚拟机通过 reference 数据可以做到两点：</p>
<ol>
<li>通过此 reference 引用，可以直接或间接的查找到对象在 Java 堆上的其实地址索引</li>
<li>通过此 reference 引用，可以直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息</li>
</ol>
<p><strong>Slot复用对GC的影响？</strong></p>
<p>Slot在离开作用域之后、离开方法之前，如果没有重新覆盖值，有可能还会持有对象的引用，这会影响GC的回收</p>
<p><strong>需要把“赋null值来优化内存回收”作为编码规则吗？</strong></p>
<ol>
<li>注意以恰当的作用域来控制变量的回收即可，上述情况不常见</li>
<li>赋null值的操作只在解释执行下的概念模型中有效，在JIT模式下无效</li>
</ol>
<p><strong>局部变量和类变量的区别？</strong></p>
<p>类变量有<code>准备阶段</code>，局部变量无，因此必须赋初值</p>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p><strong>相关说明:</strong></p>
<ul>
<li>Java 虚拟机的解释执行引擎称为”基于栈的执行引擎”，其中所指的”栈”就是操作数栈。也就是说，指令的执行过程也就是入栈、出栈的过程（代替寄存器）</li>
<li>操作数栈的最大深度也是在编译时期就写入到方法表的 Code 属性的 max_stacks 数据项中。</li>
<li>栈容量的单位是 “字宽”，对于 32 位虚拟机来说，一个 “字宽” 占 4 个字节，对于 64 位虚拟机来说，一个 “字宽” 占 8 个字节</li>
<li>操作数栈的每一个元素可以是可以是任意 Java 数据类型，包括 long 和 double，32 位数据类型所占的栈容量为 1，64 位数据类型所占的栈容量为 2</li>
</ul>
<h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><p><strong>什么是动态连接？为什么需要动态连接？</strong></p>
<p>在指令执行期间进行符号地址的转换，就是动态连接。<br>这么做的原因是有些指令操作的对象的实际类型只有在指令执行的时候才可以确定。</p>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p><strong>方法返回的两种方式：</strong></p>
<ul>
<li>正常完成出口，栈中需要保存调用处的PC值作为返回地址。</li>
<li>异常完成出口：返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。</li>
</ul>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p><strong>方法调用的任务是什么？</strong></p>
<p>方法调用的任务是确认调用哪个方法，并不是执行。</p>
<blockquote>
<p>也就是说，这里的方法调用的含义是方法“确认”</p>
</blockquote>
<h3 id="解析（Resolution）"><a href="#解析（Resolution）" class="headerlink" title="解析（Resolution）"></a>解析（Resolution）</h3><p><strong>什么是解析？</strong></p>
<p>有几种方法的调用，在加载阶段就可以确认该方法的直接引用，前提是：方法在程序真正运行之前就有一个可确定的调用版本（调用哪一个方法），并且这个方法的调用版本在运行期是不可变的（也就是说不包括接口方法和抽象方法）。换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用（确认）称为解析。</p>
<blockquote>
<p>这里的解析和类加载的解析阶段概念有些区别</p>
</blockquote>
<p><strong>哪些方法符合解析的条件？</strong></p>
<p>有四种方法是进行的方法的解析：静态方法、私有方法、实例构造器、父类方法，这四类方法称为非虚方法，与之对应的就是续方法（final 方法除外），调用这四类方法的字节码指令是：</p>
<ul>
<li>invokestatic：调用静态方法</li>
<li>invokespecial：调用实例构造器方法<init>、私有方法、父类方法</init></li>
</ul>
<p>除了这两种方法调用的指令外还有：</p>
<ul>
<li>invokevirtual：调用所有的虚方法</li>
<li>invokeinterface：调用接口方法，会在运行时确认一个实现此接口的对象</li>
<li>invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。</li>
</ul>
<h3 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h3><p><strong>什么是分派？</strong></p>
<p>根据入参、出参（都称为宗量）来确定调用的方法就是分派</p>
<h4 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h4><p><strong>静态分派的案例：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello, guy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Main guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello, man"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello, woman"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        StaticDispatch dispatch = <span class="keyword">new</span> StaticDispatch();</span><br><span class="line">        dispatch.sayHello(man);</span><br><span class="line">        dispatch.sayHello(woman);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//result:</span></span><br><span class="line"><span class="comment">//hello, guy</span></span><br><span class="line"><span class="comment">//hello, guy</span></span><br></pre></td></tr></table></figure></p>
<p><strong>什么是静态类型（外观类型）和实际类型？</strong></p>
<ul>
<li>静态类型：编译时变量的类型</li>
<li>实际类型：执行时变量的类型</li>
</ul>
<p><strong>什么是静态分派？</strong></p>
<p>依赖静态类型定位目标方法的分派动作称为静态分派<br>静态分配发生在编译阶段，静态分派的动作实际上不是由虚拟机来执行的，而是由编译器来执行的。</p>
<p><strong>分派和解析的关系？</strong></p>
<p>分派和解析并非“非黑即白”的关系<br>而是从不同的角度去确认调用方法的一个概念<br>静态分派发生在编译时期<br>解析发生在加载阶段<br>动态分派发生在执行阶段</p>
<h4 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h4><p><strong>动态分派的案例：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"hello, man"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"hello, woman"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">        woman.sayHello();</span><br><span class="line">        man = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//result</span></span><br><span class="line"><span class="comment">//hello, man</span></span><br><span class="line"><span class="comment">//hello, woman</span></span><br><span class="line"><span class="comment">//hello, man</span></span><br></pre></td></tr></table></figure></p>
<p><strong>什么是动态分派？</strong></p>
<p>执行阶段根据实际类型来定位方法<br>指令上表现为invokevirtual和invokeinterface</p>
<p><strong>invokevirtual的指令运行时大致解析过程？</strong></p>
<ol>
<li>找到操作数栈顶的引用所指的对象的实际类型，记做C</li>
<li>在类型C中查找与常量中的描述符和简单名称相同的方法，如果找到则进行访问权限的判断，如果通过则返回这个方法的直接引用，查找结束；如果权限不通过，则返回 java.lang.IllegalAccessError 的异常</li>
<li>如果在C中没有找到描述符和简单名称都符合的方法，则按照继承关系从下往上依次在 C 的父类中进行查找和验证过程</li>
<li>如果最终还是没有找到该方法，则抛出 java.lang.AbstractMethodError 的异常</li>
</ol>
<h4 id="单分派和多分派"><a href="#单分派和多分派" class="headerlink" title="单分派和多分派"></a>单分派和多分派</h4><p><strong>什么是单分派和多分派？</strong></p>
<p>根据分派时依据的宗量多少，可以分为单分派和多分派。</p>
<p><strong>java（1.8前）的分派类型是什么？</strong></p>
<p>Java 语言还是一门 “静态多分派、动态单分派” 的语言：</p>
<ul>
<li>静态多分派：静态分派时根据参数的静态类型和方法接受者的静态类型选择目标方法</li>
<li>动态单分派：动态分派时根据方法接受者的实际类型替换目标方法</li>
</ul>
<h4 id="虚拟机动态分派的实现"><a href="#虚拟机动态分派的实现" class="headerlink" title="虚拟机动态分派的实现"></a>虚拟机动态分派的实现</h4><p><strong>实际分派需要考虑什么问题？</strong></p>
<p>虚拟机中的动态分派是十分频繁的动作，并且是在运行时在类方法元数据中进行搜索的，因此基于性能的考虑，虚拟机会采用各种优化手段优化动态分派的过程，最常见的”稳定优化”的手段就是为类在方法区中建立一个虚方法表，使用虚方法表索引来代替元数据以提高性能。</p>
<p><strong>虚方法表介绍：</strong></p>
<p><img src="/2019/11/20/JVM/（七）虚拟机字节码执行引擎/02.png" alt="运行时栈帧结构"></p>
<p>上图就是一个虚方法表，Father、Son、Object 三个类在方法区中都有一个自己的虚方法表，如果子类中实现了父类的方法，那么在子类的虚方法表中该方法就指向子类实现的该方法的入口地址，如果子类中没有重写父类中的方法，那么在子类的虚方法表中，该方法的索引就指向父类的虚方法表中的方法的入口地址。</p>
<p>有两点需要注意：</p>
<ol>
<li>为了程序实现上的方便，一个具有相同签名的方法，在子类的方法表和父类的方法表中应该具有相同的索引，这样在类型变化的时候，只需要改变查找方法的虚方法表即可。</li>
<li>虚方法表是在类加载的连接阶段实现的，类的变量初始化完成之后，就会初始化该类的虚方法表</li>
</ol>
<h3 id="动态类型语言支持"><a href="#动态类型语言支持" class="headerlink" title="动态类型语言支持"></a>动态类型语言支持</h3><p><strong>什么是动态类型语言？</strong></p>
<p>主要特性：</p>
<ol>
<li>在运行期进行类型检查</li>
<li>变量没有类型而变量的值有类型</li>
</ol>
<p><strong>什么是“在编译器/运行期进行”？</strong></p>
<p>某种检查/验证进行的时期</p>
<p><strong>什么是“类型检查”？</strong></p>
<p>类型检查指验证操作接收者是否为合适的类型数据以及赋值是否合乎类型要求。</p>
<p><strong>动态语言和静态语言谁更好？</strong></p>
<p>动态语言：</p>
<ul>
<li>优点：动态检查的一个显著优点是它提供了宽松、少限制的程序设计环境，这在交互式语言中是十分有用的；动态检查允许对变量的后期约束，从而给予编程较大灵活性，还可以在引入某些新定义类型时，不需改变现行程序代码,即具有动态多态性；动态检查可允许更丰富的类型系统，特别地，易于将类型作为一阶对象处理，可允许异质的结构类型，便于数组下标分析。</li>
<li>缺点：（1）增加了程序运行时间，影响了效率；（2）需要数据具有类型标志；（3）错误发现太晚，不能防止运行错的出现。</li>
</ul>
<p>静态语言：</p>
<ul>
<li>优点：静态分析有利于错误的早时发现和代码优化、效率提高，也防止了关于类型的运行出错。</li>
<li>缺点：没有了动态方式所具有的灵活性，引入新的类型可能需对原程序的修改和重编译；静态检查也必须要求类型系统是可判定的以保证终止性，从而使类型系统有较大限制，许多类型是不允许的。</li>
</ul>
<p><strong>与JAVA语言，JVM有什么关系？</strong></p>
<p>动态类型语言最重要的是对方法调用的影响，也就是在运行时才去定位需要调用的方法，简称<code>动态定位</code>。</p>
<p>早期的java一直都是静态类型的语言，而JVM的目标是能更好的支持更多的语言，这其中包括动态语言，jdk1.7之前基本不支持动态语言，1.7引出新指令invokedynamic来支持动态语言，java1.7中使用MethodHandle来支持动态，但是也并没有使用到invokedynamic指令，从1.8的lambda中才有明显的运用。</p>
<p><strong>动态分派和动态类型语言的区别？</strong></p>
<p>动态分派利用运行期的<code>实际类型</code>来实现，但依然会用编译期的<code>静态类型</code>进行类型检查<br>而动态类型语言要求编译期<code>静态类型</code>也不确定，在运行时期才进行类型检查。</p>
<p><strong>JDK1.7如何支持动态类型（MethodHandle）？</strong></p>
<p><code>MethodHandle的关键是让分派逻辑不固化在class文件上（连静态类型也不确定），而是通过一个具体的方法来完成方法的定位，MethodHandle的含义就是分派的结果，也就是方法调用的位置</code></p>
<ol>
<li>创建MethodType对象，指定方法的签名（即方法参数以及方法返回值的类型）。</li>
<li>在MethodHandles.Lookup中查找类型为MethodType的MethodHandle；</li>
<li>传入方法参数并调用MethodHandle.invoke或者MethodHandle.invokeExact方法。</li>
</ol>
<p>案例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MethodHandleTest mht = <span class="keyword">new</span> MethodHandleTest();</span><br><span class="line">    MethodHandle mh = getString(mht);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String o = (String) mh.invoke(mht, <span class="string">"ssss"</span>);</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MethodHandle <span class="title">getString</span><span class="params">(Object Recevier)</span></span>&#123;</span><br><span class="line">    MethodType mt = MethodType.methodType(String.class,String.class);</span><br><span class="line">    MethodHandle mh = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mh = MethodHandles.lookup().findVirtual(Recevier.getClass(),<span class="string">"toString"</span>,Recevier);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>MethodHandle和反射（Reflection）的区别？</strong></p>
<ol>
<li>反射是模拟java代码层面的调用，MethodHandle是模拟字节码层面的调用。</li>
<li>Reflection是重量级，而MethodHandle是轻量级。</li>
<li>由于MethodHandle是对字节码的方法指令调用的模拟，那理论上虚拟机在这方面做的各种优化（如方法内联），在MethodHandle上也应当可以采用类似思路去支持（但目前实现还不完善）。而通过反射去调用方法则不行。</li>
</ol>
<p><strong>CONSTANT_MethodHandle_info和MethodHandle类的关系？</strong><br>InvokeDynamic指令介绍：</p>
<p>InvokeDynamic和MethodHandle机制一样，只是MethodHandle是java代码的实现，InvokeDynamic是字节码的实现。</p>
<p><strong>InvokeDynamic指令与前4条invoke*指令的区别？</strong></p>
<h2 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h2><p><strong>解释执行和编译执行的定义？</strong></p>
<ol>
<li>解释执行：代码由生成字节码指令之后，由解释器解释执行</li>
<li>编译执行：通过即时编译器生成本地代码执行</li>
</ol>
<p><img src="/2019/11/20/JVM/（七）虚拟机字节码执行引擎/03.png" alt="编译过程"></p>
<p><strong>java编译包含了哪些步骤？</strong></p>
<p>生成字节码的过程发生在虚拟机外，解释器在虚拟机内，因此属于半独立编译</p>
<p><strong>基于栈的指令集合基于寄存器的指令集区别以及优缺点？</strong></p>
<p>基于栈的指令集中的指令是依赖于操作数栈运行的，基于寄存器的指令是依赖于寄存器进行工作的。用一个简单的例子说明：1 + 1 这个例子来说明：</p>
<ul>
<li><p>基于栈的指令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iconst_1</span><br><span class="line">iconst_1</span><br><span class="line">iadd</span><br><span class="line">istore_0</span><br></pre></td></tr></table></figure>
<p>两条 iconst_1 指令分别把两个 1 压入到工作栈中去，然后执行 iadd 两条指令，对栈顶的两个 1 进行出栈并相加的动作，然后将相加的结果 2 压入到栈中，接着执行 istore_0 将栈顶的 2 存入到局部变量表中第 0 个 Slot 中去</p>
</li>
<li><p>基于寄存器的指令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov  eax, 1</span><br><span class="line">add  eax, 1</span><br></pre></td></tr></table></figure>
<p>mov 指令将寄存器 eax 中的值设置为 1，然后执行 add 指令将寄存器 eax 中的值加 1，结果就保存在 eax 寄存器中</p>
</li>
</ul>
<p><strong>基于栈的指令的特点:</strong></p>
<ul>
<li>可移植：寄存器由硬件决定，限制较大，但是虚拟机可以在不同硬件条件的机器上执行(虚拟机本身需要不同的实现)</li>
<li>代码相对更加紧凑：字节码中每个字节就对应一条指令，而多地址指令集中还需要存放参数</li>
<li>编译器实现更加简单</li>
<li>基于栈的指令缺点就是执行速度慢：因为虚拟机中操作数栈是在内存中实现的，频繁的栈访问也就意味着频繁的访问内存，内存的访问还是要比直接操作寄存器要慢的</li>
</ul>
<p><strong>案例：</strong></p>
<p>注意：</p>
<ol>
<li>案例的执行过程仅仅是一种概念模型，虚拟机最终会对执行过程做一些优化来提高性能，实际的运作过程不一定完全符合概念模型的描述。</li>
<li>更准确的说，实际情况会和上面描述的概念模型差距非常大，这种差距产生的原因是虚拟机中解释器和即时编译器都会对输入的字节码进行优化。</li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal系列源码分析</title>
    <url>/2020/06/23/Java/ThreadLocal%E7%B3%BB%E5%88%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="ThreadLocal系列源码分析"><a href="#ThreadLocal系列源码分析" class="headerlink" title="ThreadLocal系列源码分析"></a>ThreadLocal系列源码分析</h1><h2 id="ThreadLocal-源码分析："><a href="#ThreadLocal-源码分析：" class="headerlink" title="ThreadLocal 源码分析："></a>ThreadLocal 源码分析：</h2><p>直接看 ThreadLocal##get() 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 2. 获取线程对象中的属性 threadLocals表</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 3. 获取Entry</span></span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                <span class="comment">// 4. 返回value值，即 ThreadLocal 存储的线程相关的值</span></span><br><span class="line">                        T result = (T) e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5. 如果 map 为空，则设置并返回初始值</span></span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每个线程都保存自己的一份 ThreadLocal 表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 设置并返回初始值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T value = initialValue();</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 设置初始值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看 ThreadLocal##set()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 2. 获取线程对象中的属性 ThreadLocalMap</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个线程都保存自己的一份 ThreadLocal 表，这个表长啥样？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定制了自己的 hash 算法，每个Entry都可定位到指定的索引</span></span><br><span class="line">        <span class="keyword">private</span> Entry[] table;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WeakReference&lt;ThreadLocal&lt;?&gt;&gt; 表示只有一个 ThreadLocal 引用，但是这个引用比较特殊</p>
<h2 id="ThreadLocal-为什么要使用-WeakReference？"><a href="#ThreadLocal-为什么要使用-WeakReference？" class="headerlink" title="ThreadLocal 为什么要使用 WeakReference？"></a>ThreadLocal 为什么要使用 WeakReference？</h2><p>当发生 GC 时，WeakReference 中持有的引用便会被回收，这样的意义是：当 ThreadLocal 置为 Null 时，Thread 中的 map 自动进行回收（只有 map 中的 key 会自动回收）。</p>
<h2 id="WeakReference-应用场景？"><a href="#WeakReference-应用场景？" class="headerlink" title="WeakReference 应用场景？"></a>WeakReference 应用场景？</h2><ol>
<li>map 自动回收</li>
<li>缓存自动释放</li>
</ol>
<h2 id="WeakReference-内的引用如果被回收了，自身如何存在？"><a href="#WeakReference-内的引用如果被回收了，自身如何存在？" class="headerlink" title="WeakReference 内的引用如果被回收了，自身如何存在？"></a>WeakReference 内的引用如果被回收了，自身如何存在？</h2><p>自身不会被回收，但是会被放到 ReferenceQuene 中（如果有初始化），发生回收后，可以遍历 ReferenceQuene 来进行后续操作。</p>
<h2 id="feign-中使用-RequestInterceptor-遇到的一个问题："><a href="#feign-中使用-RequestInterceptor-遇到的一个问题：" class="headerlink" title="feign 中使用 RequestInterceptor 遇到的一个问题："></a>feign 中使用 RequestInterceptor 遇到的一个问题：</h2><p>当 Hystrix资源隔离策略 为线程模式时，RequestInterceptor 会变成异步执行，这时候 RequestContextHolder.getRequestAttributes() 拿到的结果会为 Null ，这是因为 RequestContextHolder 基于 ThreadLocal。</p>
<h2 id="如何解决上述问题？"><a href="#如何解决上述问题？" class="headerlink" title="如何解决上述问题？"></a>如何解决上述问题？</h2><p>使用 InheritableThreadLocal ，该类可以实现父线程的 ThreadLocalMap 传递到子线程的 ThreadLocalMap中。</p>
<h2 id="InheritableThreadLocal-源码分析"><a href="#InheritableThreadLocal-源码分析" class="headerlink" title="InheritableThreadLocal 源码分析"></a>InheritableThreadLocal 源码分析</h2><p>ThreadLocalMap 的传递发生在新线程创建时，那么可以从 Thread 的初始化方法入手：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 除了有 ThreadLocal 表 还有 inheritableThreadLocals 表</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...忽略无关代码</span></span><br><span class="line">        <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 这里把父线程中的 inheritableThreadLocals表 传递到子线程中的 inheritableThreadLocals表</span></span><br><span class="line">            <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看 ThreadLocal##createInheritedMap()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> ThreadLocalMap <span class="title">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">            Entry[] parentTable = parentMap.table;</span><br><span class="line">            <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">            setThreshold(len);</span><br><span class="line">            table = <span class="keyword">new</span> Entry[len];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                Entry e = parentTable[j];</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">                    <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 核心方法</span></span><br><span class="line">                        Object value = key.childValue(e.value);</span><br><span class="line">                        Entry c = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">                        <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">                            h = nextIndex(h, len);</span><br><span class="line">                        table[h] = c;</span><br><span class="line">                        size++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ThreadLocal 中 不支持 传递方法 childValue()，该方法由子类 InheritableThreadLocal 重写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 childValue()，支持传递</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 变更为操作 inheritableThreadLocals表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 变更为操作 inheritableThreadLocals表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="InheritableThreadLocal-有什么不足？"><a href="#InheritableThreadLocal-有什么不足？" class="headerlink" title="InheritableThreadLocal 有什么不足？"></a>InheritableThreadLocal 有什么不足？</h2><p>InheritableThreadLocal 只能做到父线程到子线程的传递，但目前往往会使用线程池，这时候 InheritableThreadLocal 就失效了。</p>
<p>可以使用 TransmittableThreadLocal 解决上述问题，TransmittableThreadLocal 的任务是把 <strong>任务提交给线程池时</strong>的<code>ThreadLocal</code>值传递到 <strong>任务执行时</strong>。</p>
<p>使用案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TransmittableThreadLocal&lt;String&gt; context = <span class="keyword">new</span> TransmittableThreadLocal&lt;String&gt;();</span><br><span class="line">context.set(<span class="string">"value-set-in-parent"</span>);</span><br><span class="line"></span><br><span class="line">Runnable task = <span class="keyword">new</span> Runnable();</span><br><span class="line"><span class="comment">// 额外的处理，生成修饰了的对象ttlRunnable</span></span><br><span class="line">Runnable ttlRunnable = TtlRunnable.get(task);</span><br><span class="line">executorService.submit(ttlRunnable);</span><br><span class="line"></span><br><span class="line"><span class="comment">// =====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Task中可以读取，值是"value-set-in-parent"</span></span><br><span class="line">String value = context.get();</span><br></pre></td></tr></table></figure>
<p>那么来看看 TtlRunnable##get 中干了些啥</p>
<h2 id="TransmittableThreadLocal-源码分析："><a href="#TransmittableThreadLocal-源码分析：" class="headerlink" title="TransmittableThreadLocal 源码分析："></a>TransmittableThreadLocal 源码分析：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TtlRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">TtlEnhanced</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;Object&gt; capturedRef;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable runnable;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> releaseTtlValueReferenceAfterRun;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 核心</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TtlRunnable</span><span class="params">(@Nonnull Runnable runnable, <span class="keyword">boolean</span> releaseTtlValueReferenceAfterRun)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保存要传递的 ThreadLocalMap capture()</span></span><br><span class="line">        <span class="keyword">this</span>.capturedRef = <span class="keyword">new</span> AtomicReference&lt;Object&gt;(capture());</span><br><span class="line">        <span class="comment">// 保存原任务</span></span><br><span class="line">        <span class="keyword">this</span>.runnable = runnable;</span><br><span class="line">        <span class="comment">// 执行完后是否释放</span></span><br><span class="line">        <span class="keyword">this</span>.releaseTtlValueReferenceAfterRun = releaseTtlValueReferenceAfterRun;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TtlRunnable <span class="title">get</span><span class="params">(@Nullable Runnable runnable, <span class="keyword">boolean</span> releaseTtlValueReferenceAfterRun, <span class="keyword">boolean</span> idempotent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == runnable) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若发现已经是目标类型了（说明已经被包装过了）直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (runnable <span class="keyword">instanceof</span> TtlEnhanced) &#123;</span><br><span class="line">            <span class="keyword">if</span> (idempotent) <span class="keyword">return</span> (TtlRunnable) runnable;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already TtlRunnable!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其实就是包装了一下</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TtlRunnable(runnable, releaseTtlValueReferenceAfterRun);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>包装时核心的方法来自 TransmittableThreadLocal 中的 静态内部类 Transmitter##capture()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransmittableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Transmitter</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * 该方法做主要功能只是把 holder 的值做一个拷贝</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; captured = <span class="keyword">new</span> HashMap&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;();</span><br><span class="line">            <span class="keyword">for</span> (TransmittableThreadLocal&lt;?&gt; threadLocal : holder.get().keySet()) &#123;</span><br><span class="line">                captured.put(threadLocal, threadLocal.copyValue());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> captured;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>holder 是啥？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TransmittableThreadLocal 继承自 InheritableThreadLocal</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransmittableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123; </span><br><span class="line">    <span class="comment">// holder 是一个 InheritableThreadLocal，存储 线程相关 的一个 Map</span></span><br><span class="line">    <span class="comment">// 该 map 即从 **任务提交给线程池时** 传递到 **任务执行时** 的 `ThreadLocal` 值</span></span><br><span class="line">    <span class="comment">// 采用 WeakHashMap</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InheritableThreadLocal&lt;Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt; holder =</span><br><span class="line">            <span class="keyword">new</span> InheritableThreadLocal&lt;Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; initialValue() &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> WeakHashMap&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; childValue(Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; parentValue) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> WeakHashMap&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;(parentValue);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>holder 中数据的相关操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransmittableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 get()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T value = <span class="keyword">super</span>.get();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != value) addValue();</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 set()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.set(value);</span><br><span class="line">        <span class="comment">// may set null to remove value</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == value) removeValue();</span><br><span class="line">        <span class="keyword">else</span> addValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 remove()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        removeValue();</span><br><span class="line">        <span class="keyword">super</span>.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * holder 写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!holder.get().containsKey(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            holder.get().put(<span class="keyword">this</span>, <span class="keyword">null</span>); <span class="comment">// WeakHashMap supports null value.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * holder 删</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        holder.get().remove(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在线程A中写 TransmittableThreadLocal 时，便会将值放到 holder 的 map 中，holder 是一个ThreadLocal，也就是线程A持有的</li>
<li>在线程A中创建一个任务时，将 holder 保存的值保存到任务中，随任务一起传递到线程B中</li>
<li>在线程B中执行 TtlRunnable##run()</li>
</ol>
<p>可以看到 TtlRunnable 是把原任务做了一个包装，那么本身也是作为 Runnable，那么最关键的就是 run() 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TtlRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">TtlEnhanced</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 获取传递来的 ThreadLocal Map</span></span><br><span class="line">        Object captured = capturedRef.get();</span><br><span class="line">        <span class="keyword">if</span> (captured == <span class="keyword">null</span> || releaseTtlValueReferenceAfterRun &amp;&amp; !capturedRef.compareAndSet(captured, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"TTL value reference is released after run!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 核心方法</span></span><br><span class="line">        <span class="comment">// 执行前，使用传递来的 ThreadLocal Map，覆盖本地的 ThreadLocalMap</span></span><br><span class="line">        Object backup = replay(captured);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行实际的任务</span></span><br><span class="line">            runnable.run();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 回复本地的 ThreadLocalMap</span></span><br><span class="line">            restore(backup);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心方法 Transmitter##replay()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransmittableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Transmitter</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Nonnull</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">replay</span><span class="params">(@Nonnull Object captured)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 入参</span></span><br><span class="line">            Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; capturedMap = (Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;) captured;</span><br><span class="line">            <span class="comment">// 出参</span></span><br><span class="line">            Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; backup = <span class="keyword">new</span> HashMap&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. 迭代本线程中的 holder</span></span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;? extends Map.Entry&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt; iterator = holder.get().entrySet().iterator();</span><br><span class="line">                 iterator.hasNext(); ) &#123;</span><br><span class="line">                Map.Entry&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; next = iterator.next();</span><br><span class="line">                TransmittableThreadLocal&lt;?&gt; threadLocal = next.getKey();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 存储本线程中的 ThreadLocalMap 到 backup</span></span><br><span class="line">                backup.put(threadLocal, threadLocal.get());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3. 清除本线程中的 ThreadLocalMap</span></span><br><span class="line">                <span class="keyword">if</span> (!capturedMap.containsKey(threadLocal)) &#123;</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                    threadLocal.superRemove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 执行 ThreadLocal##set()</span></span><br><span class="line">            <span class="comment">// 将传递的 ThreadLocalMap 设置到本线程的 ThreadLocalMap 中</span></span><br><span class="line">            setTtlValuesTo(capturedMap);</span><br><span class="line"></span><br><span class="line">            doExecuteCallback(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> backup;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setTtlValuesTo</span><span class="params">(@Nonnull Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; ttlValues)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; entry : ttlValues.entrySet()) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                TransmittableThreadLocal&lt;Object&gt; threadLocal = (TransmittableThreadLocal&lt;Object&gt;) entry.getKey();</span><br><span class="line">                threadLocal.set(entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doExecuteCallback</span><span class="params">(<span class="keyword">boolean</span> isBefore)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; entry : holder.get().entrySet()) &#123;</span><br><span class="line">            TransmittableThreadLocal&lt;?&gt; threadLocal = entry.getKey();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (isBefore) threadLocal.beforeExecute();</span><br><span class="line">                <span class="keyword">else</span> threadLocal.afterExecute();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isLoggable(Level.WARNING)) &#123;</span><br><span class="line">                    logger.log(Level.WARNING, <span class="string">"TTL exception when "</span> + (isBefore ? <span class="string">"beforeExecute"</span> : <span class="string">"afterExecute"</span>) + <span class="string">", cause: "</span> + t.toString(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="TransmittableThreadLocal-流程总结："><a href="#TransmittableThreadLocal-流程总结：" class="headerlink" title="TransmittableThreadLocal 流程总结："></a>TransmittableThreadLocal 流程总结：</h2><ol>
<li>在线程A中写 TransmittableThreadLocal 时，便会将值放到 holder 的 map 中，holder 是一个ThreadLocal，也就是线程A持有的</li>
<li>在线程A中创建一个任务时，使用TtlRunnable做一层包装，将 holder 保存的值保存到任务中，随任务一起传递到线程B中</li>
<li>在线程B中执行 TtlRunnable##run()</li>
<li>执行前，使用传递来的 ThreadLocalMap，覆盖本地的 ThreadLocalMap</li>
<li>执行Runnable##run()</li>
<li>执行后，恢复本地的 ThreadLocalMap</li>
</ol>
<p>流程图：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTU2OTQ4NC8yMDE5MDIvMTU2OTQ4NC0yMDE5MDIyNjE0MTcyMjkyMi0xMDY0MDc1NzY4LnBuZw?x-oss-process=image/format,png" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>ThreadLocal 根本问题是由于这是一个线程无关的变量，而传递的本质是使用一个线程共享的变量进行传递值，因为线程共享，所以需要注意 线程安全问题</li>
<li>TransmittableThreadLocal 继承了 InheritableThreadLocal，因此在第一次被创建时，还是使用的 InheritableThreadLocal 的功能，而后在线程池中，从父线程中继承的 ThreadLocalMap，便是作为本地元素 ThreadLocalMap 被备份和恢复。</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>反射性能分析和代理原理</title>
    <url>/2020/05/28/Java/%E5%8F%8D%E5%B0%84%E4%B8%8E%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="反射性能分析和代理原理"><a href="#反射性能分析和代理原理" class="headerlink" title="反射性能分析和代理原理"></a>反射性能分析和代理原理</h1><h2 id="反射为什么效率差？"><a href="#反射为什么效率差？" class="headerlink" title="反射为什么效率差？"></a>反射为什么效率差？</h2><h3 id="一、结论"><a href="#一、结论" class="headerlink" title="一、结论"></a>一、结论</h3><ol>
<li>Method#invoke 方法会对参数做装箱和拆箱操作</li>
<li>需要检查方法可见性</li>
<li>需要校验参数</li>
<li>反射方法难以内联</li>
<li>JIT 无法优化</li>
</ol>
<h3 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h3><h4 id="1-使用案例："><a href="#1-使用案例：" class="headerlink" title="1. 使用案例："></a>1. 使用案例：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 创建 Class 对象</span></span><br><span class="line">            Class clazz = Class.forName(<span class="string">"com.zy.java.RefTest"</span>);</span><br><span class="line">            Object refTest = clazz.newInstance();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//2. 获取 Method 对象</span></span><br><span class="line">            Method method = clazz.getDeclaredMethod(<span class="string">"refMethod"</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//3. 调用 invoke 方法</span></span><br><span class="line">            method.invoke(refTest);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面从 <strong>获取 Method 对象</strong> 开始分析，方法<code>getMethod</code>/ <code>getDeclaredMethod</code>都可以用于获取 Method 对象</p>
<h4 id="2-getMethod-和-getDeclaredMethod-有什么区别？"><a href="#2-getMethod-和-getDeclaredMethod-有什么区别？" class="headerlink" title="2. getMethod 和 getDeclaredMethod 有什么区别？"></a>2. getMethod 和 getDeclaredMethod 有什么区别？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span> </span>&#123;</span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NoSuchMethodException, SecurityException </span>&#123;</span><br><span class="line">        Objects.requireNonNull(name);</span><br><span class="line">        SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 1. 检查方法权限</span></span><br><span class="line">            checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 获取方法</span></span><br><span class="line">        Method method = getMethod0(name, parameterTypes);</span><br><span class="line">        <span class="keyword">if</span> (method == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodException(methodToString(name, parameterTypes));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 返回方法的拷贝</span></span><br><span class="line">        <span class="keyword">return</span> getReflectionFactory().copyMethod(method);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Method <span class="title">getDeclaredMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NoSuchMethodException, SecurityException </span>&#123;</span><br><span class="line">        Objects.requireNonNull(name);</span><br><span class="line">        SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 1. 检查方法是权限</span></span><br><span class="line">            checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 获取方法</span></span><br><span class="line">        Method method = searchMethods(privateGetDeclaredMethods(<span class="keyword">false</span>), name, parameterTypes);</span><br><span class="line">        <span class="keyword">if</span> (method == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodException(methodToString(name, parameterTypes));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 返回方法的拷贝</span></span><br><span class="line">        <span class="keyword">return</span> getReflectionFactory().copyMethod(method);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取方法的流程分三步走：</p>
<ol>
<li>检查方法权限</li>
</ol>
<p>为什么<code>getMethod</code>中<code>checkMemberAccess</code>传入的是 <code>Member.PUBLIC</code>，而 <code>getDeclaredMethod</code>传入的是<code>Member.DECLARED</code>？<strong>这两个值有什么区别呢？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Identifies the set of all public members of a class or interface,</span></span><br><span class="line"><span class="comment">     * including inherited members.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">	 * 翻译：PUBLIC 会包括所有的 public 方法，包括父类的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PUBLIC = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Identifies the set of declared members of a class or interface.</span></span><br><span class="line"><span class="comment">     * Inherited members are not included.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 翻译：DECLARED 会包括所有自己定义的方法，public，protected，private 都在此，但是不包括父类的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DECLARED = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这也是<code>getMethod</code>和<code>getDeclaredMethod</code>的区别。</p>
<ol start="2">
<li><p>获取方法 Method 对象</p>
<p> <code>getMethod</code> 中获取方法调用的是 <code>getMethod0</code>，而 <code>getDeclaredMethod</code> 获取方法调用的是 </p>
<p> <code>privateGetDeclaredMethods</code>，实际上而 <code>getMethod0</code> 会递归查找父类的方法，最终会调用到 </p>
<p> <code>privateGetDeclaredMethods</code> 方法。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* publicOnly：是否只获取公共方法</span><br><span class="line">*/</span><br><span class="line">private Method[] privateGetDeclaredMethods(boolean publicOnly) &#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>返回方法的拷贝</p>
<p> 为什么是返回拷贝?</p>
</li>
</ol>
<h4 id="3-getMethod-分析"><a href="#3-getMethod-分析" class="headerlink" title="3. getMethod 分析"></a>3. getMethod 分析</h4><p><strong>流程一：检查方法权限做了什么事情？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkMemberAccess</span><span class="params">(SecurityManager sm, <span class="keyword">int</span> which,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   Class&lt;?&gt; caller, <span class="keyword">boolean</span> checkProxyInterfaces)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">         * 主要是为了检查是否可以访问对象成员。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> ClassLoader ccl = ClassLoader.getClassLoader(caller);</span><br><span class="line">        <span class="keyword">if</span> (which != Member.PUBLIC) &#123;</span><br><span class="line">            <span class="keyword">final</span> ClassLoader cl = getClassLoader0();</span><br><span class="line">            <span class="keyword">if</span> (ccl != cl) &#123;</span><br><span class="line">                sm.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.checkPackageAccess(sm, ccl, checkProxyInterfaces);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>流程二：如何获取 Method 对象？</strong></p>
<p>先看 getMethod0 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Method <span class="title">getMethod0</span><span class="params">(String name, Class&lt;?&gt;[] parameterTypes)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1. 获取到 MethodList 对象</span></span><br><span class="line">        PublicMethods.MethodList res = getMethodsRecursive(</span><br><span class="line">            name,</span><br><span class="line">            parameterTypes == <span class="keyword">null</span> ? EMPTY_CLASS_ARRAY : parameterTypes,</span><br><span class="line">            <span class="comment">/* includeStatic */</span> <span class="keyword">true</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2. 筛选返回值类型最为具体的方法</span></span><br><span class="line">        <span class="keyword">return</span> res == <span class="keyword">null</span> ? <span class="keyword">null</span> : res.getMostSpecific();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着看 getMethodsRecursive 方法，是如何获取方法的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PublicMethods.<span class="function">MethodList <span class="title">getMethodsRecursive</span><span class="params">(String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                         Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                         <span class="keyword">boolean</span> includeStatic)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 获取自己的 public 方法，这里调用了 privateGetDeclaredMethods 方法</span></span><br><span class="line">        Method[] methods = privateGetDeclaredMethods(<span class="comment">/* publicOnly */</span> <span class="keyword">true</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 筛选符合条件的方法，构造 MethodList 对象</span></span><br><span class="line">        PublicMethods.MethodList res = PublicMethods.MethodList</span><br><span class="line">            .filter(methods, name, parameterTypes, includeStatic);</span><br><span class="line">        <span class="comment">// 找到方法，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (res != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 没有找到方法，就获取其父类，递归调用 getMethodsRecursive 方法</span></span><br><span class="line">        Class&lt;?&gt; sc = getSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (sc != <span class="keyword">null</span>) &#123;</span><br><span class="line">            res = sc.getMethodsRecursive(name, parameterTypes, includeStatic);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 获取接口中对应的方法</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; intf : getInterfaces(<span class="comment">/* cloneArray */</span> <span class="keyword">false</span>)) &#123;</span><br><span class="line">            res = PublicMethods.MethodList.merge(</span><br><span class="line">                res, intf.getMethodsRecursive(name, parameterTypes,</span><br><span class="line">                                              <span class="comment">/* includeStatic */</span> <span class="keyword">false</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>为什么通过名字和参数拿到的是一个Method列表？</strong></p>
<p>编写 Java 代码时，同一个类是不能有方法名和方法参数都相同的方法</p>
<p>而实际上，在 JVM 中，一个方法签名是和 返回值、方法名、方法参数 三者相关的。</p>
<p>也就是说，在 JVM 中，可以存在 方法名和方法参数都相同，但是返回值不同的方法。</p>
<p>所以这里返回的是一个方法链表。</p>
<p>由 getMethodsRecursive 方法可知，最终还是会走到 privateGetDeclaredMethods 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Method[] privateGetDeclaredMethods(<span class="keyword">boolean</span> publicOnly) &#123;</span><br><span class="line">        Method[] res;</span><br><span class="line">        <span class="comment">// 1. 通过缓存获取 ReflectionData</span></span><br><span class="line">        ReflectionData&lt;T&gt; rd = reflectionData();</span><br><span class="line">        <span class="keyword">if</span> (rd != <span class="keyword">null</span>) &#123;</span><br><span class="line">            res = publicOnly ? rd.declaredPublicMethods : rd.declaredMethods;</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. ReflectionData中没有获取到方法列表，通过 JVM 的 getDeclaredMethods0 是一个本地方法</span></span><br><span class="line">        res = Reflection.filterMethods(<span class="keyword">this</span>, getDeclaredMethods0(publicOnly));</span><br><span class="line">        <span class="keyword">if</span> (rd != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (publicOnly) &#123;</span><br><span class="line">                rd.declaredPublicMethods = res;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rd.declaredMethods = res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看看 relectionData 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ReflectionData&lt;T&gt; <span class="title">reflectionData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//1. 获取可能存在的 ReflectionData 的软引用对象</span></span><br><span class="line">        SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData = <span class="keyword">this</span>.reflectionData;</span><br><span class="line">        <span class="keyword">int</span> classRedefinedCount = <span class="keyword">this</span>.classRedefinedCount;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2. 如果软引用有值，直接返回</span></span><br><span class="line">        ReflectionData&lt;T&gt; rd;</span><br><span class="line">        <span class="keyword">if</span> (reflectionData != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (rd = reflectionData.get()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            rd.redefinedCount == classRedefinedCount) &#123;</span><br><span class="line">            <span class="keyword">return</span> rd;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3. 如果没有 重新生成</span></span><br><span class="line">        <span class="keyword">return</span> newReflectionData(reflectionData, classRedefinedCount);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ReflectionData对象中保存了类的类型信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> Field[] declaredFields;</span><br><span class="line">        <span class="keyword">volatile</span> Field[] publicFields;</span><br><span class="line">        <span class="keyword">volatile</span> Method[] declaredMethods;</span><br><span class="line">        <span class="keyword">volatile</span> Method[] publicMethods;</span><br><span class="line">        <span class="keyword">volatile</span> Constructor&lt;T&gt;[] declaredConstructors;</span><br><span class="line">        <span class="keyword">volatile</span> Constructor&lt;T&gt;[] publicConstructors;</span><br><span class="line">        <span class="comment">// Intermediate results for getFields and getMethods</span></span><br><span class="line">        <span class="keyword">volatile</span> Field[] declaredPublicFields;</span><br><span class="line">        <span class="keyword">volatile</span> Method[] declaredPublicMethods;</span><br><span class="line">        <span class="keyword">volatile</span> Class&lt;?&gt;[] interfaces;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Cached names</span></span><br><span class="line">        String simpleName;</span><br><span class="line">        String canonicalName;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> String NULL_SENTINEL = <span class="keyword">new</span> String();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Value of classRedefinedCount when we created this ReflectionData instance</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> redefinedCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是 getMethod 方法的整个实现了。</p>
<p>再回过头看一下 getDeclaredMethod 方法的实现，通过 privateGetDeclaredMethods 获取方法以后，会通过 searchMethods 对方法进行筛选：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getDeclaredMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NoSuchMethodException, SecurityException </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	Method method = searchMethods(privateGetDeclaredMethods(<span class="keyword">false</span>), name, parameterTypes);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Method <span class="title">searchMethods</span><span class="params">(Method[] methods,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Class&lt;?&gt;[] parameterTypes)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ReflectionFactory fact = getReflectionFactory();</span><br><span class="line">        Method res = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">            <span class="comment">//1. 比较方法名</span></span><br><span class="line">            <span class="keyword">if</span> (m.getName().equals(name)</span><br><span class="line">                <span class="comment">//2. 比较方法参数</span></span><br><span class="line">                &amp;&amp; arrayContentsEq(parameterTypes,</span><br><span class="line">                                   fact.getExecutableSharedParameterTypes(m))</span><br><span class="line">                <span class="comment">//3. 比较返回值 会选择返回最具体的那一个</span></span><br><span class="line">                &amp;&amp; (res == <span class="keyword">null</span></span><br><span class="line">                    || (res.getReturnType() != m.getReturnType()</span><br><span class="line">                        &amp;&amp; res.getReturnType().isAssignableFrom(m.getReturnType()))))</span><br><span class="line">                res = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>流程三：Method#copy</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Method</span> </span>&#123;</span><br><span class="line">    <span class="function">Method <span class="title">copy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// This routine enables sharing of MethodAccessor objects</span></span><br><span class="line">        <span class="comment">// among Method objects which refer to the same underlying</span></span><br><span class="line">        <span class="comment">// method in the VM. (All of this contortion is only necessary</span></span><br><span class="line">        <span class="comment">// because of the "accessibility" bit in AccessibleObject,</span></span><br><span class="line">        <span class="comment">// which implicitly requires that new java.lang.reflect</span></span><br><span class="line">        <span class="comment">// objects be fabricated for each reflective call on Class</span></span><br><span class="line">        <span class="comment">// objects.)</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Can not copy a non-root Method"</span>);</span><br><span class="line"></span><br><span class="line">        Method res = <span class="keyword">new</span> Method(clazz, name, parameterTypes, returnType,</span><br><span class="line">                                exceptionTypes, modifiers, slot, signature,</span><br><span class="line">                                annotations, parameterAnnotations, annotationDefault);</span><br><span class="line">        res.root = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// Might as well eagerly propagate this if already present</span></span><br><span class="line">        res.methodAccessor = methodAccessor;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一次返回的Method对象其实都是一个新的对象，但是：</p>
<ol>
<li>新对象的root属性都指向源Method对象</li>
<li>methodAccessor是所有对象共享的</li>
</ol>
<h4 id="4-invoke-分析"><a href="#4-invoke-分析" class="headerlink" title="4. invoke 分析"></a>4. invoke 分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span></span><br><span class="line"><span class="function">        InvocationTargetException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 1. 权限检查</span></span><br><span class="line"><span class="comment">    * 如果 override == true，就跳过检查</span></span><br><span class="line"><span class="comment">    * 调用 Method#setAccessible(true)，就是设置 override 值为 true</span></span><br><span class="line"><span class="comment">    * 首次可能为空 因此去创建 MethodAccessor</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 2. 获取 methodAccessor</span></span><br><span class="line"><span class="comment">    * 这里的 methodAccessor 就是拷贝时使用的 MethodAccessor</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    MethodAccessor ma = methodAccessor;</span><br><span class="line">    <span class="keyword">if</span> (ma == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ma = acquireMethodAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="comment">//3. 调用</span></span><br><span class="line">    <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首次调用 MethodAccessor 为空，因此进入 acquireMethodAccessor() 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MethodAccessor <span class="title">acquireMethodAccessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    MethodAccessor tmp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//1. 从root的MethodAccessor中获取</span></span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) tmp = root.getMethodAccessor();</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">        methodAccessor = tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//2. 新生成 MethodAccessor</span></span><br><span class="line">        tmp = reflectionFactory.newMethodAccessor(<span class="keyword">this</span>);</span><br><span class="line">        setMethodAccessor(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后便会执行 MethodAccessor 的invoke，那么 <strong>MethodAccessor 到底做了什么呢？</strong></p>
<p>简单来说，MethodAccessor 做了两件事：</p>
<ol>
<li>解析参数，解封操作</li>
<li>调用对象的方法</li>
</ol>
<p>那么这里有两类MethodAccessor ：</p>
<ol>
<li>默认 Native 版本的 MethodAccessor 实现——NativeMethodAccessorImpl</li>
<li>Java 版本的 MethodAccessor 实现—— MethodAccessorImpl</li>
</ol>
<p><strong>为什么会有两类？</strong></p>
<p>因为<em>跨越native边界会对优化有阻碍作用，它就像个黑箱一样让虚拟机难以分析也将其内联，于是运行时间长了之后反而是java版本的代码更快些</em>。</p>
<p>Java 版本的 MethodAccessorImpl 调用效率比 Native 版本要快 20 倍以上，但是 Java 版本加载时要比 Native 多消耗 3-4 倍资源，所以默认会调用 Native 版本，如果调用次数超过 15 次以后，就会选择运行效率更高的 Java 版本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//java版本的 MethodAccessor，相当于执行 A.foo(&quot;aaa&quot;) </span><br><span class="line">package sun.reflect;</span><br><span class="line"></span><br><span class="line">public class GeneratedMethodAccessor1 extends MethodAccessorImpl &#123;    </span><br><span class="line">    public GeneratedMethodAccessor1() &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Object invoke(Object obj, Object[] args)   </span><br><span class="line">        throws IllegalArgumentException, InvocationTargetException &#123;</span><br><span class="line">        // 1. 拆箱，转换</span><br><span class="line">        if (obj == null) throw new NullPointerException();</span><br><span class="line">        try &#123;</span><br><span class="line">            A target = (A) obj;</span><br><span class="line">            if (args.length != 1) throw new IllegalArgumentException();</span><br><span class="line">            String arg0 = (String) args[0];</span><br><span class="line">        &#125; catch (ClassCastException e) &#123;</span><br><span class="line">            throw new IllegalArgumentException(e.toString());</span><br><span class="line">        &#125; catch (NullPointerException e) &#123;</span><br><span class="line">            throw new IllegalArgumentException(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        //2. 调用</span><br><span class="line">        try &#123;</span><br><span class="line">            target.foo(arg0);</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            throw new InvocationTargetException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常用代理技术"><a href="#常用代理技术" class="headerlink" title="常用代理技术"></a>常用代理技术</h2><h3 id="JDK代理"><a href="#JDK代理" class="headerlink" title="JDK代理"></a>JDK代理</h3><p><a href="https://www.cnblogs.com/monkey0307/p/8276810.html" target="_blank" rel="noopener">jdk代理分析</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代理类反编译</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler paramInvocationHandler) &#123;</span><br><span class="line">        <span class="keyword">super</span>(paramInvocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">displayUser</span><span class="params">(String paramString)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;paramString&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        m3 = Class.forName(<span class="string">"com.demo.proxy.jdk.UserService"</span>).getMethod(<span class="string">"displayUser"</span>, <span class="keyword">new</span> Class[]&#123;Class.forName(<span class="string">"java.lang.String"</span>)&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代理类反编译</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonService</span>$$<span class="title">EnhancerByCGLIB</span>$$<span class="title">eaaaed75</span> <span class="keyword">extends</span> <span class="title">PersonService</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> CGLIB$BOUND;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal CGLIB$THREAD_CALLBACKS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Callback[] CGLIB$STATIC_CALLBACKS;</span><br><span class="line">    <span class="keyword">private</span> MethodInterceptor CGLIB$CALLBACK_0;<span class="comment">//拦截器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$setPerson$<span class="number">0</span>$Method;<span class="comment">//被代理方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$setPerson$<span class="number">0</span>$Proxy;<span class="comment">//代理方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] CGLIB$emptyArgs;<span class="comment">//方法参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> CGLIB$STATICHOOK1() &#123;</span><br><span class="line">        CGLIB$THREAD_CALLBACKS = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        CGLIB$emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line">        Class localClass1 = Class.forName(<span class="string">"com.demo.proxy.cglib.PersonService$$EnhancerByCGLIB$$eaaaed75"</span>);<span class="comment">//代理类</span></span><br><span class="line">        Class localClass2;<span class="comment">//被代理类PersionService</span></span><br><span class="line"></span><br><span class="line">        Method[] tmp223_220 = ReflectUtils.findMethods(<span class="keyword">new</span> String[]&#123;<span class="string">"setPerson"</span>, <span class="string">"()V"</span>&#125;, (localClass2 = Class.forName(<span class="string">"com.demo.proxy.cglib.PersonService"</span>)).getDeclaredMethods());</span><br><span class="line">        CGLIB$setPerson$<span class="number">0</span>$Method = tmp223_220[<span class="number">0</span>];</span><br><span class="line">        CGLIB$setPerson$<span class="number">0</span>$Proxy = MethodProxy.create(localClass2, localClass1, <span class="string">"()V"</span>, <span class="string">"setPerson"</span>, <span class="string">"CGLIB$setPerson$0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//methodProxy.invokeSuper会调用</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> CGLIB$setPerson$<span class="number">0</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.setPerson();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//methodProxy.invoke会调用，这就是为什么在拦截器中调用methodProxy.invoke会死循环，一直在调用拦截器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MethodInterceptor var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> (var10000 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//调用拦截器</span></span><br><span class="line">            var10000.intercept(<span class="keyword">this</span>, CGLIB$setPerson$<span class="number">0</span>$Method, CGLIB$emptyArgs, CGLIB$setPerson$<span class="number">0</span>$Proxy);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.setPerson();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/monkey0307/p/8328821.html" target="_blank" rel="noopener">Cglib代理分析</a></p>
<p><strong>Method 和 MethodProxy 有什么区别？</strong></p>
<p>MethodProxy 是 cglib 为了避免反射使用的一种代替方式，但是功能是一样的。</p>
<h3 id="cglib与jdk代理对比？"><a href="#cglib与jdk代理对比？" class="headerlink" title="cglib与jdk代理对比？"></a>cglib与jdk代理对比？</h3><ol>
<li>JDK动态代理是实现了被代理对象的接口，Cglib是继承了被代理对象。</li>
<li>JDK和Cglib都是在运行期生成字节码，JDK是直接写Class字节码，Cglib使用ASM框架写Class字节码，Cglib代理实现更复杂，生成代理类比JDK效率低。</li>
<li>JDK调用代理方法，是通过反射机制调用，Cglib是通过FastClass机制直接调用方法，Cglib执行效率更高。</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库数据存储结构</title>
    <url>/2018/09/28/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="InnoDB记录存储结构"><a href="#InnoDB记录存储结构" class="headerlink" title="InnoDB记录存储结构"></a>InnoDB记录存储结构</h1><h2 id="InnoDB页"><a href="#InnoDB页" class="headerlink" title="InnoDB页"></a>InnoDB页</h2><p>将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 16KB</p>
<h2 id="行格式"><a href="#行格式" class="headerlink" title="行格式"></a>行格式</h2><p>数据在磁盘上存储的格式也叫做行格式<br>InnoDB的设计者设计了多种行格式，主要的有下面4种。</p>
<p>两个问题：</p>
<ol>
<li>行格式中计算机如何区别每个部分？</li>
<li>列中名字如何和数据对应起来？</li>
</ol>
<h3 id="COMPACT行格式"><a href="#COMPACT行格式" class="headerlink" title="COMPACT行格式"></a>COMPACT行格式</h3><p><img src="/2018/09/28/MySQL/数据库数据存储结构/1.png" alt="compact行格式"></p>
<p>额外信息：服务器为了描述这条记录而不得不额外添加的一些信息。</p>
<ul>
<li><p>变长字段长度列表：把所有变长类型实际长度都存放在记录的开头部位形成一个列表，按照列的顺序逆序存放。</p>
<blockquote>
<p>实际长度大于1个字节会用两个字节，具体是使用一个字节还是两个字节取决内容的实际长度。判断规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//W=表示编码格式，ASCII-1，GBK-2,UTF8-3,</span><br><span class="line">//M=表示变长的最大字符</span><br><span class="line">//L=表示实际字节数</span><br><span class="line">if W_M&amp;lt;256:1个字节</span><br><span class="line">if W_M&gt;=256</span><br><span class="line">&#123;</span><br><span class="line">  L&amp;lt;128:1个字节</span><br><span class="line">  L&gt;=128:2个字节</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>NULL值列表：记录数据为NULL的列</p>
<p><img src="/2018/09/28/MySQL/数据库数据存储结构/2.png" alt="NULL列表"></p>
<ol>
<li>先统计允许存储NULL的列，如果表中没有允许存储 NULL 的列，则 NULL值列表 也不存在了。</li>
<li>将每个允许存储NULL的列对应一个二进制位，二进制位按照列的顺序逆序排列。</li>
<li>MySQL规定NULL值列表必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补0。</li>
</ol>
</li>
<li><p>记录头信息：</p>
<p><img src="/2018/09/28/MySQL/数据库数据存储结构/3.png" alt="记录头信息"></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小（单位：bit）</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Retention 1</td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td>Retention 2</td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td>delete_mask</td>
<td>1</td>
<td>标记该记录是否被删除</td>
</tr>
<tr>
<td>min_rec_mask</td>
<td>1</td>
<td>标记该记录是否为B+树的非叶子节点中的最小记录</td>
</tr>
<tr>
<td>n_owned</td>
<td>4</td>
<td>表示当前槽管理的记录数</td>
</tr>
<tr>
<td>heap_no</td>
<td>13</td>
<td>表示当前记录在记录堆的位置信息</td>
</tr>
<tr>
<td>record_type</td>
<td>3</td>
<td>表示当前记录的类型，0表示普通记录，1表示B+树非叶节点记录，2表示最小记录，3表示最大记录</td>
</tr>
<tr>
<td>next_record</td>
<td>16</td>
<td>表示下一条记录的相对位置</td>
</tr>
</tbody>
</table>
<ul>
<li>数据信息：mysql会为每个记录增加默认列</li>
</ul>
<table>
<thead>
<tr>
<th>列名</th>
<th>是否必须</th>
<th>占用空间</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>row_id</td>
<td>否</td>
<td>6字节</td>
<td>行ID，唯一标识一条记录</td>
</tr>
<tr>
<td>transaction_id</td>
<td>是</td>
<td>6字节</td>
<td>事务ID</td>
</tr>
<tr>
<td>roll_pointer</td>
<td>是</td>
<td>7字节</td>
<td>回滚指针</td>
</tr>
</tbody>
</table>
<blockquote>
<p>  注意：<br>  CHAR(10)类型，除真实数据以外的8个字节的统统都用空格字符填充<br>  如果主键已经指定了，那么row_id的列就不会自动添加</p>
</blockquote>
<h3 id="Redundant行格式"><a href="#Redundant行格式" class="headerlink" title="Redundant行格式"></a>Redundant行格式</h3><p><img src="/2018/09/28/MySQL/数据库数据存储结构/4.png" alt="Redundant行格式"></p>
<p>有些区别，不过大致相同。<br>采用了偏移量来实现，头信息中略有区别，NULL值也会存储。</p>
<h2 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h2><h3 id="VARCHAR-M-最多能存储的数据"><a href="#VARCHAR-M-最多能存储的数据" class="headerlink" title="VARCHAR(M)最多能存储的数据"></a>VARCHAR(M)最多能存储的数据</h3><p>COMPACT行格式中，可变长的长度记录最多可以达到2个字节，也就是内容65535个字节，其中包括可变字符长度列表中长度的记录需要2个字节，NULL列表中的1个字节（非NULL则无），于是真实的内容占65532(或者65533),在不同的编码下对应的不同数量的字符长度。</p>
<h3 id="记录中的数据太多产生的溢出"><a href="#记录中的数据太多产生的溢出" class="headerlink" title="记录中的数据太多产生的溢出"></a>记录中的数据太多产生的溢出</h3><ul>
<li>而一个页的大小一般是16KB，也就是16384字节，而一个VARCHAR(M)类型的列就最多可以存储65532个字节，这样就可能造成一个页存放不了一条记录的尴尬情况。</li>
<li>在Compact和Reduntant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分（768个字节）数据，把剩余的数据分散存储在几个连续的页中，只在记录的真实数据处用20个字节存储指向这些页的地址，从而可以找到剩余数据所在的页。</li>
</ul>
<p><img src="/2018/09/28/MySQL/数据库数据存储结构/5.png" alt="行溢出"></p>
<p>除了varchar,text和blob类型都会有这个现象。</p>
<h2 id="Dynamic和Compressed行格式"><a href="#Dynamic和Compressed行格式" class="headerlink" title="Dynamic和Compressed行格式"></a>Dynamic和Compressed行格式</h2><ul>
<li>基本和COMPACT格式一样</li>
<li>Dynamic和Compressed行格式，它们不会在记录的真实数据处存储字符串的前768个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址。</li>
<li>Compressed行格式和Dynamic不同的一点是，Compressed行格式会把存储到其他页面的数据采用压缩算法进行压缩，以节省空间。</li>
</ul>
<h1 id="InnoDB数据页结构"><a href="#InnoDB数据页结构" class="headerlink" title="InnoDB数据页结构"></a>InnoDB数据页结构</h1><h2 id="数据页结构"><a href="#数据页结构" class="headerlink" title="数据页结构"></a>数据页结构</h2><p><img src="/2018/09/28/MySQL/数据库数据存储结构/6.png" alt="数据页结构"></p>
<p><img src="/2018/09/28/MySQL/数据库数据存储结构/7.png" alt="数据页结构"></p>
<h2 id="记录行在页中的存储"><a href="#记录行在页中的存储" class="headerlink" title="记录行在页中的存储"></a>记录行在页中的存储</h2><p>用户的数据会按照指定的行格式存储到UserRecords中，这个部分一开始是不存在的，而是从Free Space这个部分中一点点的划分出。</p>
<p><img src="/2018/09/28/MySQL/数据库数据存储结构/8.png" alt="记录在页中的存储"><br>那么记录行在页中是如何存储的呢？</p>
<h2 id="记录头信息解析"><a href="#记录头信息解析" class="headerlink" title="记录头信息解析"></a>记录头信息解析</h2><p>再次回顾头信息里的字节含义：</p>
<table>
<thead>
<tr>
<th>name</th>
<th>大小（单位：bit）</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Retention1</td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td>Retention2</td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td>delete_mask</td>
<td>1</td>
<td>标记该记录是否被删除</td>
</tr>
<tr>
<td>min_rec_mask</td>
<td>1</td>
<td>标记该记录是否为B+树的非叶子节点中的最小记录</td>
</tr>
<tr>
<td>n_owned</td>
<td>4</td>
<td>表示当前槽管理的记录数</td>
</tr>
<tr>
<td>heap_no</td>
<td>13</td>
<td>表示当前记录在记录堆的位置信息</td>
</tr>
<tr>
<td>record_type</td>
<td>3</td>
<td>表示当前记录的类型，0表示普通记录，1表示B+树非叶节点记录，2表示最小记录，3表示最大记录</td>
</tr>
<tr>
<td>next_record</td>
<td>16</td>
<td>表示下一条记录的相对位置</td>
</tr>
</tbody>
</table>
<ul>
<li>delete_mask：该记录行是否删除，删除的数据并不会立刻消息，而是标记，待重排列的时候统一处理，另外，已删除的数据空间是可以被覆盖的。</li>
<li>min_rec_mask：这个属性标记该记录是否为B+树的非叶子节点中的最小记录，之后详解。</li>
<li>n_owned：当前页管理的记录数，待详解。</li>
<li>heap_no：表示该记录在页中的（相对）位置，从2开始，因为在infimum+supremum中已经存在了两条“最小记录”和“最大记录”的记录。</li>
<li>record_type：0表示普通记录，1表示B+树非叶节点记录，2表示最小记录，3表示最大记录。</li>
<li>next_record：记录在页中存储的数据结构类似于单链表，因此这个数据表示类似链表中的指针，大小表示从当前真实数据到下一个真实数据的距离。</li>
</ul>
<p><img src="/2018/09/28/MySQL/数据库数据存储结构/9.png" alt="记录存储结构"></p>
<p>当记录被删除，并不会从页中立刻消失，而是地址的指向发生变化。</p>
<p><img src="/2018/09/28/MySQL/数据库数据存储结构/10.png" alt="记录被删除后的变化"></p>
<p>如果我们想找某条数据，当然也可以遍历这条链表进行查找，但是这样效率不高。</p>
<p>一个好的灵感来自书的目录，按章节区分，先确定所属的章，再从章中去找节。</p>
<p>这个“章”在InnoDB中以偏移量来表示，称为“槽”。<br>槽中存放着所有正常记录（包括最小、最大不包括删除的记录）<br>每个槽的偏移量以最后一条记录的地址的偏移量来赋值。<br>最后一条记录中的n_owned表示在当前槽中有多少个记录。</p>
<p><img src="/2018/09/28/MySQL/数据库数据存储结构/11.png" alt="优化记录搜索"></p>
<p>规定：对于最小记录所在的分组只能有 1 条记录，最大记录所在的分组拥有的记录条数只能在 1~8 条之间，剩下的分组中记录的条数范围只能在是 4~8 条之间。</p>
<p>这样处理之后：查询的过程可以简化为下面两个步骤：</p>
<ol>
<li>通过二分法确定该记录所在的槽。</li>
<li>通过记录的next_record属性组成的链表遍历查找该槽中的各个记录</li>
</ol>
<h2 id="Page-Header"><a href="#Page-Header" class="headerlink" title="Page Header"></a>Page Header</h2><table>
<thead>
<tr>
<th>名称</th>
<th>占用空间大小</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>PAGE_N_DIR_SLOTS</td>
<td>2字节</td>
<td>在页目录中的槽数量</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td>2字节</td>
<td>第一个记录的地址</td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td>2字节</td>
<td>本页中的记录的数量（包括最小和最大记录以及标记为删除的记录v）</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td>2字节</td>
<td>指向可重用空间的地址（就是标记为删除的记录地址）</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td>2字节</td>
<td>已删除的字节数，行记录结构中delete_flag为1的记录大小总数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td>2字节</td>
<td>最后插入记录的位置</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td>2字节</td>
<td>最后插入的方向</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td>2字节</td>
<td>一个方向连续插入的记录数量</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td>2字节</td>
<td>该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td>8字节</td>
<td>修改当前页的最大事务ID，该值仅在二级索引中定义</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td>2字节</td>
<td>当前页在索引树中的位置，高度</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td>8字节</td>
<td>索引ID，表示当前页属于哪个索引</td>
</tr>
<tr>
<td>PAGE_BTR</td>
<td>10字节</td>
<td>非叶节点所在段的segment header，仅在B+树的Root页定义</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td>10字节</td>
<td>B+树所在段的segment header，仅在B+树的Root页定义</td>
</tr>
</tbody>
</table>
<ul>
<li>PAGE_DIRECTION:新插入的一条记录的主键值比上一条记录的主键值大，我们说这条记录的插入方向是右边，反之则是左边。</li>
<li>PAGE_N_DIRECTION：假设连续几次插入新记录的方向都是一致的，InnoDB会把沿着同一个方向插入记录的条数记下来。</li>
</ul>
<h2 id="File-Header"><a href="#File-Header" class="headerlink" title="File Header"></a>File Header</h2><p>Page Header：记录页内的相关信息<br>File Header：记录页外的相关信息</p>
<p><img src="/2018/09/28/MySQL/数据库数据存储结构/12.png" alt="文件头中的字节含义"></p>
<ul>
<li>FIL_PAGE_SPACE_OR_CHKSUM：表示当前页面的校验和，对于一个很长很长的字节串来说，我们会通过某种算法来计算一个比较短的值来代表这个很长的字节串，这个比较短的值就称为校验和。比较页之前可以先比较校验和，如果校验和都不一致，那么页面一定不一样，可以大大的节省时间。</li>
<li>FIL_PAGE_OFFSET：页号。唯一标识。</li>
<li><p>FIL_PAGE_TYPE：一般存放记录的数据页的类型其实是FIL_PAGE_INDEX，也就是所谓的B+树叶子节点</p>
<p><img src="/2018/09/28/MySQL/数据库数据存储结构/13.png" alt="页类型"></p>
</li>
<li><p>FIL_PAGE_PREV和FIL_PAGE_NEXT：一张表中可以有成千上万条记录，一个页只有16KB，所以可能需要好多页来存放数据，FIL_PAGE_PREV和FIL_PAGE_NEXT就分别代表本页的上一个和下一个页的页号。需要注意的是，并不是所有类型的页都有上一个和下一个页的属性。</p>
</li>
</ul>
<h2 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h2><p>如果在数据同步的过程中断电了怎么办？<br>在页尾同样加上4个字节的校验和做前后对比，判断数据是否正常。<br>另外还有4个字节的LSN日志序列位置，用来处理如果前后校验和不一致的时候，来回滚数据。</p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="没有索引的情况"><a href="#没有索引的情况" class="headerlink" title="没有索引的情况"></a>没有索引的情况</h2><ul>
<li>单页查找：<ol>
<li>以主键为搜索条件：之前讲过页目录和槽的概念，因此这里可以使用目录页的二分法来快速定位。　</li>
<li>以其它列为搜索条件：这时候没有建立相应的目录，因此需要从从最小记录开始全部遍历一遍。</li>
</ol>
</li>
<li>多页查找：<br>由于我们并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表一直往下找，在每一个页中根据单页查找的方式去查找指定的记录。</li>
</ul>
<p>显然，这种查找的效率实在是太低了。</p>
<h2 id="一个简单的索引"><a href="#一个简单的索引" class="headerlink" title="一个简单的索引"></a>一个简单的索引</h2><p>先来看一下页中记录的简化图：</p>
<p><img src="/2018/09/28/MySQL/数据库数据存储结构/14.png" alt="页中记录的简化"></p>
<p>当一个页装不下之后会装到多个页中，并且这些页可能都是不连续的，但是满足<strong>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值</strong>这样的一个规律。效果如下：</p>
<p><img src="/2018/09/28/MySQL/数据库数据存储结构/15.png" alt="分页记录效果"></p>
<p>现在建立一个目录，目录中的每一项包含页数和最小主键值两项数据：</p>
<p><img src="/2018/09/28/MySQL/数据库数据存储结构/16.png" alt="目录项"></p>
<p>这个目录就叫索引。</p>
<h2 id="InnoDB中的索引方案"><a href="#InnoDB中的索引方案" class="headerlink" title="InnoDB中的索引方案"></a>InnoDB中的索引方案</h2><p>为了更灵活的管理目录项，采取页的方式同样的去存储目录的信息：</p>
<p><img src="/2018/09/28/MySQL/数据库数据存储结构/17.png" alt="目录页"></p>
<p>如何区别页中的数据是用户数据还是目录数据？</p>
<ul>
<li>目录项记录行格式中的record_type为1。</li>
<li>目录项记录主键值和页的编号两个列。</li>
<li>只有在存储目录项记录的页中的主键值最小的目录项记录的min_rec_mask值为1，其他别的记录的min_rec_mask值都是0。</li>
</ul>
<p>除此之外没有其他区别，他们的页面类型都是0x45BF</p>
<p>再做查询：</p>
<ol>
<li>先查询记录存在的页（由于不唯一，可能存在多个页中）</li>
<li>在页中做之前提到的单页查询。</li>
</ol>
<p>虽然说目录项记录中只存储主键值和对应的页号，比用户记录需要的存储空间小多了，但是不论怎么说一个页只有16KB大小，能存放的目录项记录也是有限的，如果目录项太多，一个页面放不下，就需要多个页面，这时候就需要采取同样的方式对多个目录页再建立一个目录页。</p>
<p><img src="/2018/09/28/MySQL/数据库数据存储结构/18.png" alt="B+树"></p>
<p>实际用户记录其实都存放在B+树的最底层的节点上，这些节点也被称为叶子节点或叶节点。</p>
<h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><ol>
<li>按主键大小记录行和页。<ul>
<li>页内按主键大小顺序构成单链表</li>
<li>页之前按主键大小顺序构成双链表</li>
</ul>
</li>
<li>B+树的叶子节点存储的是完整的用户记录。</li>
</ol>
<p>这种聚簇索引并不需要我们在MySQL语句中显式的去创建，InnoDB存储引擎会自动的为我们创建聚簇索引。另外有趣的一点是，在InnoDB存储引擎中，聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的索引即数据。</p>
<h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><p>聚簇索引通过主键大小顺序来记录，但是如果我们的查询条件不是主键，就不起作用了。<br>因此需要建立新的索引树，称为二级索引：</p>
<p><img src="/2018/09/28/MySQL/数据库数据存储结构/19.png" alt="二级索引"></p>
<p>与聚簇索引的区别：</p>
<ol>
<li>真实内容中只有主键和对应的索引列。</li>
<li>以索引列的大小进行记录。</li>
</ol>
<p>因为二级索引的页节点中只有主键和对应的索引列，所以想要查询完整的数据，必须再根据主键值去聚簇索引中再查找一遍完整的用户记录。</p>
<h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>使用多个列建立的二级索引就是联合索引。<br>联合索引先通过第一个字段顺序记录，在第一个记录大小一致的时候通过第二个字段顺序记录。</p>
<p><img src="/2018/09/28/MySQL/数据库数据存储结构/20.png" alt="联合索引"></p>
<h2 id="MyISAM中的索引方案"><a href="#MyISAM中的索引方案" class="headerlink" title="MyISAM中的索引方案"></a>MyISAM中的索引方案</h2><p>InnoDB中索引的叶节点中存储了所有的数据，因此索引即数据。<br>而MyISAM中索引和数据分开了。将表中的记录按照插入时间顺序的存储在一块存储空间上，可以通过行号来访问（定长的情况）。</p>
<p><img src="/2018/09/28/MySQL/数据库数据存储结构/21.png" alt="MyISAM数据存储"></p>
<p>MyISAM一开始会为主键创建一个B+树索引，只是这个索引的数据只有主键和行号。中建立的索引全部都是二级索引</p>
<h2 id="MySQL中创建和删除索引的语句"><a href="#MySQL中创建和删除索引的语句" class="headerlink" title="MySQL中创建和删除索引的语句"></a>MySQL中创建和删除索引的语句</h2><p>MySql会自动的为主键和UNIQUE字段建立聚簇索引。</p>
<p>手动创建：</p>
<ol>
<li>建表时：INDEX 索引名 (需要被索引的单个列或多个列)</li>
<li>建表后：ALTER TABLE 表名 ADD [INDEX|KEY] 索引名 (需要被索引的单个列或多个列)</li>
</ol>
<p>手动删除：<br>ALTER TABLE 表名 DROP [INDEX|KEY] 索引名;</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL索引</tag>
        <tag>InnoDB记录存储结构</tag>
        <tag>InnoDB数据页结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring AOP 实现</title>
    <url>/2020/05/25/Spring/AOP%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="Spring-AOP-实现"><a href="#Spring-AOP-实现" class="headerlink" title="Spring AOP 实现"></a>Spring AOP 实现</h1><h2 id="AOP概述"><a href="#AOP概述" class="headerlink" title="AOP概述"></a>AOP概述</h2><p><strong>为什么需要AOP？</strong></p>
<p>问题一：如何减少重复的代码？</p>
<p>将重复的代码抽离出来，在多个地方显示地声明调用</p>
<p>问题二：如何减少“声明调用”的代码重复？</p>
<p>再抽离，再显示地声明？</p>
<p>问题三：根据需要，每个地方的“声明调用”可能不完全相同，这是就无法统一抽离，并且这些“重复”可能是业务无关的，不应该在业务中进行“声明调用”</p>
<p>为了解决问题三，提出了AOP</p>
<p>AOP概念抽象：</p>
<ol>
<li>连接点：业务代码块的边界处，可以使用声明进行功能的增强</li>
<li>切点：可以认为是连接点筛选的一个条件</li>
<li>通知：增强的相关逻辑</li>
<li>通知器：将切点和通知结合起来</li>
<li>织入：将通知写入到连接点的过程</li>
</ol>
<p>根据织入的时间点可以分为：</p>
<ol>
<li>编译器织入：生成已增强的.class</li>
<li>加载器织入：加载.class时完成增强</li>
<li>运行期织入：运行时动态生成增强代理类</li>
</ol>
<p><strong>spring AOP 和 AspectJ 的区别与联系？</strong></p>
<p>AspectJ 主要的织入方式是编译器织入和加载器织入</p>
<p>spring AOP 主要的织入方式是运行期织入，使用JDK代理或者Cglib代理</p>
<p>spring AOP 可以基于 xml 实现通知器的配置，也可以基于 AspectJ 的注解实现通知器的配置，但最终都会适配为对拦截器的处理（详细见后）</p>
<h2 id="Spring-AOP-设计与实现"><a href="#Spring-AOP-设计与实现" class="headerlink" title="Spring AOP 设计与实现"></a>Spring AOP 设计与实现</h2><h3 id="接口体系"><a href="#接口体系" class="headerlink" title="接口体系"></a>接口体系</h3><p><img src="/2020/05/25/Spring/AOP的实现/image-20200602105702787.png" alt="image-20200602105702787"></p>
<ul>
<li><p>ProxyConfig：代理的配置类，为其 AOP 代理对象工厂实现类提供基本的配置属性</p>
</li>
<li><p>Adivised：接口，定义了代理配置信息的获取方法，以及对 AOP 中通知、通知器、目标对象等的装配方法</p>
</li>
<li><p>AdivisedSupport：Adivised 的实现类，基于 ProxyConfig</p>
</li>
<li><p>ProxyCreatorSupport：基于 AdivisedSupport 中 AOP 配置和代理配置，提供生成代理类的功能（使用默认的代理对象工厂实现DefaultAopProxyFactory，该工厂基于 jdk 和 cglib）</p>
</li>
<li>ProxyCreatorSupport 子类：提供 aop 的装配<ul>
<li>ProxyFactoryBean：基于 xml 进行装配</li>
<li>ProxyFactory：基于编程的方式进行装配</li>
<li>AspectJProxyFactory：基于 AspectJ 注解进行装配</li>
</ul>
</li>
</ul>
<blockquote>
<p>  ProxyConfig详情可见：<a href="https://www.jianshu.com/p/b38b1a8cb0a4" target="_blank" rel="noopener">https://www.jianshu.com/p/b38b1a8cb0a4</a></p>
</blockquote>
<h3 id="ProxyFactoryBean"><a href="#ProxyFactoryBean" class="headerlink" title="ProxyFactoryBean"></a>ProxyFactoryBean</h3><p>接下来以 ProxyFactoryBean 为代表，对 spring AOP 的源码逻辑进行分析：</p>
<p>XML装配方式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"testAdvisor"</span> <span class="attr">class</span>=<span class="string">"com.abc.TestAdvisor"</span></span></span><br><span class="line">	&lt;property name="pointcut"  ref="bookPointcut"/&gt; </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"advice"</span> <span class="attr">ref</span>=<span class="string">"aroundMethod"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"testAop"</span> <span class="attr">class</span>=<span class="string">"org.springframeword.aop.ProxyFactoryBean"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"proxyInterfaces"</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.test.AbcInterface<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.abc.TestTarget"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">value</span>&gt;</span>testAdvisor<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line">              <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>由于 ProxyFactoryBean 是 spring 中管理的一个 FactoryBean 类，所以可以从他的 getObject() 方法着手：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyFactoryBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    	<span class="comment">//1. 根据xml配置，进行通知器装配</span></span><br><span class="line">        initializeAdvisorChain();</span><br><span class="line">        <span class="comment">//2. 返回完成增强的代理对象</span></span><br><span class="line">        <span class="keyword">if</span> (isSingleton()) &#123;</span><br><span class="line">            <span class="keyword">return</span> getSingletonInstance();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.targetName == <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Using non-singleton proxies with singleton targets is often undesirable. "</span> +</span><br><span class="line">                        <span class="string">"Enable prototype proxies by setting the 'targetName' property."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> newPrototypeInstance();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看 ProxyFactoryBean#initializeAdvisorChain() 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyFactoryBean</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initializeAdvisorChain</span><span class="params">()</span> <span class="keyword">throws</span> AopConfigException, BeansException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.advisorChainInitialized) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// interceptorNames 来自XML中的配置</span></span><br><span class="line">            <span class="keyword">if</span> (!ObjectUtils.isEmpty(<span class="keyword">this</span>.interceptorNames)) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 相关校验...</span></span><br><span class="line">    </span><br><span class="line">                <span class="keyword">for</span> (String name : <span class="keyword">this</span>.interceptorNames) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                        logger.trace(<span class="string">"Configuring advisor or advice '"</span> + name + <span class="string">"'"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">    </span><br><span class="line">                    <span class="comment">// 处理通配符“*”</span></span><br><span class="line">                    <span class="keyword">if</span> (name.endsWith(GLOBAL_SUFFIX)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!(<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ListableBeanFactory)) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(</span><br><span class="line">                                    <span class="string">"Can only use global advisors or interceptors with a ListableBeanFactory"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        addGlobalAdvisor((ListableBeanFactory) <span class="keyword">this</span>.beanFactory,</span><br><span class="line">                                name.substring(<span class="number">0</span>, name.length() - GLOBAL_SUFFIX.length()));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">                        <span class="comment">// 获取通知器Bean</span></span><br><span class="line">                        Object advice;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>.singleton || <span class="keyword">this</span>.beanFactory.isSingleton(name)) &#123;</span><br><span class="line">                            advice = <span class="keyword">this</span>.beanFactory.getBean(name);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            advice = <span class="keyword">new</span> ProxyFactoryBean.PrototypePlaceholderAdvisor(name);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 加入通知器链</span></span><br><span class="line">                        addAdvisorOnChainCreation(advice, name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">this</span>.advisorChainInitialized = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>接着看 ProxyFactoryBean#addAdvisorOnChainCreation</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyFactoryBean</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addAdvisorOnChainCreation</span><span class="params">(Object next, String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 将 Advice 和 MethodInterceptor（Advice子类） 拼上默认的 PointCut 适配成 Advisor</span></span><br><span class="line">        Advisor advisor = namedBeanToAdvisor(next);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Adding advisor with name '"</span> + name + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 调用 AdvisedSupport#addAdvisor 装配 通知器到 advisors 列表中</span></span><br><span class="line">        addAdvisor(advisor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在回到 getObject() 中看 getSingletonInstance() 的逻辑，代理类的生成逻辑可追溯到 DefaultAopProxyFactory#createAopProxy() </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span></span>&#123;</span><br><span class="line">	<span class="comment">//基于 ProxyConfig 的代理配置，有选择地使用 JDK代理方式 JdkDynamicAopProxy 或 Cglib代理方式 ObjenesisCglibAopProxy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">            Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">            <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line">                        <span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以 JdkDynamicAopProxy 为例进行分析，JDK 的代理主要的代理逻辑在 InvocationHandler#invoke 中，因此我们查看 JdkDynamicAopProxy#invoke 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAopProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        MethodInvocation invocation;</span><br><span class="line">        Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        TargetSource targetSource = <span class="keyword">this</span>.advised.targetSource;</span><br><span class="line">        Object target = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//1. 代理方法equals()、hashCode()</span></span><br><span class="line">		<span class="comment">//代理接口 DecoratingProxy、Advised</span></span><br><span class="line">		<span class="comment">//这也就说明代理类可以直接转换成Advised，操作AOP属性</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">                <span class="keyword">return</span> equals(args[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">                <span class="keyword">return</span> hashCode();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.getDeclaringClass() == DecoratingProxy.class) &#123;</span><br><span class="line">                <span class="keyword">return</span> AopProxyUtils.ultimateTargetClass(<span class="keyword">this</span>.advised);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">                    method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line">                <span class="comment">//ProxyConfig中opaque属性作用</span></span><br><span class="line">                <span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.advised, method, args);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Object retVal;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//ProxyConfig中exposeProxy属性作用</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">                oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">                setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            target = targetSource.getTarget();</span><br><span class="line">            Class&lt;?&gt; targetClass = (target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2. 获取拦截器链（关键步骤）</span></span><br><span class="line">            List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">//拦截器链为空，直接执行目标方法</span></span><br><span class="line">                Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">                retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//封装为增强后的连接点</span></span><br><span class="line">                invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">                <span class="comment">//连接点方法执行（责任链模式）</span></span><br><span class="line">                retVal = invocation.proceed();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> retVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>通知的形容很多，如before、afterReturn、afterThrow，这些不同的形式如何统一成拦截器链进行工作？连接点如何工作？</strong></p>
<p>我们进入连接点中查看 ReflectiveMethodInvocation#proceed 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReflectiveMethodInvocation</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//1. 拦截器从-1开始，直到结束</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 执行，稍后分析</span></span><br><span class="line">        Object interceptorOrInterceptionAdvice =</span><br><span class="line">                <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line">        <span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">            InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">                    (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">            <span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, <span class="keyword">this</span>.targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line">                <span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> proceed();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可见，这里关键的类是 InterceptorAndDynamicMethodMatcher 和 MethodInterceptor</p>
<ul>
<li><p>MethodInterceptor：Interceptor的子类，Interceptor又是Advice的子类，所以拦截器是一种特殊的通知</p>
</li>
<li><p>InterceptorAndDynamicMethodMatcher ：包装了 MethodInterceptor 和 MethodMatcher，MethodMatcher 是切点 PointCut 判断的方法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterceptorAndDynamicMethodMatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> MethodInterceptor interceptor;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> MethodMatcher methodMatcher;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">InterceptorAndDynamicMethodMatcher</span><span class="params">(MethodInterceptor interceptor, MethodMatcher methodMatcher)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.interceptor = interceptor;</span><br><span class="line">		<span class="keyword">this</span>.methodMatcher = methodMatcher;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInterceptor</span> <span class="keyword">extends</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function">Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有两个问题：</p>
<ol>
<li>我们定义的是通知器，为何变成了 MethodInterceptor ？</li>
<li>MethodInterceptor 里的 invoke 到底做什么什么事情？</li>
</ol>
<p>我们大致可以猜到，某个地方采用了适配器，在 JdkDynamicAopProxy#invoke 中关键的一步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2. 获取拦截器链（关键步骤）</span></span><br><span class="line">List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br></pre></td></tr></table></figure>
<p>追溯下去可以来到 DefaultAdvisorChainFactory#getInterceptorsAndDynamicInterceptionAdvice 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultAdvisorChainFactory</span> <span class="keyword">implements</span> <span class="title">AdvisorChainFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Advised config, Method method, @Nullable Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Object&gt; interceptorList = <span class="keyword">new</span> ArrayList&lt;&gt;(config.getAdvisors().length);</span><br><span class="line">        Class&lt;?&gt; actualClass = (targetClass != <span class="keyword">null</span> ? targetClass : method.getDeclaringClass());</span><br><span class="line">        <span class="keyword">boolean</span> hasIntroductions = hasMatchingIntroductions(config, actualClass);</span><br><span class="line">        <span class="comment">// 1. 全局适配器注册器定义</span></span><br><span class="line">        AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Advisor advisor : config.getAdvisors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> PointcutAdvisor) &#123;</span><br><span class="line">                PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;</span><br><span class="line">                <span class="keyword">if</span> (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">                    <span class="comment">// 2. 进行适配</span></span><br><span class="line">                    MethodInterceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">                    MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();</span><br><span class="line">                    <span class="keyword">if</span> (MethodMatchers.matches(mm, method, actualClass, hasIntroductions)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (mm.isRuntime()) &#123;</span><br><span class="line">                            <span class="comment">// 3. 加入到拦截器链中</span></span><br><span class="line">                            <span class="keyword">for</span> (MethodInterceptor interceptor : interceptors) &#123;</span><br><span class="line">                                interceptorList.add(<span class="keyword">new</span> InterceptorAndDynamicMethodMatcher(interceptor, mm));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">                IntroductionAdvisor ia = (IntroductionAdvisor) advisor;</span><br><span class="line">                <span class="keyword">if</span> (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">                    Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">                    interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">                interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> interceptorList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GlobalAdvisorAdapterRegistry 是一个单例模式，可以获取 AdvisorAdapterRegistry 的单例对象，默认是 DefaultAdvisorAdapterRegistry</p>
<p>DefaultAdvisorAdapterRegistry 内注册了 各种 AdvisorAdapter ，我们接着进入 DefaultAdvisorAdapterRegistry#getInterceptors 中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultAdvisorAdapterRegistry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;AdvisorAdapter&gt; adapters = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DefaultAdvisorAdapterRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		registerAdvisorAdapter(<span class="keyword">new</span> MethodBeforeAdviceAdapter());</span><br><span class="line">		registerAdvisorAdapter(<span class="keyword">new</span> AfterReturningAdviceAdapter());</span><br><span class="line">		registerAdvisorAdapter(<span class="keyword">new</span> ThrowsAdviceAdapter());</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> MethodInterceptor[] getInterceptors(Advisor advisor) <span class="keyword">throws</span> UnknownAdviceTypeException &#123;</span><br><span class="line">        List&lt;MethodInterceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 之前有将 Advice 和 MethodInterceptor（Advice子类） 适配成 Advisor</span></span><br><span class="line">        Advice advice = advisor.getAdvice();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 若 Advisor 中的通知是 MethodInterceptor 则无需处理</span></span><br><span class="line">        <span class="keyword">if</span> (advice <span class="keyword">instanceof</span> MethodInterceptor) &#123;</span><br><span class="line">            interceptors.add((MethodInterceptor) advice);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 若是 Advice ,则遍历选择合适的适配器 适配成 MethodInterceptor</span></span><br><span class="line">        <span class="keyword">for</span> (AdvisorAdapter adapter : <span class="keyword">this</span>.adapters) &#123;</span><br><span class="line">            <span class="keyword">if</span> (adapter.supportsAdvice(advice)) &#123;</span><br><span class="line">                interceptors.add(adapter.getInterceptor(advisor));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (interceptors.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnknownAdviceTypeException(advisor.getAdvice());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> interceptors.toArray(<span class="keyword">new</span> MethodInterceptor[interceptors.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AdvisorAdapter 是真正进行适配的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AdvisorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 支持那种 Advice 的适配</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">supportsAdvice</span><span class="params">(Advice advice)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将 Advisor 适配成 MethodInterceptor</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">MethodInterceptor <span class="title">getInterceptor</span><span class="params">(Advisor advisor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>spring 中默认的有三类：</p>
<ol>
<li>AfterReturningAdviceAdapter：适配 AfterReturningAdvice</li>
<li>MethodBeforeAdviceAdapter：适配 MethodBeforeAdvice</li>
<li>ThrowsAdviceAdapter：适配 ThrowsAdvice</li>
</ol>
<p>以 AfterReturningAdviceAdapter 为代表进行分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AfterReturningAdviceAdapter</span> <span class="keyword">implements</span> <span class="title">AdvisorAdapter</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsAdvice</span><span class="params">(Advice advice)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (advice <span class="keyword">instanceof</span> AfterReturningAdvice);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> MethodInterceptor <span class="title">getInterceptor</span><span class="params">(Advisor advisor)</span> </span>&#123;</span><br><span class="line">		AfterReturningAdvice advice = (AfterReturningAdvice) advisor.getAdvice();</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> AfterReturningAdviceInterceptor(advice);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，将 AfterReturningAdvice 转换成 AfterReturningAdviceInterceptor，到此我们解决了问题1，那么分析问题2（MethodInterceptor 里的 invoke 到底做什么什么事情？）</p>
<p>以 AfterReturningAdviceInterceptor 为代表进行分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterReturningAdviceInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">AfterAdvice</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AfterReturningAdvice advice;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AfterReturningAdviceInterceptor</span><span class="params">(AfterReturningAdvice advice)</span> </span>&#123;</span><br><span class="line">		Assert.notNull(advice, <span class="string">"Advice must not be null"</span>);</span><br><span class="line">		<span class="keyword">this</span>.advice = advice;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 推进拦截器链，递归</span></span><br><span class="line">		Object retVal = mi.proceed();</span><br><span class="line">        <span class="comment">// 2. 执行通知，这里因为是 AfterReturning，所以后执行</span></span><br><span class="line">        <span class="keyword">this</span>.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());</span><br><span class="line">		<span class="keyword">return</span> retVal;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ProxyFactory"><a href="#ProxyFactory" class="headerlink" title="ProxyFactory"></a>ProxyFactory</h3><p>上面就是对ProxyFactoryBean的分析，我们说了是基于XML对通知器的进行装配，接着看看 ProxyFactory 编程式装配：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ProxyFactory factory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">        factory.setInterfaces(<span class="keyword">new</span> Class[] &#123; PeopleService.class &#125;);</span><br><span class="line">        factory.addAdvice(<span class="keyword">new</span> AroundInteceptor());</span><br><span class="line">        factory.setTarget(<span class="keyword">new</span> EnglishService());</span><br><span class="line">        PeopleService peopleProxy = (PeopleService) factory.getProxy();</span><br><span class="line">        peopleProxy.sayHello();</span><br><span class="line">        System.err.println(peopleProxy.getClass().getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 ProxyFactory 就是用代码进行装配，其底层都是一样的，再看最后的 AspectJProxyFactory</p>
<h3 id="AspectJProxyFactory"><a href="#AspectJProxyFactory" class="headerlink" title="AspectJProxyFactory"></a>AspectJProxyFactory</h3><p>AspectJProxyFactory 其实和真正的 AspectJ 关系不大，直接借用了 AspectJ 的注解来装配通知器</p>
<p>使用如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* add(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">beforeAdd</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"beforeAdd()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-----------before-----------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有兴趣的可以继续查看其源码</p>
<p>总结：</p>
<ol>
<li>无论是 Advice 还是 Interceptor，最终都会处理成 Interceptor链，在动态代理中进行增强</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>10 内部类</title>
    <url>/2018/10/16/THING%20IN%20JAVA/10%20%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h2 id="链接到外部内"><a href="#链接到外部内" class="headerlink" title="链接到外部内"></a>链接到外部内</h2><p>内部类（即便是private的）可以很方便的访问到外部类中的方法和字段</p>
<p><strong>为什么？</strong></p>
<p>内部类秘密地创建了一个指向外围类对象的引用final Outer this$0，这样就可以访问可见成员了，而这些调用引用的细节编译器都帮我们处理了。</p>
<h2 id="使用-this-和-new"><a href="#使用-this-和-new" class="headerlink" title="使用.this 和 .new"></a>使用.this 和 .new</h2><p><strong>使用.this做什么？</strong></p>
<p>上面说到我们访问外部类的字段和方法的时候会隐含的使用一个指向外部内对象的引用。<br>如果我们想要显式的使用，可以使用Outer.this的方式来获取到外部类对象，这个过程在编译时期完成。</p>
<p><strong>如何new一个内部类对象？</strong></p>
<p>方法是使用 外部类的对象.new 内部类</p>
<p><strong>为什么是使用外部类的对象而不是外部类？</strong></p>
<p>因为内部类中有一个指向外部类对象的引用，所以有内部类对象之前必须先有一个外部类对象。<br>注意：静态内部类不需要这样。</p>
<h2 id="内部类和向上转型"><a href="#内部类和向上转型" class="headerlink" title="内部类和向上转型"></a>内部类和向上转型</h2><p><strong>什么是使用内部类结合向上转型？</strong></p>
<p>直接看代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Destination</span> </span>&#123;   </span><br><span class="line">  <span class="function">String <span class="title">readLabel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parcel4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PContents</span> <span class="keyword">implements</span> <span class="title">Contents</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">PDestination</span> <span class="keyword">implements</span> <span class="title">Destination</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String label;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">PDestination</span><span class="params">(String whereTo)</span> </span>&#123;</span><br><span class="line">            label = whereTo;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> label;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">destination</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PDestination(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PContents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上诉的代码中，可以看到，private和protected的内部类实现了两个接口，并且在外部类中提供了两个方法创建这两个内部类的实例并return，但是由于我们方法的返回类型是实例的接口而不是具体的实例，这就是向上转型的方式。</p>
<p><strong>内部类结合向上转型有什么意义？</strong></p>
<p>首先我们分析一个普通类实现接口的时候会出现怎样的问题：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PDestination</span> <span class="keyword">implements</span> <span class="title">Destination</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String label;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PDestination</span><span class="params">(String whereTo)</span> </span>&#123;</span><br><span class="line">        label = whereTo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> label;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意到，这个类中除了从接口中实现的方法是public之外，其它的都是private的，我们说这个类隐藏了接口的方法实现细节，但是注意了，这只是人为的去控制的，难道我们就不能再添加其它的public的方法了吗？当然可以。并且，更关键的是PDestination这个类是可以访问的（可以new的），由于<em>类型曝光了出来</em>，不可避免的是可以使用“类型编程”（以后会更具体的了解）。</p>
<p>情况危急之时，内部类站了出来，并且解决了这些问题！当使用内部类结合向上转型的时候，最大的一个区别在于：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestParcel</span> </span>&#123;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     </span><br><span class="line">    Parcel4 p = <span class="keyword">new</span> Parcel4();     </span><br><span class="line">    Parcel4.PContents pc = p.new PContents();<span class="comment">//Illegal -- can’t access private class:</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>内部类是具有private和protected权限的，这就使得在其他类中无法直接new一个实例，只能通过外部类中暴露的公共方法获得向上转型了的接口。</p>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p><strong>如何理解内部类的存在？</strong></p>
<p>先看一个内部类使用的案例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel7b</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyContents()&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;     </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     </span><br><span class="line">    Parcel7b p = <span class="keyword">new</span> Parcel7b();     </span><br><span class="line">    Contents c = p.contents();   </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实它只是下面这种写法的一个简化：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel7b</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MyContents</span> <span class="keyword">implements</span> <span class="title">Contents</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;   </span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyContents();</span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     </span><br><span class="line">    Parcel7b p = <span class="keyword">new</span> Parcel7b();     </span><br><span class="line">    Contents c = p.contents();   </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>进一步理解内部类</strong></p>
<p>匿名内部类其实是<em>内部类实现了一个接口（或者基类），并实现（覆盖）了它的方法后，通过向上转型使用这个内部类的方式</em>，由于向上转型，我们只关心是实现的是哪一个，具体的实现类只会定义一次，并且这个“名字”没有任何意义，甚至可以不必存在。</p>
<p>匿名内部类可以是局部内部类的简化，也可以是普通内部类的一个简化。<br>如果是局部内部类，注意局部变量需要+final，至于原因？<br>后面会分析。</p>
<p><strong>为什么不父类去继承或者实现？</strong></p>
<ol>
<li>外部类已经有父类</li>
<li>外部类不希望去实现其他的接口（实现接口意味着曝光更多的public方法，尽管这些方法和外部类没有任何关系）</li>
<li>隐藏实现的细节</li>
</ol>
<h2 id="使用内部类改进工厂方法模式"><a href="#使用内部类改进工厂方法模式" class="headerlink" title="使用内部类改进工厂方法模式"></a>使用内部类改进工厂方法模式</h2><p>之前在接口中提到了工厂方法模式，说过可以有一种改进，<strong>如何改进？</strong></p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Service <span class="title">getService</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation1</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Implementation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        print(<span class="string">"Implementation1 method1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        print(<span class="string">"Implementation1 method2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ServiceFactory factory = <span class="keyword">new</span> ServiceFactory() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Service <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Implementation1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>匿名内部类很好的声明了只会使用一次的类。</p>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>内部类作为外部类的一个成员，也可以是静态的。</p>
<p><strong>静态内部类有哪些特性？</strong></p>
<p>静态内部类行和外部内部类没什么关联，无法访问外围类的非静态成员。</p>
<p><strong>静态内部类有什么用？</strong></p>
<p>一个比较通常的用法是用在接口上。<br>接口中是禁止有任何的代码的，但是静态内部类可以作为接口的一个成员（接口中的成员自动是static和public的）</p>
<p><strong>这样有什么好处？</strong></p>
<ol>
<li><p>我可以在接口中的静态内部类中实现当前的接口，给所有的实现提供一个通用的方法实现方案。<br>案例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassInInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">howdy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">ClassInInterface</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">howdy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Howdy!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">new</span> Test().howdy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们通常使用的测试方法是在类中写一个main方法，但是这样有一个问题是，编译后代码会附带这一部分无用的信息。静态内部类提供了一个解决方氨：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBed</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"f()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Tester</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            TestBed t = <span class="keyword">new</span> TestBed();</span><br><span class="line">            t.f();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>编译后会生成两个class文件，其中的TestBed$Tester文件是测试类，直接删除即可。</p>
<h2 id="多层嵌套的内部类"><a href="#多层嵌套的内部类" class="headerlink" title="多层嵌套的内部类"></a>多层嵌套的内部类</h2><p>无论嵌套多少层，内部类都能访问到之前的所有外部类成员（即便是private的）<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MNA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                g();</span><br><span class="line">                f();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="为什么需要内部类"><a href="#为什么需要内部类" class="headerlink" title="为什么需要内部类"></a>为什么需要内部类</h2><p>多重继承（类），如果不是为了解决这个问题，自然可以用其它的方式代替，但是使用内部类，还是有其它的一些不明显的好处的。</p>
<p><strong>什么是闭包？</strong></p>
<p>闭包也是一种为表示带有自由变量的过程而用的实用技术。<br>在JAVA里：闭包是一个可调用的对象，它保留了创建它的作用域的信息。<br>很显然，这个解释就是说内部类是JAVA里的闭包。<br>使用JAVA的闭包可以更安全的实现回调？</p>
<p><strong>什么是回调？</strong></p>
<p>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。<br>但是，在JAVA里，没有提供指针(*)的操作方式，因为使用指针是很不安全的，可是，难道引用不就是指针吗？<br>其实两者有明显的区别。</p>
<p><strong>指针和引用的区别，指针为何不安全？</strong></p>
<p>指针本质上可以在整个OS允许的内存块上任意移动，有时候还会跨界到其他内存块上去。本质上它离机器语言太近，能够造成非常巨大的外延性破坏。一个最经典的例子就是内存践踏造成的缓冲区溢出。程序设计界已经因为指针每年损失billion级别的资源。<br>Java否定了这种自由性。你不能根据你现有的引用移动到内存的其他位置做任何你想做的事情。<br>既然JAVA里没有指针，就更加没有回调函数的感念了</p>
<p><strong>那内部类如何实现回调呢？</strong></p>
<p>很容易，就是使用内部类去实现一个接口，然后把这个内部类生成的对象引用作为参数传递给其它方法。</p>
<p><strong>什么情况下会使用内部类去实现接口？而不是使用外部类去实现接口？</strong></p>
<p>当外部类有一个父类，这个父类和要实现的接口没有任何的关系，但是他们又拥有相同的方法,那<em>不能为了实现这个接口而把父类中的方法给覆盖了</em>。这时，最好的解决办法就是使用内部类去实现接口。</p>
<h2 id="内部类和控制框架"><a href="#内部类和控制框架" class="headerlink" title="内部类和控制框架"></a>内部类和控制框架</h2><p><strong>什么是应用控制框架？</strong></p>
<p>被设计解决一个特定问题的一个类或者一组类，其实就是模板方法。</p>
<p><strong>什么是模板方法？</strong></p>
<p>先看一个例子：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模板方法，计算利息数额</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>    返回利息数额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> <span class="title">calculateInterest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> interestRate = doCalculateInterestRate();</span><br><span class="line">        String accountType = doCalculateAccountType();</span><br><span class="line">        <span class="keyword">double</span> amount = calculateAmount(accountType);</span><br><span class="line">        <span class="keyword">return</span> amount * interestRate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基本方法留给子类实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">doCalculateAccountType</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基本方法留给子类实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">doCalculateInterestRate</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基本方法，已经实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">calculateAmount</span><span class="params">(String accountType)</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 省略相关的业务逻辑</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">7243.00</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个模板方法就是模板方法里写好整个算法、流程，至于算法中有些抽象方法交给子类去具体的实现。</p>
<p><strong>控制框架中使用内部类有什么优势？</strong></p>
<p>先看一个控制框架的案例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> eventTime;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">long</span> delayTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Event</span><span class="params">(<span class="keyword">long</span> delayTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delayTime = delayTime;</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123; <span class="comment">// Allows restarting     </span></span><br><span class="line">        eventTime = System.nanoTime() + delayTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.nanoTime() &gt;= eventTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="comment">// A class from java.util to hold Event objects:   </span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Event&gt; eventList = <span class="keyword">new</span> ArrayList&lt;Event&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEvent</span><span class="params">(Event c)</span> </span>&#123;</span><br><span class="line">        eventList.add(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (eventList.size() &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// Make a copy so you’re not modifying the list       </span></span><br><span class="line">            <span class="comment">// while you’re selecting the elements in it:       </span></span><br><span class="line">            <span class="keyword">for</span> (Event e : <span class="keyword">new</span> ArrayList&lt;Event&gt;(eventList))</span><br><span class="line">                <span class="keyword">if</span> (e.ready()) &#123;</span><br><span class="line">                    System.out.println(e);</span><br><span class="line">                    e.action();</span><br><span class="line">                    eventList.remove(e);</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>控制框架中Event中的action需要由子类实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreenhouseControls</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> light = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOn</span> <span class="keyword">extends</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LightOn</span><span class="params">(<span class="keyword">long</span> delayTime)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(delayTime);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Put hardware control code here to</span></span><br><span class="line">            <span class="comment">// physically turn on the light.</span></span><br><span class="line">            light = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Light is on"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOff</span> <span class="keyword">extends</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LightOff</span><span class="params">(<span class="keyword">long</span> delayTime)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(delayTime);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Put hardware control code here to</span></span><br><span class="line">            <span class="comment">// physically turn off the light.</span></span><br><span class="line">            light = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Light is off"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里一定是需要使用到内部类吗？<br>并不是，其实使用内部类主要是了控制类的数量，因为有大量的事件，而且多数事件的相应方法只被用到了一次，考虑的是更好地封装。</p>
<h2 id="内部类的继承"><a href="#内部类的继承" class="headerlink" title="内部类的继承"></a>内部类的继承</h2><p><strong>继承内部类是怎样的？</strong><br>内部类由于在被实例化的时候，会隐藏一个指定外部类对象的引用，因此在继承内部类的时候，比较特别。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithInner</span> </span>&#123;   </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritInner</span> <span class="keyword">extends</span> <span class="title">WithInner</span>.<span class="title">Inner</span></span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">   <span class="comment">//! InheritInner() &#123;&#125;</span></span><br><span class="line">   <span class="comment">// Won’t compile   </span></span><br><span class="line">   InheritInner(WithInner wi) &#123;     </span><br><span class="line">     wi.<span class="keyword">super</span>();   </span><br><span class="line">   &#125;   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     </span><br><span class="line">     WithInner wi = <span class="keyword">new</span> WithInner();     </span><br><span class="line">     InheritInner ii = <span class="keyword">new</span> InheritInner(wi);   </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面表示：在继承内部类是，要定义一个带有外部类参数的构造器，并调用外部类.super().<br>至于原因，和JVM有关，暂不分析。</p>
<h2 id="内部类的覆盖"><a href="#内部类的覆盖" class="headerlink" title="内部类的覆盖"></a>内部类的覆盖</h2><p><strong>内部类作为一个特殊的成员，能被覆盖吗？</strong><br>看下面的这个案例分析：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Egg</span> </span>&#123;   </span><br><span class="line">  <span class="keyword">private</span> Yolk y;</span><br><span class="line">  <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> </span>&#123;     <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123; print(<span class="string">"Egg.Yolk()"</span>); &#125;   </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Egg</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    print(<span class="string">"New Egg()"</span>);     </span><br><span class="line">    y = <span class="keyword">new</span> Yolk();   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;      </span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigEgg</span> <span class="keyword">extends</span> <span class="title">Egg</span> </span>&#123;   </span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> </span>&#123;     </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       print(<span class="string">"BigEgg.Yolk()"</span>);</span><br><span class="line">     &#125;   </span><br><span class="line">   &#125;   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     </span><br><span class="line">     <span class="keyword">new</span> BigEgg();   </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">  <span class="function">New <span class="title">Egg</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  Egg.<span class="title">Yolk</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>由此可见，继承后，两个内部类即使名字一样，但是他们没有任何的关系，是两个独立的内部类，处于不同的命名空间。<br>如果想要实现内部类的继承，需要同时指定内部类的继承，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Egg</span> </span>&#123;   </span><br><span class="line">  <span class="keyword">private</span> Yolk y;</span><br><span class="line">  <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> </span>&#123;     <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123; print(<span class="string">"Egg.Yolk()"</span>); &#125;   </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Egg</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    print(<span class="string">"New Egg()"</span>);     </span><br><span class="line">    y = <span class="keyword">new</span> Yolk();   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;      </span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigEgg</span> <span class="keyword">extends</span> <span class="title">Egg</span> </span>&#123;   </span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> <span class="keyword">extends</span> <span class="title">Egg</span>.<span class="title">Yolk</span></span>&#123;     </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       print(<span class="string">"BigEgg.Yolk()"</span>);</span><br><span class="line">     &#125;   </span><br><span class="line">   &#125;   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     </span><br><span class="line">     <span class="keyword">new</span> BigEgg();   </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">  <span class="function">New <span class="title">Egg</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  BigEgg.<span class="title">Yolk</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>思考一下，<strong>为什么这里的内部类继承不需要定义特殊构造器？</strong><br>结果的答案在于这里的BigEgg extends Egg。</p>
<h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p><strong>什么是局部内部类？</strong><br>声明在方法或者作用域中的内部类，由于不属于外部类的成员了，也就没有访问说明符，外部类看不见内部类，除此之外，和普通的内部类没有区别，也就是说，局部内部类还是有外部类的引用，可以访问到外部类的字段方法。</p>
<p>还需要注意的是局部内部类访问方法的局部变量，要求局部变量是final的，<strong>为什么？</strong></p>
<p>因为局部变量是存放在JVM的栈区的，而当方法结束的时候，栈区中保存的局部变量就会消失，但是这时候内部类的生命周期还没有结束，因此可能会有数据不一致的问题，为了解决这个问题，必须声明内部类中使用的局部变量是final的，也就是不可变。</p>
<h1 id="内部类反编译分析"><a href="#内部类反编译分析" class="headerlink" title="内部类反编译分析"></a>内部类反编译分析</h1><h2 id="私用内部类"><a href="#私用内部类" class="headerlink" title="私用内部类"></a>私用内部类</h2><ul>
<li>在内部类中偷偷摸摸的创建了包可见构造器，从而使外部类获得了创建权限。</li>
<li>创建了一个指向外围类对象的引用final Outer this$0，这样就可以访问可见成员了。</li>
<li>在外部类中偷偷摸摸的创建了访问私有变量的静态方法，从而使内部类获得了访问权限。这样，类中定义的内部类无论私有，公有，静态都可以被包围它的外部类所访问。</li>
</ul>
<h2 id="静态内部类-1"><a href="#静态内部类-1" class="headerlink" title="静态内部类"></a>静态内部类</h2><ul>
<li>少了一个指向外围类对象的引用final Outer this$0; 也就是说静态内部类无法得到其外围类对象的引用，那么自然也就无法访问外围类的非静态成员了。</li>
</ul>
<h2 id="局部内部类-1"><a href="#局部内部类-1" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>在方法里定义的内部类叫做局部内部类</p>
<ul>
<li>在外部类中没有创建访问私有变量的静态方法，因此无法访问外部内的私用变量。</li>
<li>对Inner类的反射发现，Inner类内部多了一个对beep变量的备份隐藏域：final int val$i，所以可以使用外部方法的final变量。</li>
</ul>
<h2 id="effectively-final"><a href="#effectively-final" class="headerlink" title="effectively final"></a>effectively final</h2><p>A variable or parameter whose value is never changed after it is initialized is effectively final<br>.<br>java8出现，不需要显示的+final，就可以在局部内部类中使用（定义后值从来没有发生变化）的变量。但是如果判断变化了，就会报错。</p>
<h2 id="匿名内部类-1"><a href="#匿名内部类-1" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>没有构造器，使用的时候把参数传给超类构造器。</p>
]]></content>
      <categories>
        <category>Thinking in Java 读书笔记</category>
      </categories>
      <tags>
        <tag>JAVA编程思想</tag>
        <tag>Thinking in JAVA</tag>
        <tag>内部类</tag>
      </tags>
  </entry>
  <entry>
    <title>18 IO流</title>
    <url>/2018/11/21/THING%20IN%20JAVA/18%20IO%E6%B5%81/</url>
    <content><![CDATA[<h1 id="I-O流"><a href="#I-O流" class="headerlink" title="I/O流"></a>I/O流</h1><h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><p>仅从名字，我们很容易误解File表示一个真实存在的文件，但实际不是这样的</p>
<p><strong>File类表示的含义？</strong></p>
<p>用FilePath来形容它会更加合适，它可以有以下的含义：</p>
<ol>
<li>一个已存在的文件。</li>
<li>已存在的目录。</li>
<li>尚不存在的文件或目录。</li>
<li>这个文件或目录的特性。</li>
<li>这个文件或目录的一些操作。</li>
</ol>
<p>之前在正则表达式中提到正则表达式结合I/O流可以实现对文件的检索。</p>
<p><strong>如何实现文件的检索？</strong></p>
<p>File类中有个public String[] list(FilenameFilter filter)的方法，其中FilenameFilter就是定制过滤规则的接口，这个接口的内如很简单：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FilenameFilter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是使用了策略模式。</p>
<p><strong>如何向文件中读写数据？</strong></p>
<p>有了文件还无法进行读写的操作，JAVA把能够产生数据输入和输出的数据源称为流，以此来屏蔽I/O设备处理数据的细节。</p>
<h2 id="输入流-输出流"><a href="#输入流-输出流" class="headerlink" title="输入流/输出流"></a>输入流/输出流</h2><ul>
<li><p>JAVA中用InterStream和Read表示可以产生数据的流，具有read()的方法。</p>
</li>
<li><p>JAVA中用OuterStream和Writer表示可以接口数据的流，具有write()的方法。<br>比如文件，如果要进行读数据，需要转成文件流(FileInputStream)。<br>还可以作为数据源的比如：</p>
</li>
</ul>
<ol>
<li>字符串</li>
<li>字节数组</li>
<li>管道</li>
<li>一个由其他种类的流组成的序列</li>
<li>其他数据流</li>
</ol>
<p><img src="/2018/11/21/THING IN JAVA/18 IO流/1.png" alt="输入流InterStream"><br><img src="/2018/11/21/THING IN JAVA/18 IO流/2.png" alt="输出流OuterStream"></p>
<p>读写的方式有很多，因此一半不会直接使用InterStream和Read/OuterStream和Writer里的读写方法，一般都会包装一层，增强读写的功能，这也叫做装饰器模式。</p>
<p><strong>什么是装饰器模式？</strong></p>
<p>先说一个比较通俗的例子，玩游戏的时候，给人物穿戴各种装备，其实就是装饰器模式的一种应用，这个人物还是这个人物（这个接口还是这个接口），只是新的对象具有了更强大的功能。</p>
<p>案例:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Troll</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getAttackPower</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fleeBattle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleTroll</span> <span class="keyword">implements</span> <span class="title">Troll</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(SimpleTroll.class);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"The troll tries to grab you!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAttackPower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fleeBattle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"The troll shrieks in horror and runs away!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClubbedTroll</span> <span class="keyword">implements</span> <span class="title">Troll</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ClubbedTroll.class);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Troll decorated;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ClubbedTroll</span><span class="params">(Troll decorated)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.decorated = decorated;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    decorated.attack();</span><br><span class="line">    LOGGER.info(<span class="string">"The troll swings at you with a club!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAttackPower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> decorated.getAttackPower() + <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fleeBattle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    decorated.fleeBattle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的ClubbedTroll类就是一个装饰器，把我们的SimpleTroll类给包装了一下，让它更加强大。<br>说到包装，我们想到我们的适配器。</p>
<p><strong>装饰器和适配器的区别是？</strong></p>
<p>最本质的区别的：</p>
<ol>
<li>适配器会改变被包装的类来适用新的接口。</li>
<li>装饰器不会改变接口。</li>
</ol>
<h2 id="流的装饰器"><a href="#流的装饰器" class="headerlink" title="流的装饰器"></a>流的装饰器</h2><p>I/O流对象的装饰器都是以FilterInputStream/FilterOuterStream为父类。</p>
<p><strong>装饰什么？</strong><br>主要分为两类：</p>
<ol>
<li>改变读写方式的装饰器（DataInputStream/DataOuterStream）：流读写一般只读写一个字节，为了读写更多的类型，如int，float，boolean，double，char等。</li>
<li>在内部提高读写性能的装饰器：如是否缓存，是否保留读写的行，是否把单一的字符推入输入流等等。</li>
</ol>
<p><img src="/2018/11/21/THING IN JAVA/18 IO流/3.png" alt="装饰器DataInputStream"><br><img src="/2018/11/21/THING IN JAVA/18 IO流/4.png" alt="装饰器DataOuterStream"></p>
<p><strong>PrintStream和DataOuterStream有什么区别？</strong></p>
<p>PrintStream:格式化的输出基本类型数据</p>
<ol>
<li>PrintStream会捕获IO异常，之后使用checkError()来获取输出成功还是失败。</li>
<li>PrintStream作用是打印基本数据类型的数据，底层使用的是Writer，操作对象是字符（可以选择编码方式），里面使用了Formatter类，因此支持格式化的输出，System.out就是一种PrintStream类。</li>
</ol>
<p>DataOuterStream:以字节的形式存储基本类型数据</p>
<ol>
<li>将基本类型数据以字节的形式保存在流中，随后搭配的使用DataInputStream来获取这些数据。保持存取的顺序一致，就可以保证获取的数据准确无误。<blockquote>
<p>RandomAccessFile 实现了 DataInput和DataOuter 因此可以看做是DataOuterStream和DataInputStream 的一个综合，除此之外还具有seek()等发方法来定位文件中的某个字节位置。</p>
</blockquote>
</li>
</ol>
<p><strong>一个字节一个字节处理的缺陷？</strong></p>
<p>效率低，使用批量读写代替一个字节一个字节处理，增加一个缓冲区来辅助处理——BufferedInputStream/BufferedOutputStream：</p>
<p><strong>如何理解BufferedInputStream的功能？</strong></p>
<p>4个索引：<br>count：缓冲区有效数据<br>pos：当前缓冲区内读写的位置<br>markpos：标记<br>marklimit：缓冲区大小上限</p>
<p>1个关键函数<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = getBufIfOpen();</span><br><span class="line">    <span class="keyword">if</span> (markpos &lt; <span class="number">0</span>)</span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pos &gt;= buffer.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (markpos &gt; <span class="number">0</span>) &#123;  <span class="comment">/* can throw away early part of the buffer */</span></span><br><span class="line">            <span class="keyword">int</span> sz = pos - markpos;</span><br><span class="line">            System.arraycopy(buffer, markpos, buffer, <span class="number">0</span>, sz);</span><br><span class="line">            pos = sz;</span><br><span class="line">            markpos = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buffer.length &gt;= marklimit) &#123;</span><br><span class="line">            markpos = -<span class="number">1</span>;   <span class="comment">/* buffer got too big, invalidate mark */</span></span><br><span class="line">            pos = <span class="number">0</span>;        <span class="comment">/* drop buffer contents */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;            <span class="comment">/* grow buffer */</span></span><br><span class="line">            <span class="keyword">int</span> nsz = pos * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nsz &gt; marklimit)</span><br><span class="line">                nsz = marklimit;</span><br><span class="line">            <span class="keyword">byte</span> nbuf[] = <span class="keyword">new</span> <span class="keyword">byte</span>[nsz];</span><br><span class="line">            System.arraycopy(buffer, <span class="number">0</span>, nbuf, <span class="number">0</span>, pos);</span><br><span class="line">            <span class="keyword">if</span> (!bufUpdater.compareAndSet(<span class="keyword">this</span>, buffer, nbuf)) &#123;</span><br><span class="line">                <span class="comment">// Can't replace buf if there was an async close.</span></span><br><span class="line">                <span class="comment">// Note: This would need to be changed if fill()</span></span><br><span class="line">                <span class="comment">// is ever made accessible to multiple threads.</span></span><br><span class="line">                <span class="comment">// But for now, the only way CAS can fail is via close.</span></span><br><span class="line">                <span class="comment">// assert buf == null;</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Stream closed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            buffer = nbuf;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    count = pos;</span><br><span class="line">    <span class="keyword">int</span> n = getInIfOpen().read(buffer, pos, buffer.length - pos);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">        count = n + pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据if-esle分为以下5中情况：</p>
<p>1.<br>pos&gt;count:读取完buffer中的数据<br>且 markpos&lt;0:buffer没有被标记<br>则 重新覆盖缓冲区数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = getBufIfOpen();</span><br><span class="line">    <span class="keyword">if</span> (markpos &lt; <span class="number">0</span>)</span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    count = pos;</span><br><span class="line">    <span class="keyword">int</span> n = getInIfOpen().read(buffer, pos, buffer.length - pos);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">        count = n + pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.<br>pos&gt;count:读取完buffer中的数据<br>且 markpos&gt;0:buffer有标记<br>且 buffer没有多余的空间<br>则 重新覆盖0到标记处的字节<br>且 令markpos=0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = getBufIfOpen();</span><br><span class="line">    <span class="keyword">if</span> (markpos &gt;= <span class="number">0</span> &amp;&amp; pos &gt;= buffer.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (markpos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> sz = pos - markpos;</span><br><span class="line">            System.arraycopy(buffer, markpos, buffer, <span class="number">0</span>, sz);</span><br><span class="line">            pos = sz;</span><br><span class="line">            markpos = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    count = pos;</span><br><span class="line">    <span class="keyword">int</span> n = getInIfOpen().read(buffer, pos, buffer.length - pos);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">        count = n + pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.<br>pos&gt;count:读取完buffer中的数据<br>且 markpos=0：表示已没有无效数据可覆盖<br>且 buffer没有多余的空间<br>且 buffer.length&lt;marklimit：没有达到扩充上限<br>则 扩充buffer大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = getBufIfOpen();</span><br><span class="line">    <span class="keyword">if</span> (markpos &gt;= <span class="number">0</span> &amp;&amp; pos &gt;= buffer.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (markpos &lt;= <span class="number">0</span>) &amp;&amp; (buffer.length &lt; marklimit) ) &#123;</span><br><span class="line">            <span class="keyword">int</span> nsz = pos * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nsz &gt; marklimit)</span><br><span class="line">                nsz = marklimit;</span><br><span class="line">            <span class="keyword">byte</span> nbuf[] = <span class="keyword">new</span> <span class="keyword">byte</span>[nsz];</span><br><span class="line">            System.arraycopy(buffer, <span class="number">0</span>, nbuf, <span class="number">0</span>, pos);</span><br><span class="line">            <span class="keyword">if</span> (!bufUpdater.compareAndSet(<span class="keyword">this</span>, buffer, nbuf)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Stream closed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            buffer = nbuf;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    count = pos;</span><br><span class="line">    <span class="keyword">int</span> n = getInIfOpen().read(buffer, pos, buffer.length - pos);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">        count = n + pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.<br>pos&gt;count:读取完buffer中的数据<br>且 markpos=0：表示已没有无效数据可覆盖<br>且 buffer没有多余的空间<br>且 buffer.length&lt;marklimit：没有达到扩充上限<br>则 扩充buffer大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = getBufIfOpen();</span><br><span class="line">    <span class="keyword">if</span> (markpos &gt;= <span class="number">0</span> &amp;&amp; pos &gt;= buffer.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (markpos &lt;= <span class="number">0</span>) &amp;&amp; (buffer.length &gt;= marklimit) ) &#123;</span><br><span class="line">            markpos = -<span class="number">1</span>;   <span class="comment">/* buffer got too big, invalidate mark */</span></span><br><span class="line">            pos = <span class="number">0</span>;        <span class="comment">/* drop buffer contents */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    count = pos;</span><br><span class="line">    <span class="keyword">int</span> n = getInIfOpen().read(buffer, pos, buffer.length - pos);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">        count = n + pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.<br>pos&gt;count:读取完buffer中的数据<br>且 buffer有多余的空间<br>则 写入多余的空间<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = getBufIfOpen();</span><br><span class="line"></span><br><span class="line">    count = pos;</span><br><span class="line">    <span class="keyword">int</span> n = getInIfOpen().read(buffer, pos, buffer.length - pos);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">        count = n + pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>按字节来读写数据的缺陷？</strong></p>
<p>字节流只能很好的处理二进制数据，对于文本数据，使用字节流来处理就会显得格外的麻烦，需要解码才能转成字符串，并且有时候还会因为变长编码出现一些问题，因此采用字符流来读取数据的方式迫在眉睫。由此，JAVA在1.1发布了Reader和Writer。</p>
<h2 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h2><p><strong>什么叫做标准？</strong></p>
<p>也就数据源是控制台，从控制台输入输出数据。</p>
<p>System.out 和 System.err都是PrintStream字符流<br>System.in 是 InputStream 只有读字节的方法read()，因此需要包装一下</p>
<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p><strong>为什么需要NIO？</strong></p>
<p>实际上有两个原因，文件IO和网络IO，文件IO的话好处是提高了读写的速度。网络IO的话是解决了阻塞IO的问题。</p>
<blockquote>
<p>书中只谈文件IO的提高，这一节知识点需要补充：socket和selector，以及网络IO方面的知识。</p>
</blockquote>
<p><strong>什么是阻塞？</strong></p>
<p>就是进行在进行读写的时候，必须等待，这样效率很低。</p>
<p><strong>如何提高了</strong></p>
<ol>
<li>面向缓冲区：NIO的缓冲区是和操作系统紧密关联的，因此效率更高。</li>
<li>面向非阻塞：读写数据的时候不阻塞原应用进程。</li>
<li>具有选择器：一个缓冲区可以通过选择器选择不同的通道。</li>
</ol>
<p><strong>如何使用NIO</strong></p>
<p>这里主要讲解文件IO的使用：</p>
<ul>
<li><p>通道和缓冲器一起使用</p>
<p>文件通道：FileChannel<br>唯一与通道交互的缓冲器：ByteBuffer<br>旧的I/O库有3个类被重写了，用以产生FileChannel：FileInputStream,FilterOuterStream和RandomAccessFile.</p>
<ol>
<li>获取通道getChannel()</li>
<li>获取缓冲器ByteBuffer.allocate()或者ByteBuffer.allocateDirect()，后者更接近操作系统，虽然速度会更快，但是分配需额外的开支，需要抉择。</li>
<li>从通道读到缓冲器中in.read(buffer)，调用filp()来转换缓冲器的状态（实际上是修改了缓冲器的position,limit,capacity），从缓冲器写到通道中out.write(buffer)，调用clear再次转换状态（实际上还是修改了缓冲器的position,limit,capacity）。</li>
</ol>
</li>
<li><p>直接操作缓冲器的方法</p>
<p>put()：存<br>get()：取<br>wrap()：包装已经存在的数组<br>rewind()：回到数据的起始点<br>还是如下图的各种修改缓冲器4个主要索引的方法：</p>
<p><img src="/2018/11/21/THING IN JAVA/18 IO流/5.png" alt="操作缓冲器"></p>
<p>mark()需要配合reset()使用，前一个标记position的位置，后者回到标记点。</p>
</li>
</ul>
<p><strong>clear()和rewind()的区别？</strong></p>
<p>rewind()不会改变position的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Buffer <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    position = <span class="number">0</span>;      <span class="comment">//设置为0</span></span><br><span class="line">    limit = capacity;    <span class="comment">//极限和容量相同</span></span><br><span class="line">    mark = -<span class="number">1</span>;   <span class="comment">//取消标记</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把position设为0，把limit设为capacity，一般在把数据写入Buffer前调用。</span></span><br><span class="line"></span><br><span class="line"><span class="function">Buffer <span class="title">flip</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">     limit = position;    </span><br><span class="line">     position = <span class="number">0</span>;   </span><br><span class="line">     mark = -<span class="number">1</span>;   </span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把limit设为当前position，把position设为0，一般在从Buffer读出数据前调用。</span></span><br><span class="line"></span><br><span class="line"><span class="function">Buffer <span class="title">rewind</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    position = <span class="number">0</span>;   </span><br><span class="line">    mark = -<span class="number">1</span>;   </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把position设为0，limit不变，一般在把数据重写入Buffer前调用。</span></span><br></pre></td></tr></table></figure>
<p>因为ByteBuffer是处理字节的，那么会有两个问题：</p>
<p><strong>1 如何解决从字节到字符之间乱码问题？</strong></p>
<p>输入到缓冲区前对字节进行编码:”qweqwewq”.getBytes(编码类型)<br>从缓冲区读取后对字节进行解码:new String(str,编码类型)</p>
<p>使用Charser类做相应的转换：<br>Charset.forname(编码类型)。<br>ByteBuffer Charset.encode(CharBuffer)<br>CharBuffer Charset.decode(ByteBuffer)</p>
<p><strong>2 如何支持更多的基本数据类型</strong></p>
<p>使用视图缓冲器，如下图：</p>
<p><img src="/2018/11/21/THING IN JAVA/18 IO流/6.png" alt="视图缓冲器"></p>
<p><strong>为什么称为视图缓冲器？</strong></p>
<p>从视图缓冲器中读写了基本类型的数据，会使得最基本的ByteBuffer中存放的数据也发生变化。<br>这样的好处是：方便对基本数据类型的读写，我们可以很方便的把基本数据类型的数据读取到缓冲器中，同时也可以很方便的从缓冲器中将基本数据类型写到通道中。</p>
<p><strong>基本数据类型转成字节后的顺序有何影响？</strong></p>
<p>默认是大端法，可以使用ByteBuffer类里面的 order(ByteOrder.BIG_ENDIAN/ByteOrder.LITTLE_ENDIAN)来修改成小端法。<br>大端法：高字节在低地址位。<br>小端法：高梓节在高地址位。</p>
<p><strong>如何操作大文件（2GB）？</strong></p>
<p>一整个大文件可能在内存中放不下，这时候需要使用内存映射文件——RandomAccessFile<br>使用方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LargeMappedFiles</span> </span>&#123;   <span class="keyword">static</span> <span class="keyword">int</span> length = <span class="number">0x8FFFFFF</span>; <span class="comment">// 128 MB   </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;     </span><br><span class="line">    MappedByteBuffer out = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test.dat"</span>, <span class="string">"rw"</span>).getChannel().map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>,length);     </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)       </span><br><span class="line">        out.put((<span class="keyword">byte</span>)’x’);     </span><br><span class="line">    print(<span class="string">"Finished writing"</span>);   </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = length/<span class="number">2</span>; i &lt; length/<span class="number">2</span> + <span class="number">6</span>; i++)       </span><br><span class="line">        printnb((<span class="keyword">char</span>)out.get(i));   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>RandomAccessFile会把大文件的小部分一个个放到内存中，隐藏了其它已经交换出去了的部分的细节。</p>
<p>即便传统的IO已经应用NIO优化过了，但是对于大文件的读写，映射内存文件的使用更有优势：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stream Write: 0.56</span><br><span class="line">Mapped Write: 0.12</span><br><span class="line">Stream Read: 0.80</span><br><span class="line">Mapped Read: 0.07</span><br><span class="line">Stream Read/Write: 5.32</span><br><span class="line">Mapped Read/Write: 0.02</span><br></pre></td></tr></table></figure></p>
<p>对数据的读写就涉及到锁的问题，并且系统上的文件竞争的可能是两个完全不同的环境，这时候仅仅使用JVM的加锁可能无法控制，传统的IO没有处理这个问题，<strong>NIO如何解决？</strong></p>
<p>NIO的加锁直接映射到本地操作系统的加锁工具<br>简单的使用案例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLocking</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;     </span><br><span class="line">    FileOutputStream fos= <span class="keyword">new</span> FileOutputStream(<span class="string">"file.txt"</span>);     </span><br><span class="line">    FileLock fl = fos.getChannel().tryLock();     </span><br><span class="line">    <span class="keyword">if</span>(fl != <span class="keyword">null</span>) &#123;       </span><br><span class="line">      System.out.println(<span class="string">"Locked File"</span>);       </span><br><span class="line">      TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);       </span><br><span class="line">      fl.release();      </span><br><span class="line">       System.out.println(<span class="string">"Released Lock"</span>);     </span><br><span class="line">     &#125;     </span><br><span class="line">     fos.close();   </span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>加琐是通道来执行的，还可以使用lock(long position，long size，boolean shared)，区别是lock()是阻塞的，tryLock(long position，long size，boolean shared)是非阻塞的。方法中的参数前两个表示加锁的位置，第三个表示是否可共享。</p>
<blockquote>
<p>之前说错对资源的异常处理应该使用嵌套try-finally</p>
</blockquote>
<h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><p><img src="/2018/11/21/THING IN JAVA/18 IO流/7.png" alt="压缩"><br>使用压缩功能的装饰器</p>
<p><strong>如何使用？</strong></p>
<ol>
<li>单个文件压缩</li>
</ol>
<p>使用GZIPInputStream或者ZIPInputStream包装一下直接读写即可。</p>
<ol start="2">
<li>多个文件压缩</li>
</ol>
<p>方式1：<br>使用ZIPInputStream/ZIPOutputStream，必须结合ZipEntry<br>ZipEntry:压缩文件中的子文件<br>ZIPOutputStream.putNextEntry(ZipEntry):指定下一个子文件的名字，注释，等等属性，之后所有的数据都是压缩到这个子文件中。<br>ZIPInputStream.getNextEntry()：指定下一个需要解压的子文件。</p>
<p>如果是解压缩，有更简单的方法，使用ZipFile，提供了enrtyies方法进行遍历每一个ZipEntry。</p>
<blockquote>
<p>这是个独立的File，并不是继承File</p>
</blockquote>
<p>ZipFile: 压缩文件</p>
<p><strong>确保压缩的文件的正确性？</strong></p>
<p>使用CheckInputStream和CheckOutptuStream计算校验和</p>
<p><strong>jar和zip的区别？（Copy）</strong></p>
<p>JAR 文件格式以流行的 ZIP 文件格式为基础。JAR 格式允许您压缩文件以提高存储效率。与 ZIP 文件不同的是，JAR 文件不仅用于压缩和发布，而且还用于部署和封装库、组件和插件程序，并可被像编译器和 JVM 这样的工具直接使用。在 JAR 中包含特殊的文件，如 manifests 和部署描述符，用来指示工具如何处理特定的 JAR。</p>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p><strong>为什么需要序列化？</strong></p>
<ol>
<li>轻量级持久化应用：比如将对象序列化后的序列保存下来，下次程序启动的时候恢复。</li>
<li>远程方法调用：在其他计算机上恢复该对象。</li>
</ol>
<p><strong>如何使用？</strong></p>
<ol>
<li>实现Serializable接口</li>
<li>使用ObjectOutputStream/ObjectInputStream读写对象。</li>
</ol>
<p><strong>对象从序列化恢复的过程需要做哪些工作？</strong></p>
<ol>
<li>寻找Class文件，找不到会抛出异常。</li>
<li>反序列化</li>
</ol>
<p><strong>如何控制需要序列化的字段？</strong></p>
<ol>
<li>使用transiant关键词，取消改字段自动化。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String username;   </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> String password;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>实现Externalizable接口，实现readObject()和writeObject()自定义序列化<blockquote>
<p>Externalizable会在一开始调用所有的默认构造器，若无法调用，则无法序列化</p>
</blockquote>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Blip3 implements Externalizable &#123;   </span><br><span class="line">  private int i=1;  </span><br><span class="line">  private String s=&quot;123&quot;; // No initialization    </span><br><span class="line">  public void writeExternal(ObjectOutput out)   throws IOException &#123;</span><br><span class="line">    print(&quot;Blip3.writeExternal&quot;);     </span><br><span class="line">    // You must do this:     </span><br><span class="line">    out.writeObject(s);     </span><br><span class="line">    out.writeInt(i);   </span><br><span class="line">  &#125;</span><br><span class="line">  public void readExternal(ObjectInput in) throws IOException , ClassNotFoundException &#123;     print(&quot;Blip3.readExternal&quot;);    </span><br><span class="line">  // You must do this:     </span><br><span class="line">  s = (String)in.readObject();     </span><br><span class="line">  i = in.readInt();   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>实现Sernalizable接口，也可以做到Externalizable同样的功效，不过要求必须“添加”以下两个方法：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream stream)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectlnputStream stream)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br></pre></td></tr></table></figure>
<p>ObjectOutputStream/ObjectInputStream读写时候会使用反射去判断Sernalizable的实现中有没有这两个方法。<br>在writeObject中调用stream.defaultWriteObject()（必须作为第一个方法），可以使用默认机制写入非transient部分。</p>
<hr>
<p><strong>序列化后的字节是怎样的？</strong></p>
<p>对象案例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">int</span> parentVersion = <span class="number">10</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">contain</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;  </span><br><span class="line">       <span class="keyword">int</span> containVersion = <span class="number">11</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialTest</span> <span class="keyword">extends</span> <span class="title">parent</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">int</span> version = <span class="number">66</span>;  </span><br><span class="line">       contain con = <span class="keyword">new</span> contain();  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVersion</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">              <span class="keyword">return</span> version;  </span><br><span class="line">       &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>序列化的结果如下图：</p>
<p><img src="/2018/11/21/THING IN JAVA/18 IO流/8.png" alt="序列化字节分析"><br><img src="/2018/11/21/THING IN JAVA/18 IO流/9.png" alt="序列化字节分析"></p>
<p>有一个需要注意的点是：上图中开头的4个字节AC ED 00 05是ObjectOutputStream建立的后就会被写入的，即便没有序列化的对象也会有这4个字节，因此如果重复的生成ObjectOutputStream流，会出现AC ED 00 05 AC ED 00 05的情况，这时候后一串AC ED 00 05会被当做对象字节处理，这时候会抛出StreamCorruptedException异常，<strong>如何解决？</strong></p>
<p>AC ED 00 05的信息是由 ObjectOutputStream.writeSystemHeader()写进入的，因此对于之后重复创建的ObjectOutputStream流，必须重写这个方法，使其不写入这些头信息。</p>
<p><strong>反序列化后的对象（包括对象里的对象）是否一样？</strong></p>
<p>说到一样，就涉及到内容一样（地址不一样，深复制）和地址一样（浅复制）。<br>关于这一部分内容下面的链接可供学习：<br>[深复制和浅复制]<a href="https://www.cnblogs.com/yxnchinahlj/archive/2010/09/20/1831615.html" target="_blank" rel="noopener">https://www.cnblogs.com/yxnchinahlj/archive/2010/09/20/1831615.html</a><br>使用序列化是深复制。<br>但是需要注意的是，<em>在单一流里，相同的对象序列最后反序列化对来的对象地址是一样的。</em></p>
<p><strong>static会被序列化么？</strong></p>
<p>序列化的是对象的状态，static的信息是类的状态，放在静态区中，因此不会被序列化。如果希望传递static字段的值，需要把这个值给序列化，之后反序列后重新赋值。</p>
<h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><p>Serializable的序列化字节只有JAVA才能反序列化，XML是国际上约定的一种序列化文本，可供JAVA和其它各种语言来进行序列化和反序列化。意味着一个XML文件，往往对应着JAVA中的一个或者多个对象。</p>
<p>java语言有XOM类库支持转换XML的简单使用。</p>
<h2 id="Preferences"><a href="#Preferences" class="headerlink" title="Preferences"></a>Preferences</h2><p>一种更小更简单的序列化方式，同时也比较有限。JAVA中preferences类提供支持。</p>
]]></content>
      <categories>
        <category>Thinking in Java 读书笔记</category>
      </categories>
      <tags>
        <tag>JAVA编程思想</tag>
        <tag>Thinking in JAVA</tag>
        <tag>I/O流</tag>
      </tags>
  </entry>
  <entry>
    <title>19 枚举</title>
    <url>/2018/11/26/THING%20IN%20JAVA/19%20%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<h1 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h1><p> 使用枚举类相比静态变量的优势：<br> 1.使用枚举作为参数，有类型检查的机制，比String作为参数更加安全。<br> 2.提供了很多方法来操作枚举类，更加方便。<br> 3.甚至可以自定义某个枚举类相关的方法。</p>
<h2 id="values-的神秘之处"><a href="#values-的神秘之处" class="headerlink" title="values()的神秘之处"></a>values()的神秘之处</h2><p>枚举类继承了Enum，但是Enum并没有values()方法，那么，<strong>values()从哪来的？</strong></p>
<p>由编译器帮我们生成。至于为什么这样处理，暂不了解。</p>
<p><strong>Enum没有实现values()方法带来的问题？</strong></p>
<p>向上转型的枚举类无法使用values方法，也就意味着无法通过Enum来获取具体的类型信息。<br>当然，我们知道，使用反射基本是无所不能的，并且反射对枚举类型有一些特殊的处理方法。<br>通过getClass()可以获取实际的枚举类型，然后调用getEnumConstants()可以获取枚举类。</p>
<p><strong>编译器还帮我们做了哪些处理？</strong></p>
<ol>
<li>继承了Enum类</li>
<li>加上final关键词，使得无法被继承。</li>
<li>重载了valueOf()方法。<blockquote>
<p>注意是继承，也就意味着枚举类无法继承其他的类。</p>
</blockquote>
</li>
</ol>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>由于枚举无法继承，有时也会带来一些使用上的不便，比如给枚举分类的问题，比如拓展枚举类的问题。</p>
<p><strong>对于无法继承的补偿：</strong></p>
<ol>
<li>使用实现进行分类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> Appetizer implements Food &#123;SALAD, SOUP, SPRING_ROLLS;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> MainCourse implements Food &#123;LASAGNE, BURRITO, PAD_THAI, LENTILS, HUMMOUS, VINDALOO;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> Dessert implements Food &#123;TIRAMISU, GELATO, BLACK_FOREST_CAKE, FRUIT, CREME_CARAMEL;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> Coffee implements Food &#123;BLACK_COFFEE, DECAF_COFFEE, ESPRESSO, LATTE, CAPPUCCINO, TEA, HERB_TEA;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口内的成员变量是final static public的，把枚举类放在接口类纯粹简洁，方便管理。<br>使用方法:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Food food = Food.Appetizer.SALAD;</span><br></pre></td></tr></table></figure></p>
<p>上面存在的一个限制是，如果我要遍历所有的枚举类（比如我要浏览一个菜单中所有的菜品），会显得不太方便，解决方案是使用组合：如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Meal2 &#123;</span><br><span class="line">    APPETIZER(Food.Appetizer.class), MAINCOURSE(Food.MainCourse.class), DESSERT(Food.Dessert.class), COFFEE(Food.Coffee.class);</span><br><span class="line">    <span class="keyword">private</span> Food[] values;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Meal2</span><span class="params">(Class&lt;? extends Food&gt; kind)</span> </span>&#123;</span><br><span class="line">        values = kind.getEnumConstants();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">        <span class="keyword">enum</span> Appetizer implements Food &#123;SALAD, SOUP, SPRING_ROLLS;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">enum</span> MainCourse implements Food &#123;LASAGNE, BURRITO, PAD_THAI, LENTILS, HUMMOUS, VINDALOO;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">enum</span> Dessert implements Food &#123;TIRAMISU, GELATO, BLACK_FOREST_CAKE, FRUIT, CREME_CARAMEL;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">enum</span> Coffee implements Food &#123;BLACK_COFFEE, DECAF_COFFEE, ESPRESSO, LATTE, CAPPUCCINO, TEA, HERB_TEA;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">randomSelection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Enums.random(values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Meal2 meal : Meal2.values()) &#123;</span><br><span class="line">                Food food = meal.randomSelection();</span><br><span class="line">                System.out.println(food);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"---"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面类似把枚举放到了另一个枚举类中，遍历起来会带来很大的方便。<br>关于上面两种用法，都是对于无法继承的一个补偿，但是总的来说，使用枚举的初衷就在于简单，所以尽量不要考虑太多复杂的代码。</p>
<h2 id="适应枚举的容器"><a href="#适应枚举的容器" class="headerlink" title="适应枚举的容器"></a>适应枚举的容器</h2><p>枚举类还有个不足就是一旦定义之后，就无法增加或者删除，那么如果有时候需要对一个固定的枚举类做一个筛选，就需要配合容器来使用，但是枚举类相比其他的类型天生就有一个“去重”的优势，考虑到这个优势，就可以设计使用枚举类的更高效的容器：</p>
<p><strong>如何设计更高效的Set容器?</strong></p>
<p>EnumSet：底层使用位运算实现，速度不要太快。用来操作枚举类<br>把所有的枚举类都放到Set中作为所有的元素，保证不重复。<br>用Long的位数0，1来决定某个枚举实例存在性。</p>
<p>使用方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个包含指定元素类型的所有元素的枚举 set</span></span><br><span class="line">EnumSet&lt;SexTwo&gt; setAll = EnumSet.allOf(SexTwo.class);</span><br><span class="line"><span class="comment">//创建一个指定范围的Set</span></span><br><span class="line">EnumSet&lt;SexTwo&gt; setRange = EnumSet.range(SexTwo.MALE,SexTwo.FEMALE);</span><br><span class="line"><span class="comment">//创建一个指定枚举类型的空set</span></span><br><span class="line">EnumSet&lt;SexTwo&gt; setEmpty = EnumSet.noneOf(SexTwo.class);</span><br><span class="line"><span class="comment">//复制一个set</span></span><br><span class="line">EnumSet&lt;SexTwo&gt; setNew = EnumSet.copyOf(setRange);</span><br></pre></td></tr></table></figure></p>
<p>虽然Long只有64位，限制了枚举类中实例的个数，但是Long[]就不只64位了，这也是EnumSet有两个实现的原因。</p>
<p><strong>如何设计更高效的Map容器?</strong></p>
<p>EnumMap：底层使用数组作为实现，速度也不要太快。<br>让枚举类作为key，确保了key的不重复。<br>枚举类的ordinal()作为数组的索引。</p>
<h2 id="枚举类的应用"><a href="#枚举类的应用" class="headerlink" title="枚举类的应用"></a>枚举类的应用</h2><ol>
<li>用作责任链</li>
</ol>
<p><strong>什么是责任链模式？</strong></p>
<p>在面向对象的设计中，责任链模式是由命令对象源和一系列处理对象组成的设计模式。每个处理对象都包含定义它可以处理的命令对象类型的逻辑;其余的传递给链中的下一个处理对象。（维基百科）<br>特性：<br>①一个请求传递给很多个处理对象，不是指向性的，自动寻找可以被解决的处理对象。<br>②能够处理请求的对象称为责任链，是可以动态生成的。</p>
<p>生成责任链有很多种方式，下面给出一种使用链表的方式：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RequestType &#123;</span><br><span class="line">  DEFEND_CASTLE, TORTURE_PRISONER, COLLECT_TAX</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> RequestType requestType;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String requestDescription;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> handled;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Request</span><span class="params">(<span class="keyword">final</span> RequestType requestType, <span class="keyword">final</span> String requestDescription)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.requestType = Objects.requireNonNull(requestType);</span><br><span class="line">    <span class="keyword">this</span>.requestDescription = Objects.requireNonNull(requestDescription);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getRequestDescription</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> requestDescription; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RequestType <span class="title">getRequestType</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> requestType; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">markHandled</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>.handled = <span class="keyword">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHandled</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.handled; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> getRequestDescription(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(RequestHandler.class);</span><br><span class="line">  <span class="keyword">private</span> RequestHandler next;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RequestHandler</span><span class="params">(RequestHandler next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.next = next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Request req)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">      next.handleRequest(req);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">printHandling</span><span class="params">(Request req)</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"&#123;&#125; handling request \"&#123;&#125;\""</span>, <span class="keyword">this</span>, req);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrcCommander</span> <span class="keyword">extends</span> <span class="title">RequestHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">OrcCommander</span><span class="params">(RequestHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Request req)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (req.getRequestType().equals(RequestType.DEFEND_CASTLE)) &#123;</span><br><span class="line">      printHandling(req);</span><br><span class="line">      req.markHandled();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">super</span>.handleRequest(req);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Orc commander"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OrcOfficer and OrcSoldier are defined similarly as OrcCommander</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrcKing</span> </span>&#123;</span><br><span class="line">  RequestHandler chain;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">OrcKing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    buildChain();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    chain = <span class="keyword">new</span> OrcCommander(<span class="keyword">new</span> OrcOfficer(<span class="keyword">new</span> OrcSoldier(<span class="keyword">null</span>)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeRequest</span><span class="params">(Request req)</span> </span>&#123;</span><br><span class="line">    chain.handleRequest(req);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    OrcKing king = <span class="keyword">new</span> OrcKing();</span><br><span class="line">    king.makeRequest(<span class="keyword">new</span> Request(RequestType.DEFEND_CASTLE, <span class="string">"defend castle"</span>)); <span class="comment">// Orc commander handling request "defend castle"</span></span><br><span class="line">    king.makeRequest(<span class="keyword">new</span> Request(RequestType.TORTURE_PRISONER, <span class="string">"torture prisoner"</span>)); <span class="comment">// Orc officer handling request "torture prisoner"</span></span><br><span class="line">    king.makeRequest(<span class="keyword">new</span> Request(RequestType.COLLECT_TAX, <span class="string">"collect tax"</span>)); <span class="comment">// Orc soldier handling request "collect tax"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用枚举类也可以构建责任链：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mail</span> </span>&#123;   <span class="comment">// The NO’s lower the probability of random selection:   </span></span><br><span class="line">    <span class="keyword">enum</span> GeneralDelivery &#123;YES, NO1, NO2, NO3, NO4, NO5&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> Scannability &#123;UNSCANNABLE, YES1, YES2, YES3, YES4&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> Readability &#123;ILLEGIBLE, YES1, YES2, YES3, YES4&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> Address &#123;INCORRECT, OK1, OK2, OK3, OK4, OK5, OK6&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> ReturnAddress &#123;MISSING, OK1, OK2, OK3, OK4, OK5&#125;</span><br><span class="line"></span><br><span class="line">    GeneralDelivery generalDelivery;</span><br><span class="line">    Scannability scannability;</span><br><span class="line">    Readability readability;</span><br><span class="line">    Address address;</span><br><span class="line">    ReturnAddress returnAddress;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> id = counter++;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Mail "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">details</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toString() + <span class="string">", General Delivery: "</span> + generalDelivery + <span class="string">", Address Scanability: "</span> + scannability + <span class="string">", Address Readability: "</span> + readability + <span class="string">", Address Address: "</span> + address + <span class="string">", Return address: "</span> + returnAddress;</span><br><span class="line">    &#125;   <span class="comment">// Generate test Mail:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Mail <span class="title">randomMail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Mail m = <span class="keyword">new</span> Mail();</span><br><span class="line">        m.generalDelivery = Enums.random(GeneralDelivery.class);</span><br><span class="line">        m.scannability = Enums.random(Scannability.class);</span><br><span class="line">        m.readability = Enums.random(Readability.class);</span><br><span class="line">        m.address = Enums.random(Address.class);</span><br><span class="line">        m.returnAddress = Enums.random(ReturnAddress.class);</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Iterable&lt;Mail&gt; <span class="title">generator</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterable&lt;Mail&gt;() &#123;</span><br><span class="line">            <span class="keyword">int</span> n = count;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Iterator&lt;Mail&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;Mail&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> n-- &gt; <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Mail <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> randomMail();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123; <span class="comment">// Not implemented             </span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostOffice</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> MailHandler &#123;</span><br><span class="line">        GENERAL_DELIVERY &#123;</span><br><span class="line">            <span class="function"><span class="keyword">boolean</span> <span class="title">handle</span><span class="params">(Mail m)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">switch</span> (m.generalDelivery) &#123;</span><br><span class="line">                    <span class="keyword">case</span> YES:</span><br><span class="line">                        print(<span class="string">"Using general delivery for "</span> + m);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, MACHINE_SCAN &#123;</span><br><span class="line">            <span class="function"><span class="keyword">boolean</span> <span class="title">handle</span><span class="params">(Mail m)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">switch</span> (m.scannability) &#123;</span><br><span class="line">                    <span class="keyword">case</span> UNSCANNABLE:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">switch</span> (m.address) &#123;</span><br><span class="line">                            <span class="keyword">case</span> INCORRECT:</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">default</span>:</span><br><span class="line">                                print(<span class="string">"Delivering "</span> + m + <span class="string">" automatically"</span>);</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, VISUAL_INSPECTION &#123;</span><br><span class="line">            <span class="function"><span class="keyword">boolean</span> <span class="title">handle</span><span class="params">(Mail m)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">switch</span> (m.readability) &#123;</span><br><span class="line">                    <span class="keyword">case</span> ILLEGIBLE:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">switch</span> (m.address) &#123;</span><br><span class="line">                            <span class="keyword">case</span> INCORRECT:</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">default</span>:</span><br><span class="line">                                print(<span class="string">"Delivering "</span> + m + <span class="string">" normally"</span>);</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, RETURN_TO_SENDER &#123;</span><br><span class="line">            <span class="function"><span class="keyword">boolean</span> <span class="title">handle</span><span class="params">(Mail m)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">switch</span> (m.returnAddress) &#123;</span><br><span class="line">                    <span class="keyword">case</span> MISSING:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        print(<span class="string">"Returning "</span> + m + <span class="string">" to sender"</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">handle</span><span class="params">(Mail m)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Mail m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (MailHandler handler : MailHandler.values()) <span class="keyword">if</span> (handler.handle(m)) <span class="keyword">return</span>;</span><br><span class="line">        print(m + <span class="string">" is a dead letter"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Mail mail : Mail.generator(<span class="number">10</span>)) &#123;</span><br><span class="line">            print(mail.details());</span><br><span class="line">            handle(mail);</span><br><span class="line">            print(<span class="string">"*****"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="多路分发"><a href="#多路分发" class="headerlink" title="多路分发"></a>多路分发</h2><p><strong>什么是分发？</strong></p>
<p>根据对象的类型而对方法进行的选择,就是分发(Dispatch)。</p>
<p><strong>什么是静态分发和动态分发？</strong></p>
<p>静态分发：编译时期根据对象的类型选择方法<br>动态分发：运行时期根据对象的实际类型“置换”正确的方法</p>
<p><strong>什么是单路分发和多路分发？</strong></p>
<p>单路分发：可以根据一个宗量的类型进行对方法的选择<br>多路分发：可以根据多于一个的宗量的类型对方法进行选择</p>
<p><strong>JAVA所属的分发类别？</strong></p>
<p>编译时期，可以根据参数的类型或者根据返回值得类型进行方法的选择，属于静态多路分发。<br>运行时期，可以根据返回值的实际类型进行方法的置换，无法根据参数的实际类型进行方法的置换，属于动态单路分发。</p>
<p><strong>如何简洁的实现动态多路分发？</strong></p>
<p>使用多次单路分发（一次动态：多态，一次静态：重载）来实现动态多路分发：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Item</span> </span>&#123;   </span><br><span class="line">  <span class="function">Outcome <span class="title">compete</span><span class="params">(Item it)</span></span>;   </span><br><span class="line">  <span class="function">Outcome <span class="title">eval</span><span class="params">(Paper p)</span></span>;   </span><br><span class="line">  <span class="function">Outcome <span class="title">eval</span><span class="params">(Scissors s)</span></span>;   </span><br><span class="line">  <span class="function">Outcome <span class="title">eval</span><span class="params">(Rock r)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Paper</span> <span class="keyword">implements</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">compete</span><span class="params">(Item it)</span> </span>&#123;<span class="keyword">return</span> it.eval(<span class="keyword">this</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Paper p)</span> </span>&#123;<span class="keyword">return</span> DRAW;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Scissors s)</span> </span>&#123;<span class="keyword">return</span> WIN;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Rock r)</span> </span>&#123;<span class="keyword">return</span> LOSE;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="string">"Paper"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scissors</span> <span class="keyword">implements</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">compete</span><span class="params">(Item it)</span> </span>&#123;<span class="keyword">return</span> it.eval(<span class="keyword">this</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Paper p)</span> </span>&#123;<span class="keyword">return</span> LOSE;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Scissors s)</span> </span>&#123;<span class="keyword">return</span> DRAW;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Rock r)</span> </span>&#123;<span class="keyword">return</span> WIN;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="string">"Scissors"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rock</span> <span class="keyword">implements</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">compete</span><span class="params">(Item it)</span> </span>&#123;<span class="keyword">return</span> it.eval(<span class="keyword">this</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Paper p)</span> </span>&#123;<span class="keyword">return</span> WIN;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Scissors s)</span> </span>&#123;<span class="keyword">return</span> LOSE;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Rock r)</span> </span>&#123;<span class="keyword">return</span> DRAW;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="string">"Rock"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoShamBo1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Item <span class="title">newItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (rand.nextInt(<span class="number">3</span>)) &#123;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Scissors();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Paper();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Rock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">match</span><span class="params">(Item a, Item b)</span> </span>&#123;</span><br><span class="line">        System.out.println(a + <span class="string">" vs. "</span> + b + <span class="string">": "</span> + a.compete(b));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++) match(newItem(), newItem());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>多路分发的作用？</strong></p>
<p>在于可让调用方法的语法更加的优雅，效果就是不需要关注参数的具体类型，教给程序去判断。</p>
<p>当把上面的多路分发的方法用于枚举类类型的时候，会有问题。原因在于枚举类无法实现重载，<strong>怎么办？</strong></p>
<p>自然有适用于枚举类的多路分发的方法，案例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Competitor</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Competitor</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;   <span class="function">Outcome <span class="title">compete</span><span class="params">(T competitor)</span></span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoShamBo</span> </span>&#123;   </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Competitor&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">match</span><span class="params">(T a, T b)</span> </span>&#123;    </span><br><span class="line">    System.out.println(       a + <span class="string">" vs. "</span> + b + <span class="string">": "</span> +  a.compete(b));   </span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt; &amp; Competitor&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Class&lt;T&gt; rsbClass, <span class="keyword">int</span> size)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    match(Enums.random(rsbClass) , Enums.random(rsbClass));   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RoShamBo2 implements Competitor&lt;RoShamBo2&gt; &#123;</span><br><span class="line">    PAPER(DRAW, LOSE, WIN), SCISSORS(WIN, DRAW, LOSE), ROCK(LOSE, WIN, DRAW);</span><br><span class="line">    <span class="keyword">private</span> Outcome vPAPER, vSCISSORS, vROCK;</span><br><span class="line"></span><br><span class="line">    RoShamBo2(Outcome paper, Outcome scissors, Outcome rock) &#123;</span><br><span class="line">        <span class="keyword">this</span>.vPAPER = paper;</span><br><span class="line">        <span class="keyword">this</span>.vSCISSORS = scissors;</span><br><span class="line">        <span class="keyword">this</span>.vROCK = rock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">compete</span><span class="params">(RoShamBo2 it)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (it) &#123;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">case</span> PAPER:</span><br><span class="line">                <span class="keyword">return</span> vPAPER;</span><br><span class="line">            <span class="keyword">case</span> SCISSORS:</span><br><span class="line">                <span class="keyword">return</span> vSCISSORS;</span><br><span class="line">            <span class="keyword">case</span> ROCK:</span><br><span class="line">                <span class="keyword">return</span> vROCK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RoShamBo.play(RoShamBo2.class, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>于之前的相比，区别在于第一次使用了枚举类的方法调用，第二次使用了枚举类的switch()。</p>
<p>可以使用EnumMap进一步优化：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">table = <span class="keyword">new</span> EnumMap&lt;RoShamBo5,EnumMap&lt;RoShamBo5,Outcome&gt;&gt;(RoShamBo5.class);</span><br></pre></td></tr></table></figure></p>
<p>因为对于枚举类的多路分发而言，没有复杂的逻辑的情况下，保存两个不同参数下的结果（写死）即可。<br>既然结果已经写死了，那么可以进一步使用数组优化：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Outcome[][] table = &#123;     </span><br><span class="line">  &#123; DRAW, LOSE, WIN &#125;, <span class="comment">// PAPER     </span></span><br><span class="line">  &#123; WIN, DRAW, LOSE &#125;, <span class="comment">// SCISSORS     </span></span><br><span class="line">  &#123; LOSE, WIN, DRAW &#125;, <span class="comment">// ROCK   </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>数组的维度可以使用ordinal()来取得。</p>
]]></content>
      <categories>
        <category>Thinking in Java 读书笔记</category>
      </categories>
      <tags>
        <tag>JAVA编程思想</tag>
        <tag>Thinking in JAVA</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络自顶向下：第二章-应用层</title>
    <url>/2019/02/15/cmpNet/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%EF%BC%9A%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p><strong>两个终端应用如何交流？</strong></p>
<p>本章就是为了解决这个问题</p>
<h2 id="网络应用原则"><a href="#网络应用原则" class="headerlink" title="网络应用原则"></a>网络应用原则</h2><p><strong>什么是终端应用体系结构？</strong></p>
<p>网络上终端之间的不同的交流方式</p>
<p><img src="/2019/02/15/cmpNet/计算机网络自顶向下：第二章-应用层/1.png" alt="两种应用体系结构"></p>
<p><strong>什么是CS应用体系？特征是什么？</strong></p>
<p>网络终端上的主机分为服务器和客服端，<br>客户端上的应用一般是人为交互操作，向服务端发送请求。<br>服务器上有固定，已知的IP，一直在线，服务器上的应用接受来自客服端的请求并处理响应。<br>两个客户端之间不会沟通。</p>
<p><strong>一个服务器主机够用吗？</strong></p>
<p>一个服务器处理所有请求是不够用的，所以需要一个能容纳很多服务器的“数据中心”。<br>更多的时候需要更多个数据中心。<br>需要服务器的成本和宽带成本。</p>
<p><strong>什么是P2P应用体系结构？特征是什么？</strong></p>
<p>两个终端应用直接交互数据的体系，没有服务器。<br>成本比较低。</p>
<p><strong>两个不同主机上的程序如何交流？</strong></p>
<p>对于操作系统而言，实际上是进程在交流。<br>我们把两个终端上的进程分为客户进程和服务进程。<br>无论是哪种体系结构：我们定义，发起会话的进程是客户进程，等待联系开始会话的进程是服务进程。</p>
<p><strong>进程如何从到网络发送/接受数据？</strong></p>
<p>通过“套接字(socket)”。</p>
<p><strong>什么是套接字？</strong></p>
<p>进程好比房子，套接字好比一个门。门之间存在消息传输的设备。<br>套接字是应用层和传输层之间的接口。应用程序的开发者拥有套接字应有层的所有控制和传输层的少数控制。<br>套接字中开发者仅有的传输层控制（以后会详细讨论）是：</p>
<ol>
<li>传输层协议选择（比如TCP）</li>
<li>能设定几个传输层协议的参数<br>以后会具体讨论套接字。</li>
</ol>
<p><img src="/2019/02/15/cmpNet/计算机网络自顶向下：第二章-应用层/2.png" alt="套接字"></p>
<p><strong>出了门的消息该去往何处？</strong></p>
<p>为了确定消息的地址，需要两个数据：</p>
<ol>
<li>IP：确定哪个主机。</li>
<li>PORT：确定主机上的哪个进程。<br>以后会具体讨论端口号。</li>
</ol>
<p><strong>套接字如何选择传输层协议？</strong></p>
<p>套接字的另一边是传输层，因此传输层有责任将消息传递出去，传输层有多个不同的协议可供选择，这就和选择坐放飞机还是火车一样。每种协议都有各自的特性。</p>
<p><strong>那么传输层协议具有哪些不同的服务？</strong></p>
<ol>
<li>可靠的数据传输：确保数据成功的从网络上的一端到达另一端，没有出现丢包的现象。依然存在可承受不可靠传输的网络应用，比如视频聊天/语音聊天等多媒体应用可以承受。</li>
<li>稳定的吞吐量：确保应用之间的数据传输吞吐量不受其他问题的影响。上诉的多媒体应用（带宽敏感应用）就对稳定的吞吐量有一定的需求。</li>
<li>时效性：控制数据传输的时效性，这才交互式的实时应用中比较重要，比如游戏等，必然要求延迟不能太高。</li>
<li>安全性：加密和解密。</li>
</ol>
<p><img src="/2019/02/15/cmpNet/计算机网络自顶向下：第二章-应用层/3.jpg" alt="传输层特性"></p>
<p>TCP/IP网络能提供的传输层服务：TCP和UDP</p>
<p><strong>TCP协议具有哪些特性？</strong></p>
<ol>
<li>面向连接：为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程以及重传策略。</li>
<li>可靠传输：不会丢失数据，也不会出现数据乱序。</li>
</ol>
<blockquote>
<p>TCP和UDP都不具有加密的功能，应用层的SSL服务是TCP的一种增强，可以实现安全传输。如今的网络并没有提供可以保证吞吐量和时效性的协议，虽然可以从其他的手段去提供令人满意的服务。</p>
</blockquote>
<p><strong>TCP协议具有哪些特性？</strong></p>
<ol>
<li>能够对握手过程进行精简，减少网络通信往返次数；</li>
<li>能够对TLS加解密过程进行优化；</li>
<li>收发快速，无阻塞。</li>
</ol>
<p><img src="/2019/02/15/cmpNet/计算机网络自顶向下：第二章-应用层/4.png" alt="常见的网络应用和所采用的实现协议"></p>
<p><strong>应用层协议处理哪些问题？</strong></p>
<p>“消息”的结构是怎样的？什么时候发送消息？如何建立连接？等等。<br>应用层主要定义了：</p>
<ol>
<li>消息的类型：请求消息还是响应消息</li>
<li>不同类型消息的语法：定义消息中的字段</li>
<li>字段的语法：字段信息的含义</li>
<li>进程何时以及如何处理消息</li>
</ol>
<p>以下主要讨论5种应用和相关协议：Web(HTTP)、file transfer(FTP)、electronic mail(SMTP)、directory service、P2P application</p>
<h2 id="Web和HTTP（超文本传输协议）"><a href="#Web和HTTP（超文本传输协议）" class="headerlink" title="Web和HTTP（超文本传输协议）"></a>Web和HTTP（超文本传输协议）</h2><p><strong>什么是web和http？</strong></p>
<p>Web：一种近代的网络应用，可以解析HTTP文本，以此实现全网交流。<br>HTTP：Web的核心协议，定义了两个网络终端程序交流的消息的结构。</p>
<p>HTTP底层使用TCP作为传输层协议，无需关心数据的丢失。<br>HTPP属于无状态协议，服务端不会保存客户端的状态信息。</p>
<p>http对象：可以理解为一个文件，如html文件，jpg文件，video文件等等，一个文件可以被一个url来定址。</p>
<p><strong>HTTP请求的格式？</strong></p>
<p><img src="/2019/02/15/cmpNet/计算机网络自顶向下：第二章-应用层/9.jpg" alt="HTTP请求的格式"></p>
<p>HTTP请求行有3个字段：请求类型+URL+HTTP版本</p>
<ul>
<li>GET：用来获取http对象，URL指明对象的地址。</li>
<li>POST：依然是获取http对象，往往用来需要填写表单的位置，表单作为请求体的参数，根据参数来具体返回相应的对象。</li>
<li>HEAD：和GET一样，但是不会再返回中包含请求的http对象。</li>
<li>PUT：通常用于上传http对象</li>
<li>DELETE：通常用于删除http对象</li>
</ul>
<p><strong>HTTP响应的格式？</strong></p>
<p><img src="/2019/02/15/cmpNet/计算机网络自顶向下：第二章-应用层/10.png" alt="HTTP响应的格式"></p>
<ul>
<li>200 OK:Request succeeded and the information is returned in the response.</li>
<li>301 Moved Permanently:Requested object has been permanently moved;the new URL is specified inLocation:header of the response message. Theclient software will automatically retrieve the new URL.</li>
<li>400 Bad Request:This is a generic error code indicating that the requestcould not be understood by the server.</li>
<li>404 Not Found:The requested document does not exist on this server.</li>
<li>505 HTTP Version Not Supported:The requested HTTP protocolversion is not supported by the server.</li>
</ul>
<p><strong>什么是持续连接和非持续连接？</strong></p>
<ul>
<li><p>非持久连接：一个请求使用一个tcp连接<br>缺点：1.每次建立tcp连接都需要消耗额外的cpu消耗和内存消耗。2.获取一个http对象就需要2个RTT时间</p>
<blockquote>
<p>RRT时间：一个小的包分组在客户端和服务端往返的时间</p>
</blockquote>
</li>
<li><p>持久连接：多个请求同一个tcp连接<br>缺点：一直占用一个通道，一旦空闲、就会无端占用资源。</p>
</li>
</ul>
<p><strong>如何理解有状态和无状态？</strong></p>
<ul>
<li>【无状态】：假设用户A向服务B发了一个请求1，再次发送一个请求2。 服务端本身完全不知道两个请求来自同一个用户，这在协议层次就是【无状态】的。</li>
</ul>
<p>更通俗一点：</p>
<ul>
<li>【有状态】：消息不需要附带额外的认证消息</li>
<li>【无状态】：每一个消息都需要附带额外的认证消息</li>
</ul>
<p><strong>无状态的影响？</strong></p>
<p>无状态意味着，客户端不会记得每个请求的客户端和用户，比如购物网站，就需要记录每次请求用户的信息，那就意味着每个请求都需要携带重复的用户数据，这样处理的好处是减轻了服务器的负担，尽管请求会变得复杂，但是服务器也只是处理这些复杂的参数，而无需额外的消耗来维护各种状态。</p>
<p>优化请求信息的方式还有很多，最多的就是cookie和session</p>
<p><strong>cookie的工作方式？</strong></p>
<p>cookie：保存在客户端的数据<br>session：保存在服务器里的数据（表）</p>
<p><img src="/2019/02/15/cmpNet/计算机网络自顶向下：第二章-应用层/5.png" alt="cookie"></p>
<p><strong>web缓存的工作方式和作用？</strong></p>
<p><img src="/2019/02/15/cmpNet/计算机网络自顶向下：第二章-应用层/6.png" alt="web缓存"></p>
<p>Web缓存(也称为代理服务器)是代表原始Web服务器满足HTTP请求的网络实体。<br>最重要的是可以将请求的结果保存在代理服务器中，好处：</p>
<ol>
<li>减少客户端的响应时间</li>
<li>减少访问internet的流量。</li>
</ol>
<p><strong>如何更新缓存？</strong></p>
<p>conditional Get Request：一种特殊的请求，有两个特性：</p>
<ol>
<li>使用get</li>
<li>在请求头中包含If-Modified-Since或If-None-Match字段</li>
</ol>
<p>首次请求服务器，服务器返回的Response Headers中，指定过期时间，未指定默认为7天</p>
<p>除此之外包含Last-Modified字段或者ETag字段。Last-Modified 表示被请求资源在服务器端的上次修改时间，而ETag则是一个唯一文件标识符，每次文件修改后都会生成一个新的ETag。服务器通过向浏览器发送这两个字段，来告知浏览器其获得的资源的版本。</p>
<p>下次会在请求头中包含If-Modified-Since或If-None-Match字段。未更新则返回304状态吗。</p>
<p><img src="/2019/02/15/cmpNet/计算机网络自顶向下：第二章-应用层/7.jpg" alt="conditional Get Request"></p>
<h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><p><strong>什么是FTP</strong></p>
<p><img src="/2019/02/15/cmpNet/计算机网络自顶向下：第二章-应用层/8.png" alt="FTP"></p>
<p>文件传输协议：</p>
<p><strong>FTP和HTTP的区别</strong></p>
<p>和HTTP大部分一样，底层使用TCP实现，区别在于FTP使用两个平行的TCP连接来传输一个文件：一个控制连接，一个数据连接。</p>
<p><strong>FTP的消息结构</strong></p>
<p>客服端建立控制连接，输入身份认证的命令和文件操作指令，服务端建立数据连接进行数据的传输。</p>
<p>使用下面的命令建立连接：<br>TELNET 127.0.0.1 21</p>
<p>FTP Commands：</p>
<ul>
<li>USER username:Used to send the user identification to the server.</li>
<li>PASS password:Used to send the user password to the server.</li>
<li>LIST:Used to ask the server to send back a list of all the files in the currentremote directory. The list of files is sent over a (new and non-persistent) dataconnection rather than the control TCP connection.</li>
<li>RETR filename:Used to retrieve (that is, get) a file from the current direc-tory of the remote host.</li>
</ul>
<p>replies：</p>
<ul>
<li>331 Username OK, password required</li>
<li>125 Data connection already open; transfer starting</li>
<li>425 Can’t open data connection</li>
<li>452 Error writing file</li>
</ul>
<h2 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h2><p><strong>什么是SMTP？</strong></p>
<p><img src="/2019/02/15/cmpNet/计算机网络自顶向下：第二章-应用层/11.png" alt="SMTP"></p>
<p>简单邮件传输协议</p>
<p><strong>和HTTP的区别？</strong></p>
<p>底层同样是采用TCP协议</p>
<ol>
<li>HTTP是“拉”协议，SMTP是“推”协议</li>
<li>SMTP要求消息的必须是7位ASCII格式的，因此二进制文件必须比如转换成7位ASCII进行传输，比较麻烦。</li>
<li>一个HTTP响应包含一个消息对象，一个SMTP消息包含所有的消息对象。</li>
</ol>
<p><strong>SMPT消息格式：</strong></p>
<p><img src="/2019/02/15/cmpNet/计算机网络自顶向下：第二章-应用层/12.png" alt="SMTP消息"></p>
<p><strong>从服务器获取消息的方式？</strong></p>
<p>STMP是“推”协议，因此无法用来读取邮件消息的操作。<br>常用的读取消息的协议：POP3(Post Office Protocol—Version 3),IMAP(Internet Mail Access Protocol),HTTP</p>
<p><img src="/2019/02/15/cmpNet/计算机网络自顶向下：第二章-应用层/13.png" alt="获取消息"></p>
<p><strong>POP3协议：</strong></p>
<p>简单的读取协议，采用TCP协议。</p>
<p>telnet mailServer 110<br>+OK POP3 server ready<br>user bob<br>+OK<br>pass hungry<br>+OK user successfully logged on</p>
<p>C: list<br>S: 1 498<br>S: 2 912<br>S: .<br>C: retr 1<br>S: (blah blah …<br>S: ……………..<br>S: ……….blah)<br>S: .<br>C: dele 1<br>C: retr 2<br>S: (blah blah …<br>S: ……………..<br>S: ……….blah)<br>S: .<br>C: dele 2<br>C: quit<br>S: +OK POP3 server signing off</p>
<p><strong>IMAP协议：</strong></p>
<p>优势：</p>
<ol>
<li>维护可从任何计算机访问的远程服务器上的文件夹层次结构。每一个消息都和一个文件夹绑定。</li>
<li>可以获取消息的部分（可以通过邮件的标题，时间等等来决定是否下载附件）</li>
</ol>
<p><strong>基于HTTP：</strong></p>
<p>交互更加友好</p>
<h2 id="DNS-Domain-Name-System"><a href="#DNS-Domain-Name-System" class="headerlink" title="DNS(Domain Name System)"></a>DNS(Domain Name System)</h2><p><strong>DNS协议有什么作用？</strong></p>
<p>和人一样，每台主机都有唯一的主机名和别名<br>但是这个名字并不好被路由处理，因此使用IP作为唯一<br>DNS协议用UPD实现，占用53端口<br>功能：</p>
<ol>
<li>将主机名转换成IP</li>
<li>给主机名(canonical hostname)起比较好记的别名,DNS可以通过别名获取主机名和IP。</li>
<li>负载均衡，可以为不同的IP和canonical hostname的主机取同一个别名，当访问的时候以某些策略分配负载。</li>
</ol>
<p><strong>DNS简单工作原理：</strong></p>
<p>最简单的设计师只有一个DNS服务器处理所有的映射，问题是：</p>
<ol>
<li>单点故障</li>
<li>流量太大</li>
<li>无妨满足全球范围</li>
<li>难以维护更新</li>
</ol>
<p><strong>如何解决一个DNS服务器的问题？</strong></p>
<p>分布式继承结构：</p>
<ul>
<li>root DNS服务器：根据域名最后一节com/edu/io等等获取TLD服务器IP地址</li>
<li>TLD DNS服务器：根据域名倒数第二节获取权威DNS服务器IP地址</li>
<li>authoritative DNS服务器：获取目标IP地址</li>
</ul>
<p>一般而言是这三层，除此之外还有比较重要的两层是：</p>
<ul>
<li>中间服务器：因为TLD DNS服务器可能并不能直接获取authoritative DNS服务器IP</li>
<li>local DNS服务器：给其它的服务器发送请求</li>
</ul>
<p><img src="/2019/02/15/cmpNet/计算机网络自顶向下：第二章-应用层/14.png" alt="分布式多层DNS"></p>
<p><img src="/2019/02/15/cmpNet/计算机网络自顶向下：第二章-应用层/15.png" alt="递归DNS"></p>
<p>每台DNS服务器都有缓存功能</p>
<p><strong>这些映射关系是如何记录的？</strong></p>
<p>存储在每一个DNS服务器数据库中，记录的格式是一个四元组：(Name, Value, Type, TTL)<br>TTL表示缓存的时间<br>Type表示记录的类型，有如下几种类型：</p>
<ol>
<li>Type=A：标准的映射记录，Name是主机名，Value是IP值。如(relay1.bar.foo.com, 145.37.93.126, A)</li>
<li>Type=NS，Name是域名，Value是DNS服务器的主机名。如(foo.com, dns.foo.com, NS)</li>
<li>Type=CNAME，Name是别名，Value是权威名。如(foo.com, relay1.bar.foo.com, CNAME)</li>
<li>Type=MX,Name是权威名，Value是邮箱服务器的主机名。</li>
</ol>
<p><strong>DNS协议的消息格式？</strong></p>
<p><img src="/2019/02/15/cmpNet/计算机网络自顶向下：第二章-应用层/16.png" alt="DNS消息"></p>
<p><strong>记录如何插入到数据库中？</strong></p>
<p>不考虑缓存的话：<br>直接获取目标IP的A类型的记录被存在authoritative DNS服务器中。其余的记录在被保存的同时会附带一条A类型的数据，记录Value中服务器主机名的IP。</p>
<h2 id="P2P（Peer-to-Peer-Application）"><a href="#P2P（Peer-to-Peer-Application）" class="headerlink" title="P2P（Peer-to-Peer Application）"></a>P2P（Peer-to-Peer Application）</h2><p>之前的协议都是基于CS设施，而P2P可以不需要服务器，每一个计算机都可以充当服务器。</p>
<p><img src="/2019/02/15/cmpNet/计算机网络自顶向下：第二章-应用层/18.png" alt="CS"></p>
<p><img src="/2019/02/15/cmpNet/计算机网络自顶向下：第二章-应用层/19.png" alt="P2P"></p>
<h3 id="P2P文件分享"><a href="#P2P文件分享" class="headerlink" title="P2P文件分享"></a>P2P文件分享</h3><p>一个最大的应用是文件的分享</p>
<p><strong>优势是什么？</strong></p>
<p>可以极大的提升文件分享的时间</p>
<p>CS系统：分享时间和文件的分享数呈线性关系<br>P2P系统：分享时间和文件的分享数呈现抛物线关系</p>
<p><img src="/2019/02/15/cmpNet/计算机网络自顶向下：第二章-应用层/17.png" alt="DNS消息"></p>
<p><strong>基于BitTorrent简单的工作方式：</strong></p>
<p>一个完整的文件被分成很多个片段（chunks）存放在不同的Peer中<br>存在一个tracker服务器记录所有peer<br>当一个新用户请求下载的时候，请求tracker获取拥有资源块的peer列表<br>与peer建立tcp连接，称为neighbor，之后进行文件的传输<br>存在的两个问题：</p>
<ol>
<li>哪个片段应该优先从neighbor中获取</li>
<li>请求后的块应该发送给哪些neighbor</li>
</ol>
<p><strong>哪个片段应该优先从neighbor中获取？</strong></p>
<p>最稀罕优先<br>优先获取在洪流(torrent)中出现较小的块<br>平衡块在洪流中的数量</p>
<p><strong>请求后的块(chunks)应该发送给哪些neighbor？</strong></p>
<p>对换算法<br>确定neighbor的优先级，从中选取4个最高速率的neighbor发送块(chunks)。<br>10s刷新这个速率<br>30s随机的向一个其他的neighbor发送块，从而防止“死锁”</p>
<p>对换算法解决了P2P中“搭免费车”（只下载，不上传）的问题。</p>
<h3 id="DHT协议（Distributed-Hash-Table）"><a href="#DHT协议（Distributed-Hash-Table）" class="headerlink" title="DHT协议（Distributed Hash Table）"></a>DHT协议（Distributed Hash Table）</h3><p><strong>如何减少对于tracker服务器的依赖？</strong></p>
<p>使用DHT协议(Distributed Hash Table)</p>
<p><strong>简单的工作原理介绍</strong></p>
<ol>
<li>首先对每个Peer进行标记，其中每个标识符都是某个固定n的范围[0，2^n-1]中的整数。</li>
<li>对资源片段进行hash计算，hash值作为数据库键值对的key,value是拥有该资源片段的的计算机IP</li>
<li>根据key值定位最近(closest)的peer，何为最近？第一个大于key的peer。</li>
<li>请求该peer</li>
</ol>
<p>上面第3步，需要每一个peer都知道其他所有的peer才能正确的判断，这是不实际的。</p>
<p><strong>如何改进？</strong></p>
<p>采用循环DHT——每一个peer都知道自己的前驱节点和后继节点<br>可是即便如此，平均也需要遍历N/2次<br>因此可以适当的调整每一个peer记录的节点数（称为shortcut）达到记录数和遍历数的一个平衡。</p>
<p><img src="/2019/02/15/cmpNet/计算机网络自顶向下：第二章-应用层/20.png" alt="DHT"></p>
<h2 id="套接字编程：创建网络应用"><a href="#套接字编程：创建网络应用" class="headerlink" title="套接字编程：创建网络应用"></a>套接字编程：创建网络应用</h2><p><strong>UDP套接字编程：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//client</span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverName = ‘hostname’</span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line">clientSocket = socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">message = raw_input(’Input lowercase sentence:’)</span><br><span class="line">clientSocket.sendto(message,(serverName, serverPort))</span><br><span class="line">modifiedMessage, serverAddress = clientSocket.recvfrom(<span class="number">2048</span>)</span><br><span class="line"><span class="keyword">print</span> modifiedMessageclientSocket.close()</span><br><span class="line"></span><br><span class="line">//server</span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line">serverSocket.bind((’’, serverPort))</span><br><span class="line"><span class="keyword">print</span>”The server <span class="keyword">is</span> ready to receive”</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">  message, clientAddress = serverSocket.recvfrom(<span class="number">2048</span>)</span><br><span class="line">  modifiedMessage = message.upper()</span><br><span class="line">  serverSocket.sendto(modifiedMessage, clientAddress)</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/15/cmpNet/计算机网络自顶向下：第二章-应用层/21.png" alt="UDP"></p>
<p><strong>TCP套接字编程：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//client</span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverName = ’servername’</span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">clientSocket.connect((serverName,serverPort))</span><br><span class="line">sentence = raw_input(‘Input lowercase sentence:’)</span><br><span class="line">clientSocket.send(sentence)</span><br><span class="line">modifiedSentence = clientSocket.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="keyword">print</span> ‘From Server:’, modifiedSentence</span><br><span class="line">clientSocket.close()</span><br><span class="line"></span><br><span class="line">//client</span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line">serverSocket = socket(AF_INET,SOCK_STREAM)</span><br><span class="line">serverSocket.bind((‘’,serverPort))</span><br><span class="line">serverSocket.listen(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span> ‘The server <span class="keyword">is</span> ready to receive’</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">  connectionSocket, addr = serverSocket.accept()</span><br><span class="line">  sentence = connectionSocket.recv(<span class="number">1024</span>)</span><br><span class="line">  capitalizedSentence = sentence.upper()</span><br><span class="line">  connectionSocket.send(capitalizedSentence)</span><br><span class="line">  connectionSocket.close()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/15/cmpNet/计算机网络自顶向下：第二章-应用层/21.png" alt="TCP"></p>
<p><img src="/2019/02/15/cmpNet/计算机网络自顶向下：第二章-应用层/22.png" alt="TCP"></p>
]]></content>
      <categories>
        <category>计算机网络自顶向下</category>
      </categories>
      <tags>
        <tag>计算机网络自顶向下</tag>
      </tags>
  </entry>
  <entry>
    <title>08 数据重构</title>
    <url>/2019/01/11/refactoring/08%20%E6%95%B0%E6%8D%AE%E9%87%8D%E6%9E%84/</url>
    <content><![CDATA[<h1 id="数据重构"><a href="#数据重构" class="headerlink" title="数据重构"></a>数据重构</h1><p>数据应该符合封装的思想<br>是直接读取还是间接读取？<br>是用字段还是用对象？<br>是值对象还是引用对象？<br>是单向关联还是双向关联？<br>如何更好的表示类型码？常量？类？</p>
<h2 id="Self-Encapsulate-Field（自封装值域）"><a href="#Self-Encapsulate-Field（自封装值域）" class="headerlink" title="Self Encapsulate Field（自封装值域）"></a>Self Encapsulate Field（自封装值域）</h2><p>problem:你直接访问一个私有值域（field），但与值域之间的耦合关系逐渐无法满足需求。<br>solution:为这个值域建立取值/设值函数（getting and setting methods ），并且只以这些函数来访问值域。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> _low, _high;</span><br><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">includes</span> <span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> arg &gt;= _low &amp;&amp; arg &lt;= _high;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//======================after refactoring=========================</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> _low, _high;</span><br><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">includes</span> <span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> arg &gt;= getLow() &amp;&amp; arg &lt;= getHigh();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">getLow</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _low;&#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">getHigh</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _high;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>重构原因？</strong></p>
<p>「直接访问变量」的好处则是：代码比较容易阅读，不需要再多此一举。</p>
<p>「间接访问变量」更符合封装，好处是：</p>
<ol>
<li>我可以在getter方式，或者setter方法中统一增加查询和修改的逻辑，减少耦合。</li>
<li>支持更灵活的数据管理方式：在字段getter和setter中可以轻松实现字段值的延迟初始化和验证。</li>
<li>可以在子类中覆盖getter和setter中和方法，实现自己的需求。<blockquote>
<p>直接访问变量也并无坏处，一般可以根据公司的要求来，或者根据需要变化。</p>
</blockquote>
</li>
</ol>
<h2 id="Replace-Data-Value-with-Object（以对象取代数据值）"><a href="#Replace-Data-Value-with-Object（以对象取代数据值）" class="headerlink" title="Replace Data Value with Object（以对象取代数据值）"></a>Replace Data Value with Object（以对象取代数据值）</h2><p>problem:多个类中包含相同的一个数据字段，这个数据字段有相同的行为和关联数据。<br>solution:创建一个新类，把这个字段和他的行为放进去；original class保存这个新类。</p>
<p><img src="/2019/01/11/refactoring/08 数据重构/1.gif" alt=""></p>
<p><strong>重构原因？</strong></p>
<p>该重构是Extract Class的特例。Extract Class是分离类的职责，而Replace Data Value with Object是解决“这个字段和行为系列可以同时出现在几个类中，从而创建重复的代码”的问题的。</p>
<p><strong>如何重构?</strong></p>
<ul>
<li>使用Self Encapsulate Field隐藏original class中对于这个字段的访问</li>
<li>创建一个新类，copy字段和getter方法。创建一个构造器来初始化值。暂时不需要setter字段，因为目前只是重构成一个值对象。</li>
<li>在original class中，把字段的类型改成new class类型。</li>
<li>在original class的构造器中初始化这个字段。</li>
<li>original class的getter调用associated object的getter</li>
<li>original class的setter创建一个new class。</li>
</ul>
<p><strong>什么是值对象和引用对象？</strong></p>
<p>值对象：一个现实对象对应多个对象。比如地址/颜色/喜好。用对象的关系来体现，引用对象就是组合关系。<br><img src="/2019/01/11/refactoring/08 数据重构/2.png" alt=""></p>
<p>引用对象：一个现实对象对应一个对象。比如客户/产品。用对象的关系来体现，引用对象就是聚合关系。<br><img src="/2019/01/11/refactoring/08 数据重构/3.png" alt=""></p>
<blockquote>
<p>对于对象关系，请参考【UML】一文</p>
</blockquote>
<h2 id="Change-Value-to-Reference（将实值对象改为引用对象）"><a href="#Change-Value-to-Reference（将实值对象改为引用对象）" class="headerlink" title="Change Value to Reference（将实值对象改为引用对象）"></a>Change Value to Reference（将实值对象改为引用对象）</h2><p>把值对象变为引用对象</p>
<p><strong>重构原因？</strong></p>
<p>值对象一般不应该具有setter方法，如果希望修改数据，并且希望所有引用此对象的地方都能看到这个修改。</p>
<h2 id="Change-Reference-to-Value（把引用对象变成值对象）"><a href="#Change-Reference-to-Value（把引用对象变成值对象）" class="headerlink" title="Change Reference to Value（把引用对象变成值对象）"></a>Change Reference to Value（把引用对象变成值对象）</h2><p>把引用对象变成值对象</p>
<p><strong>重构原因？</strong></p>
<p>引用对象不好用了：</p>
<ol>
<li>可能造成内存区域之间错综复杂的关联。</li>
<li>在分布系统和并发系统中，不可变的value object特别有用，因为你无须考虑它们的同步问题。</li>
<li>我希望简单的访问一些不会被改变的对象</li>
</ol>
<h2 id="Replace-Array-with-Object（以对象取代数组）"><a href="#Replace-Array-with-Object（以对象取代数组）" class="headerlink" title="Replace Array with Object（以对象取代数组）"></a>Replace Array with Object（以对象取代数组）</h2><p>以对象替换数组。对于数组中的每个元素，以一个值域表示之。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] row = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">row [<span class="number">0</span>] = <span class="string">"Liverpool"</span>;</span><br><span class="line">row [<span class="number">1</span>] = <span class="string">"15"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//======================after refactoring=========================</span></span><br><span class="line"></span><br><span class="line">Performance row = <span class="keyword">new</span> Performance();</span><br><span class="line">row.setName(<span class="string">"Liverpool"</span>);</span><br><span class="line">row.setWins(<span class="string">"15"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>重构原因？</strong></p>
<p>数组应该只用于「以某种顺序容纳一组相似对象」<br>不要用数组来记录数种不同对象，因为很难记住第一个元素表示什么含义。</p>
<h2 id="Change-Unidirectional-Association-to-Bidirectional（将单向关联改为双向）"><a href="#Change-Unidirectional-Association-to-Bidirectional（将单向关联改为双向）" class="headerlink" title="Change Unidirectional Association to Bidirectional（将单向关联改为双向）"></a>Change Unidirectional Association to Bidirectional（将单向关联改为双向）</h2><p>problem:两个classes都需要使用对方特性，但其间只有一条单向连接（one-way link）。<br>solution:添加一个反向指针，并使修改函数（modifiers）能够同时更新两条连接。（译注：这里的指针等同于句柄（handle），修改函数（modifier）指的是改变双方关系者）<br>这个修改函数所在类就是维护方。</p>
<p><strong>重构原因？</strong></p>
<p>随着时间推移，可能发现referred class需要得到其引用者（某个object）以便进行某些处理。<br>在获取反向引用的过程比较麻烦的时候需要进行重构</p>
<p><strong>如何重构？</strong></p>
<ul>
<li>在class中增加一个值域，用以保存「反向指针」。</li>
<li>决定由哪个class (引用端或被引用端）控制关联性（association）。</li>
<li>在「被控端」建立一个辅助函数，其命名应该清楚指出它的有限用途。</li>
<li>如果既有的修改函数（modifier）在「控制端」，让它负责更新反向指针。</li>
<li>如果既有的修改函数（modifier）在「被控端」，就在「控制端」建立一个控制函数，并让既有的修改函数调用这个新建的控制函数。</li>
</ul>
<p><strong>哪一段比较适合作为控制端？</strong></p>
<p>【一对多】：让多的一方作为控制端<br>【一对一和多对多】：任意一方</p>
<h2 id="Change-Bidirectional-Association-to-Unidirectional（将双向关联改为单向）"><a href="#Change-Bidirectional-Association-to-Unidirectional（将双向关联改为单向）" class="headerlink" title="Change Bidirectional Association to Unidirectional（将双向关联改为单向）"></a>Change Bidirectional Association to Unidirectional（将双向关联改为单向）</h2><p>problem:两个鄉之间有双向关联，但其中一个class如今不再需要另一个class的特性。<br>solution:去除不必要的关联（association）。</p>
<p><img src="/2019/01/11/refactoring/08 数据重构/4.gif" alt=""></p>
<p><strong>重构原因？</strong></p>
<ol>
<li>双向关联（bidirectional associations）很有用，但你也必须为它付出代价，那就是「维护双向连接、确保对象被正确创建和删除」而增加的复杂度。</li>
<li>大量的双向连接（two-way links）也很容易引发「僵尸对象」：某个对象本来已经该死亡了，却仍然保留在系统中，因为对它的各项引用还没有完全清除。</li>
<li>过多的双向关联会导致紧耦合过多，造成一个类的变化对另外的类造成影响。<br>当不再需要另一个class的特性的时候，可以进行重构。</li>
</ol>
<h2 id="Replace-Magic-Number-with-Symbolic-Constant（以符号常量-字面常量取代魔法数）"><a href="#Replace-Magic-Number-with-Symbolic-Constant（以符号常量-字面常量取代魔法数）" class="headerlink" title="Replace Magic Number with Symbolic Constant（以符号常量/字面常量取代魔法数）"></a>Replace Magic Number with Symbolic Constant（以符号常量/字面常量取代魔法数）</h2><p>problem:使用具有特定含义的数字。<br>solution:将此数字替换为具有解释数字含义的可读名称的常量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">potentialEnergy</span><span class="params">(<span class="keyword">double</span> mass, <span class="keyword">double</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mass * <span class="number">9.81</span> * height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//======================after refactoring=========================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">potentialEnergy</span><span class="params">(<span class="keyword">double</span> mass, <span class="keyword">double</span> height)</span> </span>&#123;     </span><br><span class="line">  <span class="keyword">return</span> mass * GRAVITATIONAL_CONSTANT * height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> GRAVITATIONAL_CONSTANT = <span class="number">9.81</span>;</span><br></pre></td></tr></table></figure>
<p><strong>重构原因？</strong></p>
<p>一旦这些具有特殊含义的数值不断发生改变，将会是一场噩梦。</p>
<h2 id="Encapsulate-Field（封装值域）"><a href="#Encapsulate-Field（封装值域）" class="headerlink" title="Encapsulate Field（封装值域）"></a>Encapsulate Field（封装值域）</h2><p>problem:你的class中存在一个public值域。<br>solution:将它声明为private，并提供相应的访问函数（accessors）。</p>
<blockquote>
<p>和Self Encapsulate Field不同，这里的字段是public的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String _name</span><br><span class="line"></span><br><span class="line"><span class="comment">//======================after refactoring=========================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String _name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _name;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String arg)</span> </span>&#123;_name = arg;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>重构原因？</strong></p>
<p>符合封装的思想<br>间接管理更灵活</p>
<h2 id="Encapsulate-Collection（封装群集）"><a href="#Encapsulate-Collection（封装群集）" class="headerlink" title="Encapsulate Collection（封装群集）"></a>Encapsulate Collection（封装群集）</h2><p>有个函数（method）返回一个群集（collection）。<br>让这个函数返回该群集的一个只读映件（read-only view），并在这个class中提供「添加/移除」（add/remove）群集元素的函数。</p>
<p><img src="/2019/01/11/refactoring/08 数据重构/5.gif" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Set _courses;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Set <span class="title">getCourses</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> _courses;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCourses</span><span class="params">(Set arg)</span> </span>&#123;</span><br><span class="line">       _courses = arg;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//======================after refactoring=========================</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCourse</span> <span class="params">(Course arg)</span> </span>&#123;</span><br><span class="line">       _courses.add(arg);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeCourse</span> <span class="params">(Course arg)</span> </span>&#123;</span><br><span class="line">       _courses.remove(arg);</span><br><span class="line">   &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> Set <span class="title">getCourses</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Collections.unmodifiableSet(_courses);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>重构原因？</strong></p>
<p>也是封装的思想<br>不应该让其他类直接获取和修改数据</p>
<h2 id="Replace-Type-Code-with-Class（以类取代型别码）"><a href="#Replace-Type-Code-with-Class（以类取代型别码）" class="headerlink" title="Replace Type Code with Class（以类取代型别码）"></a>Replace Type Code with Class（以类取代型别码）</h2><p>class之中有一个数值型别码（numeric type code），但它并不影响class的行为。</p>
<blockquote>
<p>针对JAVA，使用枚举类也行</p>
</blockquote>
<p><img src="/2019/01/11/refactoring/08 数据重构/7.gif" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> O = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> B = <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AB = <span class="number">3</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> _bloodGroup;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Person</span> <span class="params">(<span class="keyword">int</span> bloodGroup)</span> </span>&#123;</span><br><span class="line">       _bloodGroup = bloodGroup;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBloodGroup</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       _bloodGroup = arg;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBloodGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> _bloodGroup;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//======================after refactoring=========================</span></span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> BloodGroup _bloodGroup;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Person</span> <span class="params">(BloodGroup bloodGroup)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>._bloodGroup = bloodGroup;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBloodGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> _bloodGroup.getCode();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBloodGroup</span><span class="params">(BloodGroup bloodGroup)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>._bloodGroup = bloodGroup;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BloodGroup</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BloodGroup O = <span class="keyword">new</span> BloodGroup(<span class="number">0</span>);</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BloodGroup A = <span class="keyword">new</span> BloodGroup(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BloodGroup B = <span class="keyword">new</span> BloodGroup(<span class="number">2</span>);</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BloodGroup AB = <span class="keyword">new</span> BloodGroup(<span class="number">3</span>);</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BloodGroup[] _values = &#123;O, A, B, AB&#125;;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> _code;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="title">BloodGroup</span> <span class="params">(<span class="keyword">int</span> code )</span> </span>&#123;</span><br><span class="line">     _code = code;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> _code;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BloodGroup <span class="title">code</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> _values[arg];</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>type code是什么？</strong></p>
<p>表示一系列实体的类型常量值集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> O = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> B = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AB = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p><strong>不影响class的行为是什么意思？</strong></p>
<p>type code只是纯粹数据<br>表示class不会因为type code的不同而执行不同的方法，表现不同的行为（比较常见的是type code会在switch语句中引起行为变化时）。</p>
<p><strong>重构原因？</strong></p>
<ol>
<li>以type code为参数的函数实际上，只是接受一个int类型的数据，大大的降低代码的可读性。</li>
<li>常量无法进行类型检查，无法避免输入错误带来的影响。</li>
</ol>
<h2 id="Replace-Type-Code-with-Subclasses（以子类取代型别码）"><a href="#Replace-Type-Code-with-Subclasses（以子类取代型别码）" class="headerlink" title="Replace Type Code with Subclasses（以子类取代型别码）"></a>Replace Type Code with Subclasses（以子类取代型别码）</h2><p>problem:你有一个不可变的（immutable）type code,它会影响class的行为。<br>solution:以一个subclass 取代这个type code。</p>
<p><img src="/2019/01/11/refactoring/08 数据重构/8.gif" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是一个使用Replace Type Code with Class重构过的类，其实没有必要重构</span></span><br><span class="line"><span class="keyword">enum</span> EmployeeTypeEnum&#123;</span><br><span class="line">  ENGINEER(<span class="number">0</span>),SALESMAN(<span class="number">1</span>),MANAGER(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">private</span> _type;</span><br><span class="line">  EmployeeType (<span class="keyword">int</span> type) &#123;</span><br><span class="line">      _type = type;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">  EmployeeTypeEnum employeeType;</span><br><span class="line">  Employee(EmployeeTypeEnum e)&#123;</span><br><span class="line">    employeeType = e;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">EmployeeTypeEnum <span class="title">getType</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> employeeType;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(EmployeeTypeEnum type)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">switch</span> (employeeType) &#123;</span><br><span class="line">           <span class="keyword">case</span> EmployeeTypeEnum.ENGINEER:</span><br><span class="line">              doSomething1();</span><br><span class="line">           <span class="keyword">case</span> EmployeeTypeEnum.SALESMAN:</span><br><span class="line">              doSomething2();</span><br><span class="line">           <span class="keyword">case</span> EmployeeTypeEnum.MANAGER:</span><br><span class="line">              doSomething3();</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Incorrect type code value"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//很多处会用到switch语句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//======================after refactoring=========================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engineer</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">       ...;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function">EmployeeTypeEnum <span class="title">getType</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> EmployeeType.ENGINEER;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Salesman</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">       ...;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function">EmployeeTypeEnum <span class="title">getType</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> EmployeeType.SALESMAN;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       ...;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function">EmployeeTypeEnum <span class="title">getType</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> EmployeeType.MANAGER;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//静态工厂方法</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Employee <span class="title">create</span><span class="params">(EmployeeTypeEnum type)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">           <span class="keyword">case</span> EmployeeTypeEnum.ENGINEER:</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> Engineer();</span><br><span class="line">           <span class="keyword">case</span> EmployeeTypeEnum.SALESMAN:</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> Salesman();</span><br><span class="line">           <span class="keyword">case</span> EmployeeTypeEnum.MANAGER:</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> Manager();</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Incorrect type code value"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里只有一处用到switch语句，并且只用于决定创建何种对象，这样的switch语句是可以接受的。</p>
</blockquote>
<p><strong>重构原因？</strong></p>
<ol>
<li>每一个方法，都需要根据类型来表现不同的行为，会导致代码中具有很多的switch语句</li>
<li>不符合开闭原则，如果需要增加一个type code，就需要在每一个方法的switch中都增加响应的逻辑，这样的工作也是十分头疼的。</li>
</ol>
<h1 id="Replace-Type-Code-with-State-Strategy（以State-strategy-取代型别码）"><a href="#Replace-Type-Code-with-State-Strategy（以State-strategy-取代型别码）" class="headerlink" title="Replace Type Code with State/Strategy（以State/strategy 取代型别码）"></a>Replace Type Code with State/Strategy（以State/strategy 取代型别码）</h1><p>problem:你有一个type code，它会影响class的行为，但你无法使用subclassing。<br>solution:以state object（专门用来描述状态的对象）取代type code 。</p>
<p><img src="/2019/01/11/refactoring/08 数据重构/9.gif" alt=""></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是一个使用Replace Type Code with Class重构过的类，其实没有必要重构</span></span><br><span class="line"><span class="keyword">enum</span> EmployeeTypeEnum&#123;</span><br><span class="line">  ENGINEER(<span class="number">0</span>),SALESMAN(<span class="number">1</span>),MANAGER(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">private</span> _type;</span><br><span class="line">  EmployeeType (<span class="keyword">int</span> type) &#123;</span><br><span class="line">      _type = type;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">  EmployeeTypeEnum employeeType;</span><br><span class="line">  Employee(EmployeeTypeEnum e)&#123;</span><br><span class="line">    employeeType = e;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">EmployeeTypeEnum <span class="title">getType</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> employeeType;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(EmployeeTypeEnum type)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">switch</span> (employeeType) &#123;</span><br><span class="line">           <span class="keyword">case</span> EmployeeTypeEnum.ENGINEER:</span><br><span class="line">              doSomething1();</span><br><span class="line">           <span class="keyword">case</span> EmployeeTypeEnum.SALESMAN:</span><br><span class="line">              doSomething2();</span><br><span class="line">           <span class="keyword">case</span> EmployeeTypeEnum.MANAGER:</span><br><span class="line">              doSomething3();</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Incorrect type code value"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//很多处会用到switch语句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//======================after refactoring=========================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeType</span></span>&#123;</span><br><span class="line">   <span class="comment">//静态工厂方法</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> EmployeeType <span class="title">create</span><span class="params">(EmployeeTypeEnum type)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">           <span class="keyword">case</span> EmployeeTypeEnum.ENGINEER:</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> Engineer();</span><br><span class="line">           <span class="keyword">case</span> EmployeeTypeEnum.SALESMAN:</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> Salesman();</span><br><span class="line">           <span class="keyword">case</span> EmployeeTypeEnum.MANAGER:</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> Manager();</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Incorrect type code value"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">       ...;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getTypeCode</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="comment">//..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engineer</span> <span class="keyword">extends</span> <span class="title">EmployeeType</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">       ...;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function">EmployeeTypeEnum <span class="title">getTypeCode</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> EmployeeTypeEnum.ENGINEER;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Salesman</span> <span class="keyword">extends</span> <span class="title">EmployeeType</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">       ...;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function">EmployeeTypeEnum <span class="title">getTypeCode</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> EmployeeTypeEnum.MANAGER;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">EmployeeType</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       ...;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function">EmployeeTypeEnum <span class="title">getTypeCode</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> EmployeeTypeEnum.SALESMAN;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  EmployeeType employee;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setType</span><span class="params">(EmployeeTypeEnum e)</span> </span>&#123;</span><br><span class="line">       employee = EmployeeType.create(e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">    employee.doSomething();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Replace Type Code with Subclasses和Replace Type Code with State/Strategy重构后，很自然的会使用Replace Conditional with Polymorphism进行重构，上面都是使用Replace Conditional with Polymorphism重构后的结果</p>
</blockquote>
<p><strong>重构原因？</strong></p>
<p>无法使用Replace Type Code with Subclasses：</p>
<ol>
<li>原类已经具有其他子类。</li>
<li>type code可能在运行的过程中变化（一个不变对象所属类型发生变化），使用子类很难做到这一点。原因是使用Replace Type Code with Subclasses，每一个对象都是一个类型，两者是一体的关系，无法分离开。而Replace Type Code with State/Strategy，对象是对象，类型是类型，分离后就可以实时改变类型。</li>
</ol>
<h2 id="Replace-Subclass-with-Fields（以值域取代子类）"><a href="#Replace-Subclass-with-Fields（以值域取代子类）" class="headerlink" title="Replace Subclass with Fields（以值域取代子类）"></a>Replace Subclass with Fields（以值域取代子类）</h2><p>你的各个subclasses 的惟一差别只在「返回常量数据」的函数身上。<br>修改这些函数，使它们返回superclass 中的某个（新增）值域，然后销毁subclasses 。</p>
<p><img src="/2019/01/11/refactoring/08 数据重构/6.gif" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isMale</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">char</span> <span class="title">getCode</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Male</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isMale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'M'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Female</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isMale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'F'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//======================after refactoring=========================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> _isMale;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> _code;</span><br><span class="line"></span><br><span class="line">    Person(<span class="keyword">boolean</span> isMale, <span class="keyword">char</span> code) &#123;</span><br><span class="line">        _isMale = isMale;</span><br><span class="line">        _code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Person <span class="title">createMale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Male(<span class="keyword">true</span>, <span class="string">'M'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Person <span class="title">createFemale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Female(<span class="keyword">false</span>, <span class="string">'F'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isMale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _isMale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>重构原因？</strong></p>
<p>子类没有什么额外的新特性，也没有明显的变化行为。只有一个返回常量的变化行为，这个常量的用途是：不同的子类会返回不同的常量。<br>除此之外，子类实在没有足够的存在价值</p>
]]></content>
      <categories>
        <category>重构 学习笔记</category>
      </categories>
      <tags>
        <tag>重构</tag>
        <tag>数据重构</tag>
      </tags>
  </entry>
  <entry>
    <title>03 机器级别的表示</title>
    <url>/2019/05/07/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/03%20%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E5%88%AB%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="机器级别的表示"><a href="#机器级别的表示" class="headerlink" title="机器级别的表示"></a>机器级别的表示</h1><h2 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h2><ul>
<li>第一步：C<strong>预处理器</strong>扩展源代码，插入所有用#include引入的文件，并扩展所有用#define声明的宏。</li>
<li>第二步：<strong>编译器</strong> 产生源文件的汇编代码，以.s结尾。</li>
<li>第三步：<strong>汇编器</strong> 将汇编代码转成二进制目标代码文件，以.o结尾，此时还没填入全局值的地址。</li>
<li>第四步：<strong>链接器</strong> 将目标代码文件与库文件函数的代码合并，最终产生可执行文件，以.p结尾。</li>
</ul>
<h3 id="机器级代码"><a href="#机器级代码" class="headerlink" title="机器级代码"></a>机器级代码</h3><p>对于机器级编程，有两种抽象：</p>
<ol>
<li><strong>指令集体系结构或指令集架构(ISA)</strong>：定义了处理器状态，指令的格式，以及每条指令对状态的影响。指令宏观上按顺序执行，微观上并发的执行。</li>
<li>内存地址使用虚拟地址</li>
</ol>
<p>指令集体系结构的一些概念：</p>
<ul>
<li><strong>程序计算器</strong>：给出将要执行的下一条指令的内存地址。</li>
<li><strong>整数寄存器文件</strong>：可以存储地址或者整数数据。有的用来记录程序状态，其它的用来保存临时数据，譬如过程的参数和局部变量，以及函数的返回值。</li>
<li><strong>条件码寄存器</strong>：保存最近执行的算术或者逻辑指令的状态信息。</li>
<li><strong>向量寄存器</strong>：存放一个或者多个整数或者浮点数。</li>
</ul>
<p>程序的执行都离不开这些寄存器的使用，后面会了解其作用。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>C语言代码文件mstore.c如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long mult2(long,long);</span><br><span class="line">void multstore(long x,long y,long *dest)&#123;</span><br><span class="line">  long t = mult2(x,y);</span><br><span class="line">  * dest = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>命令行运行：linux&gt; gcc -Og -S mstore.c 生成.s文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">multstore:</span><br><span class="line">pushq %rbx</span><br><span class="line">movq %rdx,%rbx</span><br><span class="line">call mult2</span><br><span class="line">movq %rax,(%rbx)</span><br><span class="line">popq %rbx</span><br><span class="line">ret</span><br></pre></td></tr></table></figure></p>
<p>命令行运行：linux&gt; gcc -Og -c mstore.c 生成.o文件。他是二进制的，无法阅读。1368字节的文件mstore.o中有一段14字节的文件，如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3</span><br></pre></td></tr></table></figure></p>
<p>机器对产生指令的源代码一无所知。</p>
<blockquote>
<p>-Og 是一种符合C代码整体结构的代码优化级别，采用更高的代码优化级别会使机器代码和源码之间的关系非常难以理解，因此我们采用-Og来进行学习。</p>
</blockquote>
<p>反编译时，命令行运行linux&gt; objdumo -d mstore.o即可生成对应的汇编文件。</p>
<h3 id="关于格式的注解"><a href="#关于格式的注解" class="headerlink" title="关于格式的注解"></a>关于格式的注解</h3><p>执行该 linux&gt; gcc -Og -S mstore.c 命令行时，会包含很多其他的无关信息，我们省略掉这些信息，并给我们需要的信息加上固定格式的注解。</p>
<h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><p>8位是一个字节，16位称为 <strong>字</strong> .因此，32位数称为“双字”，64位数称为“四字”，下入给出了C语言对应的x86-64表示。</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/C语言数据类型在intel中的大小.png" alt="计算机系统原理：第三章-程序的机器级别表示"></p>
<h2 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h2><p>CPU中包含16个存储64位值的通用目的寄存器。</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/整数寄存器.png" alt="计算机系统原理：第三章-程序的机器级别表示"></p>
<blockquote>
<p>指令可以对每个寄存器的低位部分中存放的不同大小的数据进行操作。对于生成小于8字节的指令，寄存器中剩下的字节会有两条处理规则：</p>
<ol>
<li>生成1字节或者2字节时，剩下的字节保持不变。</li>
<li>生成4字节时，高位的4个字节被设置为0。</li>
</ol>
</blockquote>
<h3 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h3><p>大多数指令有一个或者多个<strong>操作数</strong>，指示出一个操作中要用到的源数据值，以及放置结果的目的位置。有如下三种类型。</p>
<ol>
<li><strong>立即数（inmediate）</strong>：表示常数值。书写方式是”$”后面跟一个值，只作为源操作数。</li>
<li><strong>寄存器(register)</strong>：表示某个寄存器的内容。书写方式是r_a表示任意寄存器a。用R[r_a]表示寄存器里的值。</li>
<li><strong>内存引用(memmery)</strong>：根据计算出来的地址访问某个内存位置。</li>
</ol>
<p>内存地址的计算方式是imm(r_a,r_i,s)</p>
<ul>
<li>imm：地址偏移量</li>
<li>r_a：基址寄存器</li>
<li>r_i：变址寄存器</li>
<li>s：比例<br>计算公式：imm+R[r_a]+R[r_i]*s</li>
</ul>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/操作数格式.png" alt="计算机系统原理：第三章-程序的机器级别表示"></p>
<blockquote>
<p>上述操作数值M后都省略了下标b，表示对开始地址后的b个字节值的引用。还要注意地址是64位的。</p>
</blockquote>
<p>M表示数据必然是在内存中</p>
<h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p>指令是将源操作数的值，存放到目的操作数中。<br>这里的值可以是数据，也可以是地址。<br>具体是什么根据指令来判断。<br>一般都是地址对应数据，也有些奇葩存在，比如leap，由此也导致leap和指针有着密切的联系。</p>
<p>最简单形式的数据传送指令——MOV类，这些指令把源数据复制到目标位置，不做任何变化。</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/简单的数据传送指令.png" alt="计算机系统原理：第三章-程序的机器级别表示"></p>
<p>x86-64中规定，源操作数和目的操作数不能同时为一个内存地址。因此内存到内存需要两个指令。</p>
<blockquote>
<p>movq和movabsq的区别是：movq的源数据是32位补码，然后扩展得到的64位值。movabsq的数据是任意的64位立即数。</p>
</blockquote>
<p>根据之前提过的寄存器剩下字节处理规则，对于movl指令，会把高4位字节设置为0:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movabsq $0011223344556677 %rax %rax=0011223344556677</span><br><span class="line">movb -1,%rax %rax=00112233445566FF</span><br><span class="line">movw -1,%rax %rax=001122334455FFFF</span><br><span class="line">movl -1,%rax %rax=00000000FFFFFFFF</span><br><span class="line">movq -1,%rax %rax=FFFFFFFFFFFFFFFF</span><br></pre></td></tr></table></figure></p>
<p>当把较小的数值复制到较大的目的时，使用MOVZ和MOVS指令：</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/零扩展数据传送指令.png" alt="计算机系统原理：第三章-程序的机器级别表示"><br><img src="/2019/05/07/系统原理/03 程序的机器级别表示/符号扩展数据传送指令.png" alt="计算机系统原理：第三章-程序的机器级别表示"></p>
<p>不一样的是，MOVZ在高位作零扩展，MOVS作符号扩展，案例如下：</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/1.png" alt="计算机系统原理：第三章-程序的机器级别表示"></p>
<h3 id="数据传送示例"><a href="#数据传送示例" class="headerlink" title="数据传送示例"></a>数据传送示例</h3><p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/数据传送示例.png" alt="计算机系统原理：第三章-程序的机器级别表示"></p>
<p>我们可以看到：</p>
<ol>
<li>所谓指针，其实就是地址。</li>
<li>局部变量通常保存在寄存器中，而不是内存中。访问寄存器比访问内存要快很多。</li>
</ol>
<h3 id="圧入和弹出栈数据"><a href="#圧入和弹出栈数据" class="headerlink" title="圧入和弹出栈数据"></a>圧入和弹出栈数据</h3><p><strong>什么是内存栈？</strong></p>
<p>内存栈是一种存储结构<br>栈指针是一个寄存器(%rsp)，保存着指向栈顶的地址。</p>
<p>入栈和出栈的指令如下：</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/3.png" alt="计算机系统原理：第三章-程序的机器级别表示"></p>
<p>在内存的操作对应如下：</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/2.png" alt="计算机系统原理：第三章-程序的机器级别表示"></p>
<p>pushq的指令也可以使用subq+movq来代替，区别是前者只需要1个字节，后者需要8个字节。</p>
<h2 id="算术和逻辑指令"><a href="#算术和逻辑指令" class="headerlink" title="算术和逻辑指令"></a>算术和逻辑指令</h2><p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/4.png" alt="计算机系统原理：第三章-程序的机器级别表示"></p>
<p>除了leaq之外，每个指令类都有4种不同大小的指令（1,2,4,8位）</p>
<h3 id="加载有效地址指令leaq"><a href="#加载有效地址指令leaq" class="headerlink" title="加载有效地址指令leaq"></a>加载有效地址指令leaq</h3><p>leaq是movq的变种，与movq不同的是，leaq不是存储源操作数的值，而是存储它的地址。</p>
<ul>
<li>movq (%rdi),%rax 值将%rdi寄存器中的地址的值存放到%rax寄存器中</li>
<li>leaq (%rdi),%rax 是将%rdi寄存器中的地址存放到%rax寄存器中</li>
</ul>
<p>leaq指令就类似c中的指针</p>
<h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>从图中可以看到，除了位移指令，大部分的指令既可用于无符号运算，也可用于补码运算。这个特性也导致使用补码作为有符号整数参与运算.<br>区分有符号无符号是通过指令来判断的，指令值针对有符号的操作就表示数据有符号，指令值针对无符号的操作就表示数据有无符号。</p>
<h3 id="特殊的算术操作"><a href="#特殊的算术操作" class="headerlink" title="特殊的算术操作"></a>特殊的算术操作</h3><p>下面的这些指令支持两个64位的指令相乘得到128位的结果</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/5.png" alt="计算机系统原理：第三章-程序的机器级别表示"></p>
<p>要求%rax寄存器（这其实就是一个累加器）中存在一个值<br>imulq这个指令可以用于两个不同的操作，汇编器能够通过计算操作数的数目来分辨。</p>
<p>案例：</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/6.png" alt="特殊算术操作案例"><br><img src="/2019/05/07/系统原理/03 程序的机器级别表示/7.png" alt="特殊算术操作案例"></p>
<p>高位字节存储在大地址</p>
<p><strong>如果我们不想按照指令顺序一步一步执行？</strong></p>
<h2 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h2><p>使用jump指令可以改变指令的执行顺序<br>条件，循环，分支。</p>
<h3 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h3><p>除了整数寄存器，CPU还维护着一组<strong>单个位</strong>条件码寄存器，描述了最近的算术或逻辑操作属性。<br>常用的条件码有：</p>
<ul>
<li>CF：进位标志，最近的操作是否使最高位产生进位，可用来检查无符号操作的溢出。</li>
<li>ZF：零标志，最近的操作计算的结果为零</li>
<li>SF：符号标志，最近的操作结果为负</li>
<li>OF：溢出标志，最近的操作导致补码溢出</li>
</ul>
<p>如有一个表达式t=a+b，条件码会根据这个表达式设置值如下：</p>
<ul>
<li>CF：（unsigned）t &lt; (unsignded) a</li>
<li>ZF：（t==0）</li>
<li>SF：（t&lt;0）</li>
<li>OF:(a&lt;0 == b&lt;0)&amp;&amp;(t&lt;0 != a&lt;0)<blockquote>
<p>leap指令不会改变条件码</p>
</blockquote>
</li>
</ul>
<p>有些指令不会改变寄存器的值，而是简单的改变条件码寄存器。<br>cmp类似sub，test类似and</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/10.png" alt="只改变条件码寄存器的指令"></p>
<h3 id="访问条件码"><a href="#访问条件码" class="headerlink" title="访问条件码"></a>访问条件码</h3><p><strong>条件码有什么用呢？</strong></p>
<p>用作<em>条件</em></p>
<p><strong>条件码如何使用呢？</strong></p>
<p>一般并不直接访问单个条件码寄存器</p>
<ol>
<li>可以通过条件码寄存器的组合结果来将一个字节设置为0或者1。</li>
<li>可以通过条件码寄存器的组合结果来跳转到其它地方</li>
<li>可以通过条件码寄存器的组合结果来传输数据</li>
</ol>
<p>常用的指令组合（大于小于等于）有：</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/11.png" alt="常用的SET指令"></p>
<h3 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h3><p>jump是直接跳转，其它的是结合条件码的组合来跳转。</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/12.png" alt="跳转指令"></p>
<p>jump也有分为两种：</p>
<ul>
<li>直接跳转：目的地是指令编码中指定的地点，如jmp .L1</li>
<li>间接跳转：目的地是寄存器或内存地址，如jmp *%rax，*(%rax)</li>
</ul>
<h3 id="跳转指令的编码"><a href="#跳转指令的编码" class="headerlink" title="跳转指令的编码"></a>跳转指令的编码</h3><p><strong>对于“目的地”如何机器编码？</strong></p>
<ol>
<li>PV相对寻址：以下一地址的偏移量（负表示到之前）所得作为目的地</li>
<li>绝对寻址：直接给出跳转的目的地址</li>
</ol>
<p>案例：<br><img src="/2019/05/07/系统原理/03 程序的机器级别表示/13.png" alt="跳转目标的机器表示"></p>
<h3 id="实现条件分支"><a href="#实现条件分支" class="headerlink" title="实现条件分支"></a>实现条件分支</h3><p><strong>如何实现条件分支？</strong></p>
<ol>
<li>条件跳转</li>
</ol>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/14.png" alt="条件跳转实现条件分支"></p>
<ol start="2">
<li>条件传送（条件赋值）</li>
</ol>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/15.png" alt="条件赋值实现条件分支"></p>
<p><strong>两种方式有何区别？</strong></p>
<ul>
<li><p>在分支比较简单时，使用条件赋值较好：<br>一条指令的处理要经过一系列阶段（从内存取指令、确定指令类型、从内存取数据、执行算术运算、从内存写数据、更新程序计数器）<br>处理器通过使用 <em>流水线（pipelining）</em> 来提高性能<br>大概就是通过同时执行指令的不同阶段<br>这要求指令是顺序的，因此当遇到分支（条件跳转）时，要么选择等待，要么采用非常精密的分支预测逻辑来预测执行<br>这就意味着要承担错误预测的风险（消耗）</p>
<p>x84_64可用的条件赋值指令有：</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/16.png" alt="条件赋值指令"></p>
</li>
<li><p>在分支比较复杂时，使用条件跳转较好：<br>在条件赋值的处理下，无论最后走哪一条分支，两条分支的逻辑都会被执行<br>这就会出现：</p>
<ol>
<li>如果有一条分支需要大量的计算，当条件不满足时，那就相当于做了无用功。</li>
<li>可能在一条分支上出现了错误（技师在条件永不满足），也会被执行报错</li>
</ol>
</li>
</ul>
<h3 id="实现循环"><a href="#实现循环" class="headerlink" title="实现循环"></a>实现循环</h3><p><strong>如何实现循环分支？</strong></p>
<p>使用条件码（比较、测试）和条件跳转可以实现循环，如下：</p>
<ol>
<li><p>do-while</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/17.png" alt="do-while"></p>
</li>
<li><p>while<br>有两种</p>
<ol>
<li>jump to middle</li>
</ol>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/18.png" alt="jump to middle"></p>
<ol start="2">
<li>jguarded-do</li>
</ol>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/19.png" alt="guarded-do"></p>
</li>
<li><p>for<br>for语句可以转换为while语句来实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(init-expr;test-expr;update-expr)</span><br><span class="line">  body-statement</span><br><span class="line">===========================</span><br><span class="line">init-expr;</span><br><span class="line">while(test-expr)&#123;</span><br><span class="line">    body-statement</span><br><span class="line">    update-expr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p><strong>如何实现switch分支？</strong></p>
<p>同样是使用条件（无条件）跳转来实现的<br>跳转的地址用一个数组保存（&amp;表示指向数据值的地址，&amp;&amp;表示指向标记代码位置的地址）<br>数组索引是分支的开关，通过计算得到</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/20.png" alt="switch"></p>
<p>对应的汇编代码如下：</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/21.png" alt="switch汇编"></p>
<p>jmp *.L4(,%rsi,8)<br>表示一个间接跳转，地址为 8 * R[%rsi] + .L4</p>
<p>跳转表数组对应的内存：</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/22.png" alt="跳转表"></p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p><strong>什么是过程？</strong></p>
<p>指令集合<br>可被调用<br>函数、方法、子例程、处理函数等等</p>
<p><strong>一个过程涉及到哪些步骤？</strong></p>
<p>假设过程P调用过程Q，过程Q执行后返回到P。<br>这个动作包括下面的一个或多个机制：</p>
<ol>
<li>传递控制：程序计数器必须设置为Q代码的起始地址，然后在返回时，要把程序计数器指向调用Q的下一行指令地址。</li>
<li>传递数据：P可以向Q提供参数，Q可以向P返回结果值</li>
<li>分配和释放额内存：Q需要为局部变量分配空间，返回后又需要释放这些空间</li>
</ol>
<p>接来下一一说明这些机制如何实现;</p>
<h3 id="运行时栈"><a href="#运行时栈" class="headerlink" title="运行时栈"></a>运行时栈</h3><p>大多数语言都使用一种内存结构——栈帧——来控制过程</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/23.png" alt="栈帧"></p>
<h3 id="传递控制"><a href="#传递控制" class="headerlink" title="传递控制"></a>传递控制</h3><p><strong>传递控制如何实现？</strong></p>
<p>使用call和ret指令实现传递控制<br>call Q调用过程Q，同时把返回地址A压入栈</p>
<blockquote>
<p>callq和retq表明是x86-64版本</p>
</blockquote>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/24.png" alt="call和ret"></p>
<p><strong>具体是如何退出？</strong></p>
<p>当过程需要退出时，会释放当前的内存<br>这时候栈帧会指向返回地址A<br>ret会取出该地址，并将程序计数器（%rpi）修改为该地址</p>
<p>案例：</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/25.png" alt="过程案例"></p>
<p>下图是这个案例中call和ret对栈的操作栈过程：</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/26.png" alt="call和ret的操作栈过程"></p>
<p>%rip：程序计数器（寄存器）<br>%rsp：栈顶指针（寄存器）</p>
<h3 id="传递数据"><a href="#传递数据" class="headerlink" title="传递数据"></a>传递数据</h3><p><strong>传递数据如何实现？</strong></p>
<p>大部分过程间数据传递都是通过寄存器实现的<br>有6个寄存器被用来参数传递，寄存器使用的按照参数的顺序，寄存器的名字取决于要传递的数据类型的大小<br>用%rax来返回结果值</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/27.png" alt="用来传参的寄存器"></p>
<p><strong>多于6个参数怎么办？</strong></p>
<p>多于6个的参数会被放到栈帧中，通过帧指针（存放在%rbp中）调用来使用<br>每个参数都占用8个字节</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/28.png" alt="用来传参的栈帧"></p>
<p><strong>这些参数在被调用的过程中如何使用？</strong></p>
<ol>
<li>寄存器中的参数：直接使用寄存器</li>
<li>存放在栈帧中的参数：通过上一过程最后一帧的地址（帧指针）来访问</li>
</ol>
<h3 id="分配和释放栈帧内存"><a href="#分配和释放栈帧内存" class="headerlink" title="分配和释放栈帧内存"></a>分配和释放栈帧内存</h3><p>之前说过，寄存器是可以用来存放过程中的局部数据<br>那么，<strong>在什么时候需要用栈帧来存储参数和局部数据？</strong></p>
<p>寄存器不够用，常见的情况有：</p>
<ol>
<li>本地数据太多</li>
<li>对局部变量使用了地址运算符‘&amp;’（意味着必须存放到内存地址中）</li>
<li>使用了数组或者结构体（这些连续的空间必须在内存上才能实现）</li>
</ol>
<p><strong>多的局部数据如何保存在栈帧中？</strong></p>
<p>这也可以通过分配栈帧和释放栈帧空间来实现：</p>
<ol>
<li>进入一个新的过程，分配内存空间</li>
<li>局部意味着只在当前过程中有效，因此离开的时候需要释放这部分空间</li>
</ol>
<p>案例：</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/29.png" alt="分配和释放栈帧内存"></p>
<h3 id="寄存器中的局部数据"><a href="#寄存器中的局部数据" class="headerlink" title="寄存器中的局部数据"></a>寄存器中的局部数据</h3><p>存放在过程栈帧中的局部数据是当前过程一直有效的</p>
<p>但是寄存器是所有过程共享的，这意味着在过程调用中，寄存器中的值可能会被改变，那么，<strong>如何确保存当前过程寄存器中的局部数据是一致的？</strong></p>
<ol>
<li>分析有哪些寄存器数据是在调用其他过程后会被修改的</li>
<li>把这些寄存器数据存起来</li>
<li>调用其他过程返回后恢复数据</li>
</ol>
<p><strong>如何保存这些寄存器？</strong></p>
<p>x86-64采用了一组统一的寄存器使用惯例（%rbx、%rbp、%r12~%r15）：<br><em>被调用者保存寄存器</em>：被调用者在开始前必须保存这些寄存器（会发生变化的）中的数据，以返回时恢复这些数据<br>把之前谈到的变化数据存放到<em>被调用者保存寄存器</em>中即可<br>保存的方式是在分配栈空间就先把这些数据压入栈中，释放空间后再弹出。</p>
<p>案例：<br><img src="/2019/05/07/系统原理/03 程序的机器级别表示/30.png" alt="被调用者保存寄存器"></p>
<p><strong>当被调用者保存寄存器不够用了怎么办？</strong></p>
<h3 id="递归过程"><a href="#递归过程" class="headerlink" title="递归过程"></a>递归过程</h3><p>栈规则提供了一种机制，每次函数调用都有它自己私有的状态信息。<br>调用本身和调用其他函数是一样的</p>
<p>案例：<br><img src="/2019/05/07/系统原理/03 程序的机器级别表示/31.png" alt="递归过程"></p>
<h2 id="数组分配和访问"><a href="#数组分配和访问" class="headerlink" title="数组分配和访问"></a>数组分配和访问</h2><p><strong>数组是如何存储的？</strong></p>
<p>C语言：<br>数组是内存上的连续空间<br>标志符作为指向数组的开头指针</p>
<p><strong>如何使用指令来访问数组？</strong></p>
<p>假设是int型数组(4字节)<br>将开头指针存放在寄存器%rdx中<br>索引存放在寄存器%rcx中<br>可以使用<movl (%rdx,%rcx,4),%eax="">来访问</movl></p>
<h3 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h3><p>C语言允许指针运算：<br>p+i = p的地址 + i * p的数据类型大小</p>
<h3 id="数组嵌套"><a href="#数组嵌套" class="headerlink" title="数组嵌套"></a>数组嵌套</h3><p><strong>二维数组、三维数组如何表示？</strong></p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/32.png" alt="数组嵌套"></p>
<p>T D[R][C];<br>计算公式：&amp;D[i][j] = D + L(C * i + j);</p>
<p>L是数据类型的大小(字节)</p>
<h3 id="定长数组和变长数组"><a href="#定长数组和变长数组" class="headerlink" title="定长数组和变长数组"></a>定长数组和变长数组</h3><p><strong>什么是定长和变长？</strong></p>
<p>定和变是相对编译前后而言的</p>
<p>定长：数组的长度编译之后是固定的<br>变长：数组的长度编译之后   可能会不同</p>
<p>变长数组性能上会大打折扣，<strong>为什么？</strong></p>
<ol>
<li>需要额外的寄存器来存放数组长度参数</li>
<li>在计算C*i的时候必须使用乘法指令，而不能使用leaq指令来实现，乘法指令会有性能处罚。</li>
</ol>
<h2 id="异质的数据结构"><a href="#异质的数据结构" class="headerlink" title="异质的数据结构"></a>异质的数据结构</h2><p>C语言提供给了两种把不同的数据类型组合到一起创建新的数据类型的机制：结构和联合</p>
<blockquote>
<p>机器代码不包含关于字段声明和字段名字的信息，这些都在编译时期被处理。</p>
</blockquote>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>和数组一样，结构体是内存上一段连续的空间。</p>
<p>案例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct rec&#123;</span><br><span class="line">  int i;</span><br><span class="line">  int j;</span><br><span class="line">  int a[2];</span><br><span class="line">  int *p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/33.png" alt="结构体"></p>
<h3 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h3><p><strong>为什么需要数据对齐？</strong></p>
<p>CPU为了提高读写效率，一般都是一次读写多个字节，如8字节<br>如果能确保一个数据能在一次内存读写中获取，是提高性能的一个方式</p>
<p><strong>如何保证？</strong></p>
<p>确保K字节的数据类型地址（偏移）是K的倍数<br>如：<br>1字节的char地址（偏移）是1的倍数<br>2字节的short地址（偏移）是2的倍数<br>4字节的int地址（偏移）是4的倍数<br>8字节的double地址（偏移）是8的倍数</p>
<p>因此在一个结构体中，如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct S1&#123;</span><br><span class="line">  char c;</span><br><span class="line">  int i;</span><br><span class="line">  char f;</span><br><span class="line">  double j;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>sizeof(S1) = 4 + 4 + 8 + 8 = 24  </p>
<blockquote>
<p>一般编译器会替我们选择适合目标平台的对齐策略</p>
</blockquote>
<p>.align 8 可以指定全部数据的对齐</p>
<h2 id="机器级程序中控制和数据的互动"><a href="#机器级程序中控制和数据的互动" class="headerlink" title="机器级程序中控制和数据的互动"></a>机器级程序中控制和数据的互动</h2><p>越底层的操作，越能看清数据和控制的互动<br>譬如C中<em>指针</em></p>
<h3 id="理解指针"><a href="#理解指针" class="headerlink" title="理解指针"></a>理解指针</h3><ol>
<li>每个指针都对应一个类型：<int \*ip=""><char \*\*cpp=""></char></int></li>
<li>每一个指针都有一个值：数据的地址</li>
<li>使用‘&amp;’获取数据的指针</li>
<li>使用‘*’使用指针</li>
<li>数组和指针关系密切：数组标志符就是指针</li>
<li>指针的强转只改变类型，不改变值</li>
<li>指针也可以指向函数<int (\*fp)(int,int\*)=""></int></li>
</ol>
<h3 id="内存越界和缓存区溢出"><a href="#内存越界和缓存区溢出" class="headerlink" title="内存越界和缓存区溢出"></a>内存越界和缓存区溢出</h3><p>对指针的操作不会有任何的边界检查，因此会操作一些溢出问题</p>
<p><strong>溢出会有什么影响？</strong></p>
<p>譬如数组，C中的gets(char[])就会有溢出问题<br>首先，数组是存储在栈上的<br>那么数组越界操作会直接导致修改了栈上的其他数据<br>更严重的影响是：修改栈中返回地址，指向一段被越界操作篡改了的攻击代码，也就是所谓的“病毒”和“蠕虫”</p>
<p><strong>如何预防？</strong></p>
<p>修改返回地址需要知道当前字符串存放的栈地址<br>这在以往的机器上都是固定的，因此可以模拟出攻击代码</p>
<p>由此一个预防的方法是<em>栈随机化</em><br>每次运行程序都有一个随机的栈地址<br>32位计算机栈随机范围是2^23<br>64位计算机栈随机范围是2^32</p>
<p>但是，与此同时，又有一个更暴力的攻击方式，对返回地址进个遍历修改<br>在实际的攻击代码之前插入一段‘nop指令’<br>这个指令的作用是：对程序计数器加一，没有其他的效果<br>这样，运用暴力方法，最终能执行到攻击代码</p>
<p>第二种预防方式解决了这个问题：<br>C中是无法防止对数组越界写的，但是可以检查出是否越界<br>在缓冲区之前存储一个特殊值（金丝雀值）<br>在离开过程前检查这个值，如果发现该值被修改<br>则程序异常终止</p>
<p>现在的C大部分都默认采用后者进行保护</p>
<p>第三种方案是区别对待内存上的区域：读、写和可执行<br>JAVA等语言采用的就是这种方式</p>
<h3 id="支持变长的帧栈"><a href="#支持变长的帧栈" class="headerlink" title="支持变长的帧栈"></a>支持变长的帧栈</h3><p><strong>如何理解变长的栈帧？</strong></p>
<p>大部分代码是在编译之后就能确定需要分配多少栈帧空间<br>但是也有特殊的情况<br>譬如alloca函数，可以在栈上分配任意字节的数量<br>又譬如变长数组</p>
<p><strong>如何实现变长数组的内存分配？</strong></p>
<p>使用subq分配栈帧空间时 无法使用立即数 ，而是需要通过参数计算出来。</p>
<h2 id="浮点代码"><a href="#浮点代码" class="headerlink" title="浮点代码"></a>浮点代码</h2><p>如何存储和访问浮点数？<br>浮点数作为参数和返回的规则？<br>对浮点数据操作的指令？<br>浮点数和整数之间的转换？<br>浮点数之间的转换？</p>
]]></content>
      <categories>
        <category>计算机系统原理</category>
      </categories>
      <tags>
        <tag>计算机系统原理</tag>
        <tag>机器级别的表示</tag>
      </tags>
  </entry>
  <entry>
    <title>IOC容器的实现</title>
    <url>/2020/05/12/Spring/IOC%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="IOC容器的实现"><a href="#IOC容器的实现" class="headerlink" title="IOC容器的实现"></a>IOC容器的实现</h1><h2 id="容器的设计"><a href="#容器的设计" class="headerlink" title="容器的设计"></a>容器的设计</h2><p><strong>什么是依赖反转？为什么需要依赖反转？</strong></p>
<p>依赖对象的获得被反转了</p>
<p>如果这个获取过程要靠自身实现，那么这将导致代码高度耦合并且难以维护和调试。</p>
<p><strong>什么是容器？什么是 BeanDefinition？他们是什么关系？</strong></p>
<p>IOC容器是实现依赖反转的载体</p>
<p>BeanDefinition 是对依赖反转模式中管理的对象依赖关系的数据抽象，也是容器实现依赖反转功能的核心数据结构，依赖反转功能都是围绕着这个 BeanDefinition 的处理来完成的。</p>
<p><strong>BeanDefinition和Bean的联系和区别？</strong></p>
<p>按照 BeanDefinition 规则，对 pojo 对象进行装配，管理，并赋予生命后得到的最终的对象才是Bean</p>
<p><strong>为什么要设计各种容器？</strong></p>
<p>BeanFactory 定义了容器最基本的功能（获取bean），同时，为了简化使用者的使用和开发，实现了各种不同功能的子容器，这些子容器能适用于各种不同的场景。</p>
<p><strong>容器的设计体系：</strong></p>
<p><img src="/2020/05/12/Spring/IOC容器的实现/image-20200513111401829.png" alt="image-20200513111401829"></p>
<ol>
<li><p>路线一：</p>
<ul>
<li>BeanFactory：定义了容器的基本功能（getBean）</li>
<li>HierarchivalBeanFactory：使容器具有继承管理（getParentBeanFactory）</li>
<li>ConfigurableBeanFactory：使容器具有可配置功能（setParentBeanFactory，addBeanPostProcessor）</li>
</ul>
</li>
<li><p>路线二：</p>
<ul>
<li><p>ListableBeanFactory：使容器具有枚举bean的功能，不然工厂中到底有多少bean无法得知（只能采用穷举法一个个的去尝试）</p>
</li>
<li><p>ApplicationContext：继承 HierarchivalBeanFactory 和 ListableBeanFactory，使其拥有容器的功能，同时扩展了很多的高级特性。</p>
</li>
</ul>
</li>
</ol>
<h2 id="容器的初始化"><a href="#容器的初始化" class="headerlink" title="容器的初始化"></a>容器的初始化</h2><p><strong>如何采用线路一使用容器？</strong></p>
<p>在Spring中，提供了 DefaultListableBeanFactory 类，这个类基本实现了容器所有的功能，因此委托这个类，就可以进行简单的容器开发使用。</p>
<p>除外我们还需要做的额外操作：将 BeanDefinition 注册到 DefaultListableBeanFactory 中（因为DefaultListableBeanFactory 实现了 BeanDefinitionRegistry 接口），这一步操作的意义是为了告诉DefaultListableBeanFactory 如何进行bean装配、管理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BeanDefinition 资源定位，使用 Resource 抽象，可以使用 ResourceLoader 进行 Resource 的定位</span></span><br><span class="line">ClassPathResource res = <span class="keyword">new</span> ClassPathResource(<span class="string">"beans.xml"</span>);</span><br><span class="line"><span class="comment">//委托</span></span><br><span class="line">DefaultListableBeanFactory factory = <span class="keyword">new</span> DefultListableBeanFactory();</span><br><span class="line"><span class="comment">//BeanDefinition 资源加载器定义，入参是一个 BeanDefinitionRegistry</span></span><br><span class="line">XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDeifinitionReader(factory);</span><br><span class="line"><span class="comment">//BeanDefinition 资源加载，使用回调将将 BeanDefinition 注册到 DefaultListableBeanFactory 中</span></span><br><span class="line">reader.loadBeanDefinition(res);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>  注意到我们这里为了使用 DefaultListableBeanFactory，其实是做了额外的三步：</p>
<ol>
<li>BeanDefinition 资源定位</li>
<li>BeanDefinition 资源加载</li>
<li>BeanDefinition 资源注册</li>
</ol>
</blockquote>
<p><strong>ApplicationContext扩展了哪些容器的高级特性？</strong></p>
<ul>
<li>MessageSource：支持国际化，为开发多语言的程序提供支持</li>
<li>ResourceLoader：支持 Resource 多方面获取</li>
<li>ApplicationContextPublisher：支持应用事件处理</li>
<li>BeanPostProcesser管理</li>
</ul>
<p><strong>如何采用线路二使用容器？</strong></p>
<p>spring 中 AbstractApplicationContext 为我们实现了这些扩展的高级特性的基本功能，但是为了使用它，我们还需要实现他的三个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ApplicationContext 采用委托其它容器来支持它自身的容器功能，并且完成对容器的增强</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//关闭委托容器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">closeBeanFactory</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//获取委托容器</span></span><br><span class="line"><span class="function">ConfigurableListableBeanFactory <span class="title">getBeanFactory</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>spring 中 AbstractRefreshableApplicationContext 继承了 AbstractApplicationContext 类，它使用DefaultListableBeanFactory 作为委托容器，为我们做了上面的工作，但为了使用AbstractRefreshableApplicationContext，我们还需要实现它的一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//之前说过，这里就是为了告诉DefaultListableBeanFactory如何进行bean装配、管理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>线路二案例：</strong></p>
<p>这里使用 AbstractRefreshableConfigApplicationContext 的一个子类 AbstractXmlApplicationContext 来说明：</p>
<ol>
<li><p>BeanDefinition 资源定位</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span></span>&#123;</span><br><span class="line">        <span class="comment">//BeanDefinition资源加载器定义，入参是一个BeanDefinitionRegistry，这里表明是一个XML</span></span><br><span class="line">        <span class="comment">//BeanDefinition资源可以是很多其他的形式</span></span><br><span class="line">        XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//配置beanDefinitionReader，关键是配置ResourceLoader</span></span><br><span class="line">        <span class="comment">//ResourceLoader的功能是可以定位BeanDefinition</span></span><br><span class="line">        beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">        beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">        beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加载BeanDefinition资源</span></span><br><span class="line">        initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">        loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * getConfigResources() 和 getConfigLocations() 用于定位资源</span></span><br><span class="line"><span class="comment">    * 后者在reader中需要调用loader对stringPath的进行定位</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> DefaultResourceLoader#getResourceByPath(String path)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span></span>&#123;</span><br><span class="line">        Resource[] configResources = getConfigResources();</span><br><span class="line">        <span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">            reader.(configResources);</span><br><span class="line">        &#125;</span><br><span class="line">        String[] configLocations = getConfigLocations();</span><br><span class="line">        <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">            reader.loadBeanDefinitions(configLocations);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>BeanDefinition载入</p>
<p><img src="/2020/05/12/Spring/IOC容器的实现/image-20200514181150727.png" alt="image-20200514181150727"></p>
<p><strong>哪个类主要用来实现BeanDefinition载入细节？里面主要的方法是什么？</strong></p>
<p>在 DefaultBeanDefinitionDocumentReader.processBeanDefinition 中解析 Document</p>
<p>委托 BeanDefinitionParserDelegate.parseBeanDefinitionElement 来实现载入</p>
<p><strong>BeanDefinitionParserDelegate 的作用是什么？</strong></p>
<p>实现 BeanDefinition 嵌套载入</p>
</li>
<li><p>BeanDefinition注册</p>
<p>解析完成后回调 BeanDefinitionRegistry.registerBeanDefinition() 进行注册（DefaultListableBeanFactory 实现了BeanDefinitionRegistry）</p>
<p><img src="/2020/05/12/Spring/IOC容器的实现/image-20200514183640908.png" alt="image-20200514183640908"></p>
</li>
</ol>
<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p><strong>依赖注入发生的时机？</strong></p>
<p>发生在第一次向容器索要 Bean 的时候，也就是调用 getBean 的时候</p>
<p>AbstractBeanFactory 实现了 getBean 的功能，因此下面着重分析 AbstractBeanFactory</p>
<p><strong>AbstractBeanFactory源码分析：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">doGetBean(...)&#123;</span><br><span class="line">	<span class="comment">//先从单例缓存中获取	</span></span><br><span class="line">    Object sharedInstance = getSingleton(beanName);</span><br><span class="line">	<span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//处理FactoryBean</span></span><br><span class="line">		bean = getObjectForBeanInstance(...);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//如果拿不到BeanDefinition，则从父容器中找</span></span><br><span class="line">        BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName))&#123;</span><br><span class="line">            <span class="comment">//从父容器中获取</span></span><br><span class="line">            parentBeanFactory.getBean(...);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//获取BeanDefinition</span></span><br><span class="line">        RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">		checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取依赖的bean，触发递归</span></span><br><span class="line">        String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">        <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String dep : dependsOn)&#123;</span><br><span class="line">                registerDependentBean(dep, beanName);</span><br><span class="line">                getBean(dep);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">		<span class="keyword">if</span> (mbd.isSingleton())&#123;</span><br><span class="line">            <span class="comment">//创建单例bean</span></span><br><span class="line">            sharedInstance = getSingleton(...createBean(...)...)</span><br><span class="line">            bean = getObjectForBeanInstance(sharedInstance,...);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">if</span> (mbd.isPrototype()))&#123;</span><br><span class="line">            <span class="comment">//创建原型bean</span></span><br><span class="line">            prototypeInstance = createBean(...);</span><br><span class="line">            bean = getObjectForBeanInstance(prototypeInstance,...);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//其他作用域</span></span><br><span class="line">            String scopeName = mbd.getScope();</span><br><span class="line">            Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">            scopedInstance = scope.get(...createBean(...)...)</span><br><span class="line">            bean = getObjectForBeanInstance(scopedInstance,...);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上诉代码可以看到，关键的方法是 createBean，该方法由子类实现。</p>
<p>正好，spring 中 AbstractAutowireCapableBeanFactory 帮我们准备了上述方法的实现</p>
<p>下面将对这个类进行分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断需要创建的Bean是否可以实例化</span></span><br><span class="line">	Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);      </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//给BeanPostProcessors处理成一个代理类的机会</span></span><br><span class="line">    Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建实例</span></span><br><span class="line">    Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//实例持有</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//？</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">		instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//实例化</span></span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化，完成依赖注入，exposedObject是完成后的对象</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">		exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要的两个方法是 createBeanInstance 和 populateBean ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//确认bean可以实例化</span></span><br><span class="line">    Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">    <span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">			<span class="string">"Bean class isn't public, and non-public access not allowed: "</span> + beanClass.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//？</span></span><br><span class="line">    Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">	<span class="keyword">if</span> (instanceSupplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从工厂方法中获取实例</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>)  &#123;</span><br><span class="line">		<span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">        </span><br><span class="line">   	<span class="comment">//调用构造函数获取实例</span></span><br><span class="line">    Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (ctors != <span class="keyword">null</span> ||</span><br><span class="line">        mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">        mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line">        <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最后采用默认构造函数</span></span><br><span class="line">    <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//实例化策略：默认的实例化测试是CglibSubclassingInstantiationStrategy，也就Cglib</span></span><br><span class="line">		Object beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, <span class="keyword">this</span>);</span><br><span class="line">		BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span><br><span class="line">		initBeanWrapper(bw);</span><br><span class="line">		<span class="keyword">return</span> bw;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">				mbd.getResourceDescription(), beanName, <span class="string">"Instantiation of bean failed"</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!bd.hasMethodOverrides()) &#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">        <span class="comment">//JAVA反射</span></span><br><span class="line">		<span class="keyword">return</span> BeanUtils.instantiateClass(constructorToUse);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//cglib</span></span><br><span class="line">        <span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看依赖注入 populateBean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)</span></span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取Property值</span></span><br><span class="line">	PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//处理autowire</span></span><br><span class="line">	<span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class="line">	mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">        MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">			autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">		&#125;</span><br><span class="line">   </span><br><span class="line">		<span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">            autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pvs = newPvs;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//BeanPostProcessors处理</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注入</span></span><br><span class="line">	<span class="keyword">if</span> (pvs != <span class="keyword">null</span>) &#123;</span><br><span class="line">		applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPropertyValues</span><span class="params">(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pvs.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MutablePropertyValues mpvs = <span class="keyword">null</span>;</span><br><span class="line">    List&lt;PropertyValue&gt; original;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pvs <span class="keyword">instanceof</span> MutablePropertyValues) &#123;</span><br><span class="line">        mpvs = (MutablePropertyValues) pvs;</span><br><span class="line">        <span class="keyword">if</span> (mpvs.isConverted()) &#123;</span><br><span class="line">            <span class="comment">//1. 已作过转换处理 直接走捷径</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bw.setPropertyValues(mpvs);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                        mbd.getResourceDescription(), beanName, <span class="string">"Error setting property values"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        original = mpvs.getPropertyValueList();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        original = Arrays.asList(pvs.getPropertyValues()); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TypeConverter converter = getCustomTypeConverter();</span><br><span class="line">    <span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        converter = bw;</span><br><span class="line">    &#125;</span><br><span class="line">    BeanDefinitionValueResolver valueResolver = <span class="keyword">new</span> BeanDefinitionValueResolver(<span class="keyword">this</span>, beanName, mbd, converter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 类型转换，结果保存到新列表deepCopy中</span></span><br><span class="line">    List&lt;PropertyValue&gt; deepCopy = <span class="keyword">new</span> ArrayList&lt;&gt;(original.size());</span><br><span class="line">    <span class="keyword">boolean</span> resolveNecessary = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (PropertyValue pv : original) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pv.isConverted()) &#123;</span><br><span class="line">            <span class="comment">//已转换</span></span><br><span class="line">            deepCopy.add(pv);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//未转换</span></span><br><span class="line">            String propertyName = pv.getName();</span><br><span class="line">            Object originalValue = pv.getValue();</span><br><span class="line">            <span class="comment">//类型转换：如将 TypedStringValue 解析成 Resource</span></span><br><span class="line">            Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);</span><br><span class="line">            Object convertedValue = resolvedValue;</span><br><span class="line">            </span><br><span class="line">           	<span class="comment">/*</span></span><br><span class="line"><span class="comment">           	* 判断是否可转换：</span></span><br><span class="line"><span class="comment">           	* 1. 属性是否可写</span></span><br><span class="line"><span class="comment">           	* 2. 属性是否嵌套或者有索引</span></span><br><span class="line"><span class="comment">           	*/</span></span><br><span class="line">            <span class="keyword">boolean</span> convertible = bw.isWritableProperty(propertyName) &amp;&amp;</span><br><span class="line">                    !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);</span><br><span class="line">            <span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">                convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3. 保存转换后的值</span></span><br><span class="line">            <span class="keyword">if</span> (resolvedValue == originalValue) &#123;</span><br><span class="line">                <span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">                    pv.setConvertedValue(convertedValue);</span><br><span class="line">                &#125;</span><br><span class="line">                deepCopy.add(pv);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (convertible &amp;&amp; originalValue <span class="keyword">instanceof</span> TypedStringValue &amp;&amp;</span><br><span class="line">                    !((TypedStringValue) originalValue).isDynamic() &amp;&amp;</span><br><span class="line">                    !(convertedValue <span class="keyword">instanceof</span> Collection || ObjectUtils.isArray(convertedValue))) &#123;</span><br><span class="line">                pv.setConvertedValue(convertedValue);</span><br><span class="line">                deepCopy.add(pv);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolveNecessary = <span class="keyword">true</span>;</span><br><span class="line">                deepCopy.add(<span class="keyword">new</span> PropertyValue(pv, convertedValue));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mpvs != <span class="keyword">null</span> &amp;&amp; !resolveNecessary) &#123;</span><br><span class="line">        mpvs.setConverted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 赋值</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        bw.setPropertyValues(<span class="keyword">new</span> MutablePropertyValues(deepCopy));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">"Error setting property values"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>BeanWapper分析：</strong></p>
<p><img src="/2020/05/12/Spring/IOC容器的实现/image-20200528160704541.png" alt="image-20200528160704541"></p>
<ol>
<li><p>PropertyAccessor：提供通过属性名访问属性功能（是否可读，是否可写，get，set），支持普通的java对象和spring的Bean对象</p>
</li>
<li><p>TypeConverter：提供类型转换的功能（convertIfNecessary），比如注入的属性值是String型，而属性类型是对象类型，则提供转换的功能</p>
<p> TypeConverterSupport 继承了 PropertyEditorRegistrySupport，持有各种类型的 PropertyEditor，</p>
<p> TypeConverterSupport 委托 PropertyEditor 或者 ConversionService 来处理实际的值转换</p>
</li>
<li><p>ConfigurablePropertyAccessor：提供 PropertyAccessor 的相关配置(setConversionService)</p>
<ol>
<li>AbstractPropertyAccessor：实现 ConfigurablePropertyAccessor<ol>
<li>实现了各种可重构的方法，把关键的方法（如何访问属性）留给子类实现</li>
<li>继承 TypeConverterSupport，具有类型转换功能</li>
</ol>
</li>
<li>AbstractNestablePropertyAccessor：拓展了嵌套属性的访问功能，同样“如何访问”需要子类实现</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyBeanPropertyAccessor extends AbstractNestablePropertyAccessor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected PropertyHandler getLocalPropertyHandler(String propertyName) &#123;</span><br><span class="line">        //如何访问属性，并且抽象成PropertyHandler</span><br><span class="line">        return MyProxyHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected AbstractNestablePropertyAccessor newNestedPropertyAccessor(Object object, String nestedPath) &#123;</span><br><span class="line">        //提供子属性访问器</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected NotWritablePropertyException createNotWritablePropertyException(String propertyName) &#123;</span><br><span class="line">        //定义异常，附加额外的异常处理</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class MyProxyHandler extends PropertyHandler&#123;</span><br><span class="line"></span><br><span class="line">        public MyProxyHandler(Class&lt;?&gt; propertyType, boolean readable, boolean writable) &#123;</span><br><span class="line">            super(propertyType, readable, writable);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public TypeDescriptor toTypeDescriptor() &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public ResolvableType getResolvableType() &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public TypeDescriptor nested(int level) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Object getValue() throws Exception &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void setValue(Object value) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>BeanWrapper：提供分析和操作JavaBean的方法</p>
</li>
<li><p>BeanWrapperImpl：</p>
<ol>
<li>使用JavaBean的内省机制实现属性的访问</li>
<li>具有类型转换功能</li>
<li>具有通过属性名嵌套访问属性的功能</li>
</ol>
</li>
</ol>
<h2 id="其他特性实现"><a href="#其他特性实现" class="headerlink" title="其他特性实现"></a>其他特性实现</h2><h3 id="容器的准备"><a href="#容器的准备" class="headerlink" title="容器的准备"></a>容器的准备</h3><p><img src="/2020/05/12/Spring/IOC容器的实现/image-20200528163841436.png" alt="image-20200528163841436"></p>
<p>容器的准备发生在 AbstractApplicationContext#prepareBeanFactory() 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		* 1. 类加载器设置</span></span><br><span class="line"><span class="comment">		* 2. 新增PropertyEditorRegistrar</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">		beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">		beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		* 1. 配置BeanPostProcessor</span></span><br><span class="line"><span class="comment">		* 2. 配置DependencyInterface</span></span><br><span class="line"><span class="comment">		* DependencyInterface 用于 依赖检查 和 autowire 时指定忽略的接口</span></span><br><span class="line"><span class="comment">		* 详情可查看 (https://www.jianshu.com/p/3c7e0608ff1f)</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">		beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">		beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">		beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">		beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">		beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">		beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line">		<span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line">		beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">		beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">		beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">		beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line">		beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line">		<span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">			beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">			<span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">			beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 注册默认环境bean</span></span><br><span class="line">		<span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">			beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">			beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">			beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="容器的销毁"><a href="#容器的销毁" class="headerlink" title="容器的销毁"></a>容器的销毁</h3><p>发生在 AbstractApplicationContext#doClose() 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.active.get() &amp;&amp; <span class="keyword">this</span>.closed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">				logger.info(<span class="string">"Closing "</span> + <span class="keyword">this</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			LiveBeansView.unregisterApplicationContext(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// 发布关闭事件</span></span><br><span class="line">				publishEvent(<span class="keyword">new</span> ContextClosedEvent(<span class="keyword">this</span>));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">				logger.warn(<span class="string">"Exception thrown from ApplicationListener handling ContextClosedEvent"</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Stop all Lifecycle beans, to avoid delays during individual destruction.</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.lifecycleProcessor != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">this</span>.lifecycleProcessor.onClose();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">					logger.warn(<span class="string">"Exception thrown from LifecycleProcessor on context close"</span>, ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Destroy all cached singletons in the context's BeanFactory.</span></span><br><span class="line">			destroyBeans();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Close the state of this context itself.</span></span><br><span class="line">			closeBeanFactory();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Let subclasses do some final clean-up if they wish...</span></span><br><span class="line">			onClose();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">this</span>.active.set(<span class="keyword">false</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Bean初始化"><a href="#Bean初始化" class="headerlink" title="Bean初始化"></a>Bean初始化</h3><p>发生在 AbstractAutowireCapableBeanFactory#initializeBean 中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutowireCapableBeanFactory</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//anything else...</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//1. 执行BeanNameAware、BeanClassLoaderAware、BeanFactoryAware方法</span></span><br><span class="line">		invokeAwareMethods(beanName, bean);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//2. 执行BeanPostProcessor.postProcessBeforeInitialization()</span></span><br><span class="line">		Object wrappedBean = bean;</span><br><span class="line">		<span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//3. 执行InitializingBean.afterPropertiesSet()</span></span><br><span class="line">		<span class="comment">//	 执行&lt;init-method&gt;</span></span><br><span class="line">		invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//4. 执行BeanPostProcessor.postProcessAfterInitialization()</span></span><br><span class="line">		<span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">			wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> wrappedBean;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Bean销毁"><a href="#Bean销毁" class="headerlink" title="Bean销毁"></a>Bean销毁</h3><p>最终会走到 DisposableBeanAdapter#destroy 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisposableBeanAdapter</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 执行 DestructionAwareBeanPostProcessor#postProcessBeforeDestruction</span></span><br><span class="line">		<span class="keyword">if</span> (!CollectionUtils.isEmpty(<span class="keyword">this</span>.beanPostProcessors)) &#123;</span><br><span class="line">			<span class="keyword">for</span> (DestructionAwareBeanPostProcessor processor : <span class="keyword">this</span>.beanPostProcessors) &#123;</span><br><span class="line">				processor.postProcessBeforeDestruction(<span class="keyword">this</span>.bean, <span class="keyword">this</span>.beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//2. 执行DisposableBean#destroy()</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.invokeDisposableBean) &#123;</span><br><span class="line">			((DisposableBean) bean).destroy();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 执行&lt;destory-method&gt;</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.destroyMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">			invokeCustomDestroyMethod(<span class="keyword">this</span>.destroyMethod);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.destroyMethodName != <span class="keyword">null</span>) &#123;</span><br><span class="line">			Method methodToCall = determineDestroyMethod(<span class="keyword">this</span>.destroyMethodName);</span><br><span class="line">			<span class="keyword">if</span> (methodToCall != <span class="keyword">null</span>) &#123;</span><br><span class="line">				invokeCustomDestroyMethod(methodToCall);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lazy-init属性和预实例化"><a href="#lazy-init属性和预实例化" class="headerlink" title="lazy-init属性和预实例化"></a>lazy-init属性和预实例化</h3><p><strong>lazy-init属性有何用？</strong></p>
<p>决定执行bean的实例化：是在容器初始化完成时还是第一个请求获取bean时</p>
<p>相关逻辑在 DefaultListableBeanFactory#preInstantiateSingletons 中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultListableBeanFactory</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//忽略无关代码...</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 执行 non-lazy 单例的初始化</span></span><br><span class="line">		<span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">			<span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">				getBean(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><p>FactoryBean的相关逻辑在 AbstractBeanFactory#getObjectForBeanInstance中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanFactory</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectForBeanInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// beanInstance 是工厂Bean 已经经历了 依赖注入 和 初始化</span></span><br><span class="line">        <span class="comment">// 忽略无关代码...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 非 FactoryBean 直接返回</span></span><br><span class="line">        <span class="comment">// 获取 FactoryBean 本身 beanName以&amp;开头</span></span><br><span class="line">        <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> beanInstance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行 FactoryBean#getObject();</span></span><br><span class="line">        <span class="keyword">boolean</span> synthetic = (mbd != <span class="keyword">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line">        Object object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="autowiring自动装配"><a href="#autowiring自动装配" class="headerlink" title="autowiring自动装配"></a>autowiring自动装配</h3><p>相关逻辑在 AbstractAutowireCapableBeanFactory#populateBean 中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractAutowireCapableBeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">        PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//忽略无关代码...</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class="line">                mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">            MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// by name</span></span><br><span class="line">            <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">                autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// by type</span></span><br><span class="line">            <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">                autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pvs = newPvs;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Bean对IOC容器的感知"><a href="#Bean对IOC容器的感知" class="headerlink" title="Bean对IOC容器的感知"></a>Bean对IOC容器的感知</h3><p><img src="/2020/05/12/Spring/IOC容器的实现/image-20200529170459629.png" alt="image-20200529170459629" style="zoom:50%;"></p>
<p>通过 ApplicationContextAwareProcessor 来实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextAwareProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConfigurableApplicationContext applicationContext;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringValueResolver embeddedValueResolver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ApplicationContextAwareProcessor</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">        <span class="keyword">this</span>.embeddedValueResolver = <span class="keyword">new</span> EmbeddedValueResolver(applicationContext.getBeanFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(<span class="keyword">final</span> Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//忽略无关代码...</span></span><br><span class="line">        </span><br><span class="line">        invokeAwareInterfaces(bean);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareInterfaces</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware) &#123;</span><br><span class="line">                ((EnvironmentAware) bean).setEnvironment(<span class="keyword">this</span>.applicationContext.getEnvironment());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware) &#123;</span><br><span class="line">                ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(<span class="keyword">this</span>.embeddedValueResolver);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware) &#123;</span><br><span class="line">                ((ResourceLoaderAware) bean).setResourceLoader(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware) &#123;</span><br><span class="line">                ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MessageSourceAware) &#123;</span><br><span class="line">                ((MessageSourceAware) bean).setMessageSource(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">                ((ApplicationContextAware) bean).setApplicationContext(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring MVC</title>
    <url>/2020/06/17/Spring/springMVC/</url>
    <content><![CDATA[<h1 id="spring-MVC"><a href="#spring-MVC" class="headerlink" title="spring MVC"></a>spring MVC</h1><p>为什么在WEB下接入spring？</p>
<p>极高的提高开发效率</p>
<p>如何在web环境中整合spring容器？</p>
<p>常见的web容器是tomcat，在tomcat中主要的组件是servlet、监听器等，tomcat的配置在WEB-INF/web.xml中</p>
<p>常见配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"4.0"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置根容器上下文配置文件，默认位置是/WEB-INF/applicationContext.xml--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--监听器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置DispatchcerServlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Main<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置servlet容器上下文配置文件，默认位置是WEB-INF/[DispatcherServlet的Servlet名字,也就是Main]-servlet.xml--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:Main-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- load-on-startup：表示启动容器时初始化该Servlet； --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Main<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- url-pattern：表示哪些请求交给Spring Web MVC处理， “/” 是用来定义默认servlet映射的。 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 也可以如“*.html”表示拦截所有以html为扩展名的请求。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="根容器的初始化"><a href="#根容器的初始化" class="headerlink" title="根容器的初始化"></a>根容器的初始化</h2><p>先来看看 ContextLoaderListener 有什么作用：</p>
<p><img src="/2020/06/17/Spring/springMVC/image-20200609155939201.png" alt="image-20200609155939201"></p>
<p>ContextLoaderListener 实现了 ServletContextListener 接口，ServletContextListener 是 tomcat 中的监听器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServletContextListener</span> <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * web应用启动时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * web应有销毁时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着看 ContextLoaderListener 如何实现 contextInitialized：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextLoaderListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">        initWebApplicationContext(event.getServletContext());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用了父类方法 ContextLoader：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//校验和日志...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 实例化容器</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.context == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.context = createWebApplicationContext(servletContext);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2. 配置并启动</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.context <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">                ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) <span class="keyword">this</span>.context;</span><br><span class="line">                <span class="comment">//设置父容器</span></span><br><span class="line">                <span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        ApplicationContext parent = loadParentContext(servletContext);</span><br><span class="line">                        cwac.setParent(parent);</span><br><span class="line">                    &#125;</span><br><span class="line">                    configureAndRefreshWebApplicationContext(cwac, servletContext);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3. 保存容器</span></span><br><span class="line">            servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="keyword">this</span>.context);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//其他无关代码..</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.context;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着看如何进行容器的实例化，进入 ContextLoader##createWebApplicationContext() ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createWebApplicationContext</span><span class="params">(ServletContext sc)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; contextClass = determineContextClass(sc);</span><br><span class="line">        <span class="keyword">if</span> (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"Custom context class ["</span> + contextClass.getName() +</span><br><span class="line">                    <span class="string">"] is not of type ["</span> + ConfigurableWebApplicationContext.class.getName() + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入 ContextLoader##determineContextClass()，该方法决定容器的具体类型 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; determineContextClass(ServletContext servletContext) &#123;</span><br><span class="line">        <span class="comment">// 1. 查询xml中contextClass参数配置</span></span><br><span class="line">        String contextClassName = servletContext.getInitParameter(CONTEXT_CLASS_PARAM);</span><br><span class="line">        <span class="keyword">if</span> (contextClassName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ClassUtils.forName(contextClassName, ClassUtils.getDefaultClassLoader());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 无配置采用默认类型 XmlWebApplicationContext.class</span></span><br><span class="line">            contextClassName = defaultStrategies.getProperty(WebApplicationContext.class.getName());</span><br><span class="line">            <span class="keyword">return</span> ClassUtils.forName(contextClassName, ContextLoader.class.getClassLoader());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着看如何配置容器并启动，进入 ContextLoader##configureAndRefreshWebApplicationContext()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureAndRefreshWebApplicationContext</span><span class="params">(ConfigurableWebApplicationContext wac, ServletContext sc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;</span><br><span class="line">            <span class="comment">// 配置容器id</span></span><br><span class="line">            String idParam = sc.getInitParameter(CONTEXT_ID_PARAM);</span><br><span class="line">            <span class="keyword">if</span> (idParam != <span class="keyword">null</span>) &#123;</span><br><span class="line">                wac.setId(idParam);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Generate default id...</span></span><br><span class="line">                wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +</span><br><span class="line">                        ObjectUtils.getDisplayString(sc.getContextPath()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存 ServletContext</span></span><br><span class="line">        wac.setServletContext(sc);</span><br><span class="line">        <span class="comment">// 配置 bean定义 xml路径，默认是/WEB-INF/applicationContext.xml</span></span><br><span class="line">        String configLocationParam = sc.getInitParameter(CONFIG_LOCATION_PARAM);</span><br><span class="line">        <span class="keyword">if</span> (configLocationParam != <span class="keyword">null</span>) &#123;</span><br><span class="line">            wac.setConfigLocation(configLocationParam);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//else...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动容器</span></span><br><span class="line">        wac.refresh();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直此，根容器就启动起来，根容器 和 ServetContext 相互持有对方的实例，因此根容器所处的上下文就是 ServetContext  上下文，之后便可在web环境下使用spring容器的 IOC 和 AOP 功能。</p>
<h2 id="spring-MVC-1"><a href="#spring-MVC-1" class="headerlink" title="spring MVC"></a>spring MVC</h2><p>MVC 就不必多言了，至于为什么选择 spring MVC，而不是struts2等，还不是因为它比较好用。</p>
<p>如何接入spring MVC 呢，还记得我们之前配置文件中配置的一个servlet吗？——DispatcherServlet</p>
<p>DispatcherServlet 作为 tomcat 的组件，有其web容器中的生命周期：</p>
<p><img src="/2020/06/17/Spring/springMVC/image-20200609172103097.png" alt="image-20200609172103097"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有 servlet 的init方法在 tomcat 启动时都会被调用，我们看 DispatcherServlet 的 init()，其实现在父类 HttpServletBean 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpServletBean</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">"Initializing servlet '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 从xml的init参数设置属性值</span></span><br><span class="line">		PropertyValues pvs = <span class="keyword">new</span> ServletConfigPropertyValues(getServletConfig(), <span class="keyword">this</span>.requiredProperties);</span><br><span class="line">		<span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</span><br><span class="line">				ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(getServletContext());</span><br><span class="line">				bw.registerCustomEditor(Resource.class, <span class="keyword">new</span> ResourceEditor(resourceLoader, getEnvironment()));</span><br><span class="line">				initBeanWrapper(bw);</span><br><span class="line">				bw.setPropertyValues(pvs, <span class="keyword">true</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isErrorEnabled()) &#123;</span><br><span class="line">					logger.error(<span class="string">"Failed to set bean properties on servlet '"</span> + getServletName() + <span class="string">"'"</span>, ex);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 让子类做他们想做的事情</span></span><br><span class="line">		initServletBean();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">"Servlet '"</span> + getServletName() + <span class="string">"' configured successfully"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;   PropertyValue 和 BeanWrapper 使用小案例：</span><br><span class="line">&gt;   A a = new A();</span><br><span class="line">&gt;   BeanWrapper beanWrapper = new BeanWrapperImpl(a);</span><br><span class="line">&gt;   PropertyValue propertyValue = new PropertyValue(&quot;name&quot;,&quot;qqq&quot;);</span><br><span class="line">&gt;   beanWrapper.setPropertyValue(propertyValue);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>子类 FrameworkServlet 重写了 initServletBean 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrameworkServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        getServletContext().log(<span class="string">"Initializing Spring FrameworkServlet '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class="line">        initFrameworkServlet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入 FrameworkServlet##initWebApplicationContext ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrameworkServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// rootContext 就是之前创建的 根容器</span></span><br><span class="line">        WebApplicationContext rootContext =</span><br><span class="line">                WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">        <span class="comment">// 初始化容器，contextClass参数可以执行容器类，否则默认XmlWebApplicationContext</span></span><br><span class="line">        wac = createWebApplicationContext(rootContext);</span><br><span class="line">        <span class="comment">// 让子类执行初始化工作</span></span><br><span class="line">        onRefresh(wac);</span><br><span class="line">        <span class="keyword">return</span> wac;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么创建了两个容器？</p>
<p>根容器是web环境下使用的，管理tomcat中所有的bean，而子容器是servlet下使用的，仅管理springMVC中所有的Bean .</p>
<p>追溯 onRefresh(wac) ，可以走到 DispatcherServlet##initStrategies中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class DispatcherServlet&#123;</span><br><span class="line">	protected void initStrategies(ApplicationContext context) &#123;</span><br><span class="line">		initMultipartResolver(context);</span><br><span class="line">		initLocaleResolver(context);</span><br><span class="line">		initThemeResolver(context);</span><br><span class="line">		initHandlerMappings(context);</span><br><span class="line">		initHandlerAdapters(context);</span><br><span class="line">		initHandlerExceptionResolvers(context);</span><br><span class="line">		initRequestToViewNameTranslator(context);</span><br><span class="line">		initViewResolvers(context);</span><br><span class="line">		initFlashMapManager(context);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，initStrategies中做了大量的初始化工作，以 initHandlerMappings 为例说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DispatcherServlet</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHandlerMappings</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.handlerMappings = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.detectAllHandlerMappings) &#123;</span><br><span class="line">        <span class="comment">// 1. 初始化为容器中所有HandlerMapping类的bean</span></span><br><span class="line">            Map&lt;String, HandlerMapping&gt; matchingBeans =</span><br><span class="line">					BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">			<span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class="line">				<span class="keyword">this</span>.handlerMappings = <span class="keyword">new</span> ArrayList&lt;&gt;(matchingBeans.values());</span><br><span class="line">				<span class="comment">// We keep HandlerMappings in sorted order.</span></span><br><span class="line">				AnnotationAwareOrderComparator.sort(<span class="keyword">this</span>.handlerMappings);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 初始化为name是handlerMapping的bean</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);</span><br><span class="line">				<span class="keyword">this</span>.handlerMappings = Collections.singletonList(hm);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">				<span class="comment">// Ignore, we'll add a default HandlerMapping later.</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 3. 容器中没有定义，则采用默认 BeanNameUrlHandlerMapping/RequestMappingHandlerMapping</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">"No HandlerMappings found in servlet '"</span> + getServletName() + <span class="string">"': using default"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，DispatcherServlet 中持有了另一个 spring容器。</p>
<p>那么来到第二个问题，servlet 如何工作？</p>
<p>当有请求到来时，根据web中定义的url映射会指派到指定的servlet中执行相应的service()方法， DispatcherServlet 的 service() 实现在 父类 FrameworkServlet 中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrameworkServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());</span><br><span class="line">        <span class="keyword">if</span> (HttpMethod.PATCH == httpMethod || httpMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 关键方法</span></span><br><span class="line">            processRequest(request, response);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 最终也会走到processRequest</span></span><br><span class="line">            <span class="keyword">super</span>.service(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入 FrameworkServlet##processRequest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrameworkServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 初始化 LocaleContextHolder RequestContextHolder </span></span><br><span class="line">        <span class="comment">// initContextHolders(request, localeContext, requestAttributes);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 关键方法</span></span><br><span class="line">        doService(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入 DispatcherServle##doService：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DispatcherServle</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. request.setAttribute...</span></span><br><span class="line">    </span><br><span class="line">    doDispatch(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入 DispatcherServle##doDispatch：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DispatcherServle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//忽略无关代码...</span></span><br><span class="line">        </span><br><span class="line">        processedRequest = checkMultipart(request);</span><br><span class="line">        HandlerExecutionChain mappedHandler = getHandler(processedRequest);</span><br><span class="line">        HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">        mappedHandler.applyPreHandle(processedRequest, response);</span><br><span class="line">        ModelAndView mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">        applyDefaultViewName(processedRequest, mv);</span><br><span class="line">        mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要理解上面代码到底在做什么，我们得学习下面知识点：</p>
<ul>
<li>HandlerMapping：匹配url和处理器</li>
<li>HandlerExecutionChain：包装处理器和拦截器</li>
<li>HandlerAdapter：适配处理器：</li>
<li>ModelAndView：模型和视图</li>
<li>View：视图</li>
</ul>
<h3 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerMapping</span> </span>&#123;</span><br><span class="line">    <span class="function">HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractHandlerMapping 做了基本的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractHandlerMapping</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 匹配对应的handler实例 由子类实现</span></span><br><span class="line">        Object handler = getHandlerInternal(request);</span><br><span class="line">        <span class="comment">// 2. 若对应不到，采取默认的handler实例</span></span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handler = getDefaultHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 或是字符串，则从容器中获取对应实例</span></span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            String handlerName = (String) handler;</span><br><span class="line">            handler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4. 加入拦截器，包装成 HandlerExecutionChain</span></span><br><span class="line">        HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);</span><br><span class="line">        <span class="keyword">if</span> (CorsUtils.isCorsRequest(request)) &#123;</span><br><span class="line">            CorsConfiguration globalConfig = <span class="keyword">this</span>.globalCorsConfigSource.getCorsConfiguration(request);</span><br><span class="line">            CorsConfiguration handlerConfig = getCorsConfiguration(handler, request);</span><br><span class="line">            CorsConfiguration config = (globalConfig != <span class="keyword">null</span> ? globalConfig.combine(handlerConfig) : handlerConfig);</span><br><span class="line">            executionChain = getCorsHandlerExecutionChain(request, executionChain, config);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> executionChain;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getHandlerInternal 的匹配逻辑由子类实现，常用的有：</p>
<ul>
<li>AbstractHandlerMethodMapping：匹配url到一个Handler方法</li>
<li>AbstractUrlHandlerMapping：匹配url到一个Handler类</li>
</ul>
<p>以 AbstractUrlHandlerMapping 为例进行说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractUrlHandlerMapping</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; handlerMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取 url</span></span><br><span class="line">        String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);</span><br><span class="line">        <span class="comment">// 根据 handlerMap 进行匹配</span></span><br><span class="line">        Object handler = lookupHandler(lookupPath, request);</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// We need to care for the default handler directly, since we need to</span></span><br><span class="line">            <span class="comment">// expose the PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE for it as well.</span></span><br><span class="line">            Object rawHandler = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"/"</span>.equals(lookupPath)) &#123;</span><br><span class="line">                rawHandler = getRootHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rawHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                rawHandler = getDefaultHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rawHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Bean name or resolved handler?</span></span><br><span class="line">                <span class="keyword">if</span> (rawHandler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                    String handlerName = (String) rawHandler;</span><br><span class="line">                    rawHandler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">                &#125;</span><br><span class="line">                validateHandler(rawHandler, request);</span><br><span class="line">                handler = buildPathExposingHandler(rawHandler, lookupPath, lookupPath, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有子类去处理 handlerMap 的初始化，以 SimpleUrlHandlerMapping 为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleUrlHandlerMapping</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 父类实现了 ApplicationContextAware</span></span><br><span class="line"><span class="comment">     * 在 setApplicationContext 中会调用initApplicationContext()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initApplicationContext</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.initApplicationContext();</span><br><span class="line">        registerHandlers(<span class="keyword">this</span>.urlMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化 handlerMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerHandlers</span><span class="params">(Map&lt;String, Object&gt; urlMap)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (urlMap.isEmpty()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Neither 'urlMap' nor 'mappings' set on SimpleUrlHandlerMapping"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            urlMap.forEach((url, handler) -&gt; &#123;</span><br><span class="line">                <span class="comment">// Prepend with slash if not already present.</span></span><br><span class="line">                <span class="keyword">if</span> (!url.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">                    url = <span class="string">"/"</span> + url;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Remove whitespace from handler bean name.</span></span><br><span class="line">                <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                    handler = ((String) handler).trim();</span><br><span class="line">                &#125;</span><br><span class="line">                registerHandler(url, handler);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HandlerExecutionChain"><a href="#HandlerExecutionChain" class="headerlink" title="HandlerExecutionChain"></a>HandlerExecutionChain</h3><p>HandlerExecutionChain 持有 处理器 和 拦截器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerExecutionChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Object handler;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> HandlerInterceptor[] interceptors;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> List&lt;HandlerInterceptor&gt; interceptorList;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//else....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理器的类型很多，统一适配成 HandlerAdapter 执行如：</p>
<ul>
<li>接口 Controller，适配器 SimpleControllerHandlerAdapter</li>
<li>接口 HttpRequestHandler，适配器 HttpRequestHandlerAdapter</li>
<li>接口 Servlet，适配器 SimpleServletHandlerAdapter</li>
</ul>
<p>以 SimpleControllerHandlerAdapter 为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleControllerHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (handler <span class="keyword">instanceof</span> Controller);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ((Controller) handler).handleRequest(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> LastModified) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((LastModified) handler).getLastModified(request);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ModelAndView"><a href="#ModelAndView" class="headerlink" title="ModelAndView"></a>ModelAndView</h3><p>持有 Model 和 View (或者 字符名)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelAndView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Object view;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> ModelMap model;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将返回解析到 response 中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">render</span><span class="params">(@Nullable Map&lt;String, ?&gt; model,</span></span></span><br><span class="line"><span class="function"><span class="params">                HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象实现：AbstractView</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractView</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(@Nullable Map&lt;String, ?&gt; model, HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">			HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 必要时，将 staticAttributes 和 requestContextAttribute 也整合到model中</span></span><br><span class="line">		Map&lt;String, Object&gt; mergedModel = createMergedOutputModel(model, request, response);</span><br><span class="line">		prepareResponse(request, response);</span><br><span class="line">		<span class="comment">//由子类实现</span></span><br><span class="line">		renderMergedOutputModel(mergedModel, getRequestToExpose(request), response);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体如何解析返回，由子类实现 renderMergedOutputModel 来实现，如 pdf（AbstractPdfView），excel（AbstractXlsView），资源文件jsp（InternalResourceView）等等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractPdfView</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">renderMergedOutputModel</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// IE workaround: write into byte array first.</span></span><br><span class="line">		ByteArrayOutputStream baos = createTemporaryOutputStream();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Apply preferences and build metadata.</span></span><br><span class="line">		Document document = newDocument();</span><br><span class="line">		PdfWriter writer = newWriter(document, baos);</span><br><span class="line">		prepareWriter(model, writer, request);</span><br><span class="line">		buildPdfMetadata(model, document, request);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Build PDF document.</span></span><br><span class="line">		document.open();</span><br><span class="line">		buildPdfDocument(model, document, writer, request, response);</span><br><span class="line">		document.close();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Flush to HTTP response.</span></span><br><span class="line">		writeToResponse(response, baos);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RequestToViewNameTranslator"><a href="#RequestToViewNameTranslator" class="headerlink" title="RequestToViewNameTranslator"></a>RequestToViewNameTranslator</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RequestToViewNameTranslator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据 request 获取一个 view name</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">String <span class="title">getViewName</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一个默认实现 DefaultRequestToViewNameTranslator，列如：/www/qwe.jsp 将会解析为 www/qwe</p>
<h3 id="ViewResolver"><a href="#ViewResolver" class="headerlink" title="ViewResolver"></a>ViewResolver</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ViewResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将 view字符名 解析为 View</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">View <span class="title">resolveViewName</span><span class="params">(String viewName, Locale locale)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如 InternalResourceViewResolver 将view字符名 解析为 InternalResourceView</p>
<h3 id="DispatcherServle-doDispatch"><a href="#DispatcherServle-doDispatch" class="headerlink" title="DispatcherServle##doDispatch"></a>DispatcherServle##doDispatch</h3><p>再回到之前的 DispatcherServle##doDispatch 中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class DispatcherServle &#123;</span><br><span class="line">    protected void doDispatch(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">        // 忽略无关代码...</span><br><span class="line">        </span><br><span class="line">        processedRequest = checkMultipart(request);</span><br><span class="line">        // 获取 HandlerExecutionChain</span><br><span class="line">        HandlerExecutionChain mappedHandler = getHandler(processedRequest);</span><br><span class="line">        </span><br><span class="line">        // 适配 Handler</span><br><span class="line">        HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">        </span><br><span class="line">        // 拦截器前置处理</span><br><span class="line">        mappedHandler.applyPreHandle(processedRequest, response);</span><br><span class="line">        </span><br><span class="line">        // 处理器执行</span><br><span class="line">        ModelAndView mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">        </span><br><span class="line">        // RequestToViewNameTranslator 解析 request 获取 view Name</span><br><span class="line">        applyDefaultViewName(processedRequest, mv);</span><br><span class="line">        </span><br><span class="line">        // 拦截器后置处理</span><br><span class="line">        mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        </span><br><span class="line">        // 1. ViewResolver 解析 view Name 获取 View 对象</span><br><span class="line">        // 2. 执行 View##render 方法，处理成 response</span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>15 泛型</title>
    <url>/2018/12/17/THING%20IN%20JAVA/15%20%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="简单泛型"><a href="#简单泛型" class="headerlink" title="简单泛型"></a>简单泛型</h2><p>让一些类方式适用于所有类型，而不是特定的类和接口。<br>应用：</p>
<h3 id="元祖"><a href="#元祖" class="headerlink" title="元祖"></a>元祖</h3><p>问题：<br>一个方法只能返回一个新的对象，如果想要返回对个对象，只能再包装成一个新对象。每次需要都需要这样处理。<br>更好的解决办法：使用泛型元祖<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoTuple</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> A first;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> B second;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoTuple</span><span class="params">(A a, B b)</span> </span>&#123;</span><br><span class="line">        first = a;</span><br><span class="line">        second = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"("</span> + first + <span class="string">", "</span> + second + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一个二元元祖<br>注意：使用final，只能一次赋值，之后就只能读。（符合JAVA编程的安全性原则）<br>增加“元”可以使用继承来实现。</p>
<h3 id="堆栈类"><a href="#堆栈类" class="headerlink" title="堆栈类"></a>堆栈类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">        U item;</span><br><span class="line">        Node&lt;U&gt; next;</span><br><span class="line"></span><br><span class="line">        Node() &#123;</span><br><span class="line">            item = <span class="keyword">null</span>;</span><br><span class="line">            next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(U item, Node&lt;U&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> item == <span class="keyword">null</span> &amp;&amp; next == <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; top = <span class="keyword">new</span> Node&lt;T&gt;(); <span class="comment">// End sentinel   </span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">        top = <span class="keyword">new</span> Node&lt;T&gt;(item, top);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T result = top.item;</span><br><span class="line">        <span class="keyword">if</span> (!top.end()) top = top.next;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedStack&lt;String&gt; lss = <span class="keyword">new</span> LinkedStack&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : <span class="string">"Phasers on stun!"</span>.split(<span class="string">" "</span>)) lss.push(s);</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s = lss.pop()) != <span class="keyword">null</span>) System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最初的一个Node 叫做哨兵节点，用来判空。</p>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>在声明接口的时候，加上泛型声明<t>，可以泛化接口中的参数类型和返回类型。<br>来看一个具体的应用：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Blacksmith</span> </span>&#123;</span><br><span class="line">  <span class="function">Weapon <span class="title">manufactureWeapon</span><span class="params">(WeaponType weaponType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p>
<p>这是之前讲过的工厂方法，上面是一个可以制作武器的工厂。<br>使用泛型可以做一个生成器，这是工厂方法的一个应用：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>泛型可以只用在方法上，无论是不是泛型类。</p>
<p>泛型方法的思想是：可以简化和类型的耦合关系，把编程的重心点放到逻辑上！并且可以让这个逻辑适用于所有类型！很强大！</p>
<p>注意点：尽量使用泛型方法来代替泛型类</p>
<p><strong>什么是类型推断？</strong></p>
<p>能通过参数的类型或者返回的结果类型判断出泛型的具体类型。<br>用法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">New</span> </span>&#123;   </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">Map&lt;K,V&gt; <span class="title">map</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;K,V&gt;();   </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     </span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; sls = New.map();     </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类型判断只在赋值操作的时候工作，其它时候是无效的，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LimitsOfInference</span> </span>&#123;   </span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Map&lt;Person, List&lt;? extends Pet&gt;&gt; petPeople)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     </span><br><span class="line">     <span class="comment">//f(New.map()); // Does not compile   </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这时候无法做类型判断，为了解决这个问题，需要显示的声明类型，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExplicitTypeSpecification</span> </span>&#123;   </span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Map&lt;Person, List&lt;Pet&gt;&gt; petPeople)</span> </span>&#123;&#125;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     </span><br><span class="line">    f(New.&lt;Person, List&lt;Pet&gt;&gt;map());   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样做似乎没有什么好处。</p>
<p><strong>泛型方法的应用？</strong></p>
<p>还是那句话：尽量使用泛型方法来代替泛型类</p>
<ol>
<li>利用生成器和泛型方法，编写Collection快速填充方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generators</span> </span>&#123;   </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">fill</span><span class="params">(Collection&lt;T&gt; coll, Generator&lt;T&gt; gen, <span class="keyword">int</span> n)</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)       </span><br><span class="line">        coll.add(gen.next());     </span><br><span class="line">    <span class="keyword">return</span> coll;   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一个麻烦，每一个Collection<t>，都要为他编写特定的Generatro<t>实现。<br>解决方案：提供一个基本的实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;   </span><br><span class="line">  <span class="keyword">private</span> Class&lt;T&gt; type;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BasicGenerator</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;       <span class="comment">// Assumes type is a public class:       </span></span><br><span class="line">      <span class="keyword">return</span> type.newInstance();     </span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;       </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);     </span><br><span class="line">    &#125;   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></t></p>
<ol start="2">
<li>一个更加通用的类生产方法：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicGenerator</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Assumes type is a public class:       </span></span><br><span class="line">            <span class="keyword">return</span> type.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Produce a Default generator given a type token:   </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Generator&lt;T&gt; <span class="title">create</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BasicGenerator&lt;T&gt;(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>使用泛型方法来优化元祖类的</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A, B&gt; <span class="function">TwoTuple&lt;A, B&gt; <span class="title">tuple</span><span class="params">(A a, B b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TwoTuple&lt;A, B&gt;(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A, B, C&gt; <span class="function">ThreeTuple&lt;A, B, C&gt; <span class="title">tuple</span><span class="params">(A a, B b, C c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreeTuple&lt;A, B, C&gt;(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A, B, C, D&gt; <span class="function">FourTuple&lt;A, B, C, D&gt; <span class="title">tuple</span><span class="params">(A a, B b, C c, D d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FourTuple&lt;A, B, C, D&gt;(a, b, c, d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A, B, C, D, E&gt; <span class="function">FiveTuple&lt;A, B, C, D, E&gt; <span class="title">tuple</span><span class="params">(A a, B b, C c, D d, E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FiveTuple&lt;A, B, C, D, E&gt;(a, b, c, d, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="擦除"><a href="#擦除" class="headerlink" title="擦除"></a>擦除</h2><p><strong>什么是擦除？</strong></p>
<p>在运行时期，即便通过反射，也只是获取类型参数标志符号和泛型类型边界的信息，无法获取实际的类型参数。</p>
<p><strong>擦除给泛型带来的影响有？</strong></p>
<p>C++中的泛型：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Manipulator</span> &#123;</span>   </span><br><span class="line">  T obj;</span><br><span class="line"><span class="keyword">public</span>:   </span><br><span class="line">    Manipulator(T x) &#123; obj = x; &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span> </span>&#123; obj.f(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasF</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:   </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"HasF::f()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">  HasF hf;   </span><br><span class="line">  Manipulator&lt;HasF&gt; manipulator(hf);   </span><br><span class="line">  manipulator.manipulate();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Manipulator<hasf>在声明的时候，编译器如果发现HasF中有方法f()，编译就能通过，否则就会得到一个编译器异常。</hasf></p>
<p>再来看JAVA：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HasF</span> </span>&#123;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"HasF.f()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manipulator</span>&lt;<span class="title">T</span>&gt; </span>&#123;   </span><br><span class="line">  <span class="keyword">private</span> T obj;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Manipulator</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    obj = x;</span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="comment">// Error: cannot find symbol: method f():   </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    obj.f();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>会报错，因为编译器无法通过Manipulator<hasf>的声明来判断，obj有方法f()。</hasf></p>
<p>若要解决这个问题，要使用extends来限定边界：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manipulator2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasF</span>&gt; </span>&#123;   </span><br><span class="line">  <span class="keyword">private</span> T obj;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Manipulator2</span><span class="params">(T x)</span> </span>&#123; obj = x; &#125;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span> </span>&#123; obj.f(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所谓擦除，实际上就是编译器会把上面的代码变为下面这样：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manipulator2</span> </span>&#123;   </span><br><span class="line">  <span class="keyword">private</span> HasF obj;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Manipulator2</span><span class="params">(HasF x)</span> </span>&#123; obj = x; &#125;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span> </span>&#123; obj.f(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这时候就不会报错了。<br>但是这样一来，我们完全没有看出泛型带来的作用，因为多态也有一定的泛化作用。<br>因此，我们可以说：当希望一段代码作用不同的基类，泛型才有更多的意义。<br>除此之外，泛型还是有类型检查和自动类型转换的功能的。</p>
<p><strong>擦除设计的由来？</strong></p>
<p>JAVA的一个核心理念就是版本兼容，因此，为了使JAVA5之前的版本代码也能完好的执行，JAVA让擦除成为一个解决方案。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-----JAVA5后更新的泛型类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericBase</span>&lt;<span class="title">T</span>&gt; </span>&#123;   </span><br><span class="line">  <span class="keyword">private</span> T element;   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">    arg = element;</span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----JAVA5后的类库</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">GenericBase</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----JAVA5前的类库，完美兼容</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived2</span> <span class="keyword">extends</span> <span class="title">GenericBase</span> </span>&#123;&#125; <span class="comment">// No warning</span></span><br></pre></td></tr></table></figure></p>
<p><strong>如何理解JAVA泛型的作用？</strong></p>
<p>即使由于擦除，JAVA的泛型并没有传统上的那么有效，但是还有有一些优点的。<br>所有泛型的动作都发生在边界（进入和离开泛型）处，对传进来值进行额外的编译器检查，对传出去的值进行额外的转型操作。</p>
<h2 id="擦除的补偿措施"><a href="#擦除的补偿措施" class="headerlink" title="擦除的补偿措施"></a>擦除的补偿措施</h2><p>由于编译时期的擦除，导致在运行时期无法获取到真正的类型信息，也就是说通过T获取到真正的.class文件（Class对象）。<br>因此如果是要执行一些需要检查Class对象的方法，就无法通过。譬如：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erased</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> T) &#123;&#125;<span class="comment">// Error</span></span><br><span class="line">        T var = <span class="keyword">new</span> T();<span class="comment">// Error</span></span><br><span class="line">        T[] array = <span class="keyword">new</span> T[SIZE];<span class="comment">// Error</span></span><br><span class="line">        T[] arrays = (T) <span class="keyword">new</span> Object[SIZE];<span class="comment">// Unchecked warning</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这些方法在初始化阶段需要使用到.class文件，但是因为擦除，找不到了。</p>
<p>补偿措施：</p>
<ol>
<li>通过构造器传入Class对象，使得可以获取到累类型信息，从而通过newInstance来创建一个对象。</li>
<li>使用ArrayList代替数组。</li>
</ol>
<p>一个比较奇怪的现象是：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">T var = (T)<span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure></p>
<p>这种情况编译器又是允许的，<strong>为什么？</strong></p>
<p>我的想法是，这其实等价于<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object var = (Object)<span class="keyword">new</span> String();</span><br></pre></td></tr></table></figure></p>
<p>依然是没有任何泛型的信息，所以是不会报错的。</p>
<h2 id="泛型和数组的协变性分析"><a href="#泛型和数组的协变性分析" class="headerlink" title="泛型和数组的协变性分析"></a>泛型和数组的协变性分析</h2><p>数组是协变的：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] obj[] = <span class="keyword">new</span> Integer[];</span><br></pre></td></tr></table></figure></p>
<p>泛型不是协变的：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Object&gt; oList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;()[];</span><br></pre></td></tr></table></figure></p>
<p>泛型的出现远晚于数组。</p>
<p><strong>为什么数组要设计成协变的？</strong></p>
<p>数组的协变性更加适应具有多态特性的编程。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">puilic boolen <span class="title">equle</span><span class="params">(Object[] objs1,Object[] objs2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(Object obj1:objs1)&#123;</span><br><span class="line">    <span class="keyword">for</span>(Object obj2:objs2)&#123;</span><br><span class="line">      <span class="keyword">if</span>(obj1.equel(obj2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面用数组作为参数的方法可以适用于所有的数组。</p>
<p><strong>为什么泛型不是协变的？</strong></p>
<p>协变性会破坏数组的安全性：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] obj[] = <span class="keyword">new</span> Integer[];</span><br><span class="line">obj[<span class="number">0</span>] = <span class="keyword">new</span> String();</span><br></pre></td></tr></table></figure></p>
<p>为了避免泛型出现这种安全性，因而将泛型设计成不协变的。（这里不分析由强制改变的任何协变关系，因为那是强转带来的问题。）</p>
<p>数组和泛型不能很好的共存，也是因为担心数组的协变性影响了泛型的非协变性：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt;[] lsa = <span class="keyword">new</span> List&lt;String&gt;[<span class="number">10</span>]; <span class="comment">// 假设这一步是可行的！！！</span></span><br><span class="line">Object[] oa = lsa;  <span class="comment">// OK because List&lt;String&gt; is a subtype of Object</span></span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">li.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));</span><br><span class="line">oa[<span class="number">0</span>] = li;</span><br><span class="line">String s = lsa[<span class="number">0</span>].get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p><strong>使用通配符的意义是？</strong></p>
<p>但是不协变写就意味着不支持多态的编程，而协变又会出现安全的问题，<strong>怎么办？</strong></p>
<p>通配符正是为了解决这个问题而出现的：<br>泛型通配符支持协变：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;? extends Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;()[];</span><br></pre></td></tr></table></figure></p>
<p>为了解决安全问题：什么都不让存！<br>因为取的话至少只能用Object来接受，是安全的，所以可以取。</p>
<p><strong>使用泛型和使用原生类型有什么区别？</strong></p>
<p>使用原生类型意味着兼容各种版本，因此会失去所有的编译时期检查，容器中的类型都是Object，也就不存在任何的限制了。</p>
<p>对于老版本的一些类库，必然存在使用原生类型作为参数的一些方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">oldStyleMethod</span><span class="params">(List probablyDogs)</span> </span>&#123;     </span><br><span class="line">  probablyDogs.add(<span class="keyword">new</span> Cat());   </span><br><span class="line">&#125;</span><br><span class="line">oldStyleMethod(<span class="keyword">new</span> ArrayList&lt;Dog&gt;());</span><br></pre></td></tr></table></figure>
<p>当我们传入泛型容器时，原生容器必然会破坏我们的泛型容器，<strong>怎么办？</strong></p>
<p>JAVA考虑到了这种问题，因此定义了一些可以防止破坏的容器（可以进行动态类型检查的容器）。</p>
<p>使用方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  oldStyleMethod(Collections.checkedList(<span class="keyword">new</span> ArrayList&lt;Dog&gt;(), Dog.class));   </span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样的还有checkedMap,checkedSet,checkedSortedMap,checkedSortedSet。</p>
<h2 id="使用泛型会出现哪些问题？"><a href="#使用泛型会出现哪些问题？" class="headerlink" title="使用泛型会出现哪些问题？"></a>使用泛型会出现哪些问题？</h2><ol>
<li>基本类型并不能作为类型参数</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;<span class="keyword">int</span>&gt;</span><br></pre></td></tr></table></figure>
<p><strong>可以代码中依然可以看到ArrayList&lt;int>这样的写法，为什么？</strong></p>
<p>这是由于 JAVA的自动包装机制，实际上自动转换成ArrayList&lt;Integer><br>由于自动包装机制或多或少会影响一点性能，如果考虑性能问题，就需要使用一些其他的一些开源的适用于基本类型的容器版本。</p>
<p><strong>自动包装机制解决所有问题了吗？</strong></p>
<p>并没有，自动包装机制并不会应用到数组上，所以使用int i来遍历Integer的数组的时候会出错。</p>
<ol start="2">
<li>不能实现同一类型参数接口的两个变体</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Payable</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Payable</span>&lt;<span class="title">Employee</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hourly</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Payable</span>&lt;<span class="title">Hourly</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这样有什么问题吗？</strong></p>
<p>一旦基类指定了某个特定的泛型接口，它的子类都必须实现同样的接口。<br>一个问题的场景是：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparablePet</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ComparablePet</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ComparablePet arg)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>pet能和其它的pet比<br>但是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ComparableCat extends ComparablePet implements Comparable&lt;ComparableCat&gt;</span><br></pre></td></tr></table></figure>
<p>上诉代码无法编译<br>但是pet的子类cat也是和其它的pet比（应该只能和其它cat比才对）</p>
<ol start="3">
<li>使用带有泛型类型参数的实例类型强制转换不会产生任何效果。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Shape&gt; shapes = (List&lt;Widget&gt;)in.readObject();</span><br></pre></td></tr></table></figure>
<p><strong>why?</strong><br>因为泛型参数会被擦除到边界，最终无法得知它具体的类型，即便强转也只能到边界，而无法得知本质的类型，因此会得到一个警告。</p>
<ol start="4">
<li>使用不同泛型类型参数的类型来重载方法无法编译</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseList</span>&lt;<span class="title">W</span>,<span class="title">T</span>&gt; </span>&#123;   </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(List&lt;T&gt; v)</span> </span>&#123;&#125;   </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(List&lt;W&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>why?</strong>`<br>因为擦除，不同泛型类型参数的类型在重载时会被认为没有任何区别。</p>
<h2 id="自限定的类型"><a href="#自限定的类型" class="headerlink" title="自限定的类型"></a>自限定的类型</h2><p>在上面，我们遇到过一种情况：自定义的一个类，继承了一个基类，与此同时，这个基类的类型参数是这个自定义的类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ComparablePet implements Comparable&lt;ComparablePet&gt;</span><br></pre></td></tr></table></figure>
<p>这是个<strong>循环泛型</strong>，<strong>如何理解这个现象？</strong><br>先看一个简单的版本：</p>
<p><strong>上诉基类为什么要把自定义的类（这里称为派生子类）作为类型参数值？</strong></p>
<p>首先我们知道JAVA中的泛型和参数类型和返回类型相关。<br>这样做的好处是可以将派生类作为基类方法的参数类型或者返回类型，又或者字段的类型，即便他们都将会被擦除为Object。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicHolder</span>&lt;<span class="title">T</span>&gt; </span>&#123;   </span><br><span class="line">  T element;   </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">    element = arg;</span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="function">T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    System.out.println(element.getClass().getSimpleName());   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是一个普通的泛型，我们将派生类来作为类型参数T使用。<br>接着再来分析那个古怪的循环有何用意。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subtype</span> <span class="keyword">extends</span> <span class="title">BasicHolder</span>&lt;<span class="title">Subtype</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CRGWithBasicHolder</span> </span>&#123;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     </span><br><span class="line">    Subtype st1 = <span class="keyword">new</span> Subtype();</span><br><span class="line">    Subtype st2 = <span class="keyword">new</span> Subtype();     </span><br><span class="line">    st1.set(st2);     </span><br><span class="line">    Subtype st3 = st1.get();     </span><br><span class="line">    st1.f();   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要理解的是：子类继承了基类中的方法和字段，但是<em>这些方法的参数和返回类型是子类</em>，这使得基类称为一个所有子类的公共模板，重点是这些模板的返回和参数是派生子类！<br>这便是CRG的本质：<em>基类使用派生类作为参数</em></p>
<p>从上面我们可以看出，BasicHolder&lt;T>中的T可以是任意的类型，这说明会出现这样的情况：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Other</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicOther</span> <span class="keyword">extends</span> <span class="title">BasicHolder</span>&lt;<span class="title">Other</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这表示当前派生类使用了其它的类的模板，这一般没有什么意义。</p>
<p><strong>为了不让上面的情景发生，我们能怎么做？</strong></p>
<p>给类型参数加一个边界，使得类型参数不能是任意的类型。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicHolder</span>&lt;<span class="title">T</span> <span class="title">extent</span> <span class="title">Other</span>&gt; </span>&#123;   </span><br><span class="line">  T element;   </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">    element = arg;</span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="function">T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    System.out.println(element.getClass().getSimpleName());   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>即便这样还是可能使用了其它具有共同基类Other的类的模板。</p>
<p><strong>加怎样的一个边界比较合适呢？</strong></p>
<p>有时候会可看到这样的一种比较奇怪的情况，但是也是最常用的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span>&gt;&gt;</span></span><br><span class="line"><span class="class"></span>&#123;   </span><br><span class="line">  T element;   </span><br><span class="line">  <span class="function">SelfBounded&lt;T&gt; <span class="title">set</span><span class="params">(T arg)</span> </span>&#123;     </span><br><span class="line">    element = arg;     </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;   </span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="function">T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种奇怪的写法叫做自限定。</p>
<p><strong>自限定的泛型怎么使用？</strong></p>
<p>自限定规定了我们使用的类必须具有下面的继承形式：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>一般只会用到第一种形式，像下面的这种用法就会出错：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">B</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为B的基类并不是SelfBounded&lt;B></p>
<p>然而这里还有一点点小小的问题，如果这样使用：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>是可行的。如果需要强制使用泛型，需要额外的工具。</p>
<p><strong>自限定有什么意义吗？</strong></p>
<p><em>新创建的类使用到的基类模板的参数类型只能是自己</em>，或者是有相同的基类（不常用）。<br>这就防止了当前派生类使用到了其它类的模板的情况。</p>
<p><strong>自限定除了可以用在类上，还可以用在别的地方吗？</strong></p>
<p>还可以用在静态方法上，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBoundingMethods</span></span></span><br><span class="line"><span class="class"></span>&#123;   </span><br><span class="line">  <span class="keyword">static</span> &lt;T extends SelfBounded&lt;T&gt;&gt; <span class="function">T <span class="title">f</span><span class="params">(T arg)</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">return</span> arg.set(arg).get();   </span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     </span><br><span class="line">    A a = f(<span class="keyword">new</span> A());  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样限定了可以使用这个静态方法的类型。</p>
<h2 id="参数协变"><a href="#参数协变" class="headerlink" title="参数协变"></a>参数协变</h2><p>参数类型协变是泛型模板的一个应用。</p>
<p><strong>什么是参数类型协变？</strong></p>
<p>方法的参数类型会随着子类变化。<br>注意，这不是重载。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重载:B中有两个同名的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Integer <span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数协变:在子类中的方法参数可以更加具体</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Setter</span> <span class="keyword">extends</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">Setter</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法set的参数会随着子类而变化</p>
<p><strong>为什么要用自限定的泛型，用一般的泛型不行吗？</strong></p>
<p>参考之前自限定的意义既能理解了。</p>
<p><strong>我们说过泛型关乎参数类型和返回类型，为什么没有返回类型协变？</strong></p>
<p>首先，返回类型协变没那么重要，其次，因为JAVA5之后支持返回类型协变。</p>
<p><strong>什么是返回类型协变？</strong></p>
<p>先回忆什么是覆盖（重写）：子类重新定义父类中的方法，参数和返回类型都一致就叫重写。<br>然而这个要求是在JAVA5之前的，JAVA5之后支持返回类型协变，可以让返回类型不一致。<br>在面向对象的编程语言中，返回类型协变指的是<em>子类中的成员函数的返回值类型不必严格等同于父类中被重写的成员函数的返回值类型，而可以是更 “狭窄” 的类型</em>。</p>
<p><strong>泛型如何支持参数类型协变？</strong></p>
<p>使用如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Setter</span> <span class="keyword">extends</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">Setter</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">A</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfBoundingAndCovariantArguments</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testA</span><span class="params">(Setter s1, Setter s2, SelfBoundSetter sbs)</span> </span>&#123;</span><br><span class="line">        s1.set(s2);     </span><br><span class="line">        <span class="comment">// s1.set(sbs); // Error:set(Setter) in SelfBoundSetter&lt;Setter&gt; cannot be applied to (SelfBoundSetter)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Setter会把类型参数T给覆盖，Setter变成其他类之后，相应的参数类型也会改变。</p>
<h2 id="混型"><a href="#混型" class="headerlink" title="混型"></a>混型</h2><p>就是一个类混合了多个类的能力。<br>C++中可以用多重继承和继承泛型实现<br>当想在混型类中修改某些东西，这些修改会应用于混型的所有类型上。</p>
<p>JAVA的这两种方式都不支持。JAVA的实现方法：</p>
<ol>
<li>使用接口，问题是接口中的方法都需要手动实现。</li>
<li>使用装饰器，问题是只有最后一个装饰类中的方法可见。</li>
<li>使用动态代理，弥补了第一个方法中的手动实现问题。</li>
</ol>
<h2 id="潜在类型机制"><a href="#潜在类型机制" class="headerlink" title="潜在类型机制"></a>潜在类型机制</h2><p><strong>什么是代码的“泛化”？</strong></p>
<p>代码的“泛化”意思是编写 无需修改就可以应用于更多情况的代码。<br>具体点说就是一段代码，不需要关心它的类型，只要类型符合这段代码的要求（比如参数的类型具有特定的方法），就可以使用，这一段代码就可以用在很多地方，实现“泛化”。<br>为了实现跨类型的代码，注意这不是实现同一个接口，某些编程语言提供的一种解决的思想是称为“潜在类型机制”。</p>
<p><strong>什么是潜在类型机制？</strong></p>
<p>两个完全不同的类，不需要继承同一个父类或者实现同一个接口，能在同一段代码中编写能够同时运用于这两个类的代码，只要实现了某个方法子集，程序就允许执行，这种机制就是潜在类型机制，这是一个编程语言的思想。<br>python和c++都可以支持潜在类型机制，前者是动态类型检查（类型检查发生在运行时期），因而运行时转换为具体的类型。后者是静态类型检查（发生在编译时期），编译时转换为具体的类型。<br>类型检查是语言的一个功能，可以帮我们避免类型错误。</p>
<p><strong>使用JAVA泛型不能支持潜在类型机制吗？</strong></p>
<p>由于擦除的存在，JAVA的泛型和C++的不一样，属于“第二类泛型类型”。所有的具体类型在之后会被擦除为Object类型，无法拥有特定的方法，因而不支持潜在类型机制。<br>当然，我们的确可以使用带有边界限制的泛型来实现潜在类型机制，但是这样的方式完全可以使用继承类型和实现接口来替代了，也就没有什么意义。</p>
<h2 id="对泛型缺乏潜在类型机制的补偿"><a href="#对泛型缺乏潜在类型机制的补偿" class="headerlink" title="对泛型缺乏潜在类型机制的补偿"></a>对泛型缺乏潜在类型机制的补偿</h2><p><strong>JAVA能通过其它方式来支持潜在类型机制吗？</strong></p>
<p>然而，可喜可贺！使用反射可以实现！<br>如何实现，看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mime</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Mime sit"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Mime speak"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Mime"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Robot speak"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Robot"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommunicateReflectively</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; oc = object.getClass();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method speak = oc.getMethod(<span class="string">"speak"</span>);</span><br><span class="line">                speak.invoke(object);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                System.out.println(object + <span class="string">" can't speak"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method sit = oc.getMethod(<span class="string">"sit"</span>);</span><br><span class="line">                sit.invoke(object);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                System.out.println(object + <span class="string">" can't sit"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LatenReflection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CommunicateReflectively.perform(<span class="keyword">new</span> Robot());</span><br><span class="line">        CommunicateReflectively.perform(<span class="keyword">new</span> Mime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管这样做可以实现，但是这样处理类型检查是在运行时期，</p>
<p><strong>运行时检查的缺陷是？</strong></p>
<ol>
<li>增加了程序运行时间，影响了效率；</li>
<li>需要数据具有类型标志；</li>
<li>错误发现太晚，不能防止运行错的出现。</li>
</ol>
<p><strong>有可能使类型检查在编译时期吗？</strong></p>
<p>要想实现编译时期类型检查，最直观的想法是运用泛型。<br>但是JAVA的泛型并不支持潜在类型机制。<br>如果使用带有边界的泛型（支持潜在类型机制），之前也说过是没有意义的，因为如果泛型带有边界，还不如用接口和继承来代替。</p>
<p>当然还有其他的一些弥补方式。</p>
<blockquote>
<p>关于混型和潜在类型机制仅作了解，以后有需求再进一步学习</p>
</blockquote>
]]></content>
      <categories>
        <category>Thinking in Java 读书笔记</category>
      </categories>
      <tags>
        <tag>JAVA编程思想</tag>
        <tag>Thinking in JAVA</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络自顶向下：第三章-传输层</title>
    <url>/2019/03/08/cmpNet/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0-%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="传输层的介绍"><a href="#传输层的介绍" class="headerlink" title="传输层的介绍"></a>传输层的介绍</h2><p>传输层提供应用进程间的逻辑通信</p>
<p><strong>应用进程间的逻辑通信作何解？</strong></p>
<p>从应用进程的角度看，两台相隔两岸的计算机中的进程，通过传输层，就好似直接连接起来进行交流一般，对于底层的路由、链路都是透明不可见的。</p>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/1.png" alt="传输层"></p>
<h3 id="传输层和网络层的联系"><a href="#传输层和网络层的联系" class="headerlink" title="传输层和网络层的联系"></a>传输层和网络层的联系</h3><p>和传输层相比，网络层提供主机之间的逻辑通信，区别是细微的，但十分重要。</p>
<p>传输层作为终端特殊的一部分，功能是收集整理应用层的消息(message)，加入传输头成为(segment)。<br>真正负责在网络中传输的是网络层的职责。</p>
<p>举个例子：传输层好比一个村的村长，专门收集/发放村民们的邮箱，而网络层才是真正的邮递员。</p>
<p>网络层的功能会影响传输层的功能，譬如带宽<br>传输层也可以提供网络层无法提供的额外的功能，譬如可靠传输、加密等。</p>
<p>传输层协议的代表：TCP/UDP<br>网络层协议的代表：IP</p>
<h3 id="传输层概况"><a href="#传输层概况" class="headerlink" title="传输层概况"></a>传输层概况</h3><p><strong>传输层的意义？</strong></p>
<p>IP协议提供网络中每一个主机的逻辑通信，因而每一个主机都至少具有一个IP。<br>IP协议是一个尽力的服务，意味着提供最大可能的通信，尽管如此，它依然无法担保。如segment的顺序，segment的完整性。<br>因而传输层拓展了网络层的服务</p>
<p><strong>拓展了哪些服务？</strong></p>
<p>提供了完整性检查的功能<br>数据传输服务和完整性检查服务是最小的传输层服务，也是UDP仅仅提供的两个服务。因而UDP也是不可靠服务。<br>而TCP提供了可靠数据传输和阻塞控制的服务。</p>
<p>另外，传输层协议将主机间的通信拓展为主机中进程间的通信，这种拓展称为传输层多路复用和多路分解。</p>
<h2 id="多路复用和多路分解"><a href="#多路复用和多路分解" class="headerlink" title="多路复用和多路分解"></a>多路复用和多路分解</h2><p><strong>什么是多路复用和多路分解？作用是什么？</strong></p>
<p>将主机间的通信拓展为主机中进程间的通信，关键就在于<em>如何定位计算机中的进程？</em><br>网络层协议(IP)定位计算机，因而传输层协议（TCP/UDP）需要做的就是去定位进程，为此计算机为每一个进程提供一个端口号(port)，而应用层和传输层之间通过一个抽象的门（套接字）进行数据的传输，所以传输层协议的作用就是定位套接字。</p>
<ul>
<li>多路分解：将传输层报文段中的数据定位到正确的套接字。</li>
<li>多路复用：从不同的套接字收集源主机上的数据块，用头信息封装每个数据块(稍后将用于解复用)以创建段，并将这些段传递到网络工作层。<br>但是无连接（UDP）的多路复用和多路分解又和有连接(TCP)的不一样，举例说就是门牌号的定位方式不一样。</li>
</ul>
<p><strong>无连接（UDP）的多路复用和多路分解？</strong></p>
<p>创建UDP套接字的java代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DatagramSocket mySocket = <span class="keyword">new</span> DatagramSocket();<span class="comment">//随机分配端口号</span></span><br><span class="line">DatagramSocket mySocket = <span class="keyword">new</span> DatagramSocket(xxxx);<span class="comment">//指定端口号</span></span><br></pre></td></tr></table></figure></p>
<p>UDP套接字通过(目标IP,目标端口号)（二元）进行定位，因而两个不同来源的UDP报文可以定位到相同的目的进程。</p>
<p><strong>有连接（TCP）的多路复用和多路分解？</strong></p>
<p>创建TCP套接字的java代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Socket clientSocket = <span class="keyword">new</span> Socket(<span class="string">"hostname"</span>,portNumber);</span><br></pre></td></tr></table></figure></p>
<p>TCP套接字通过(源IP,源端口号,目标IP,目标端口号)（四元）进行定位</p>
<blockquote>
<p>套接字有时候和线程是对应的</p>
</blockquote>
<h2 id="无连接传输——UDP"><a href="#无连接传输——UDP" class="headerlink" title="无连接传输——UDP"></a>无连接传输——UDP</h2><p>UDP所提供的服务是非常极简的，使用UDP进行传输，几乎就等于使用IP进行传输。<br>传输前也不需要做多余的准备工作，因而说UDP是无连接的。<br>使用UDP的案例——DNS</p>
<p><strong>为什么还有使用UDP协议，而不是更好的TCP协议的应用？</strong></p>
<ol>
<li>提高实时性：由于TCP具有阻塞控制，因而使用TCP往往存在一定的延迟。如果希望提高实时性，并且可以容忍一些数据的丢失，可以使用UDP。</li>
<li>减少时延：如果大量的数据都需要进行三次握手，必然会导致较高的时延。</li>
<li>无连接状态：TCP需要维护连接状态（接受/发送缓存，阻塞控制参数，序列号和确认号参数，流量控制参数等）。然而，使用UDP能支持更多的活动。</li>
<li>头信息开销小：每一个TCP报文头有20字节，而UDP只有8字节。</li>
</ol>
<h3 id="UDP报文结构"><a href="#UDP报文结构" class="headerlink" title="UDP报文结构"></a>UDP报文结构</h3><p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/2.png" alt="UDP报文结构"></p>
<ul>
<li>checksum：校验UDP报文的数据正确性</li>
<li>length：报文长度（头+数据）</li>
</ul>
<p><strong>为什么数据的校验要放在传输层？</strong></p>
<p>这是一个被人提倡的端到端原则（end-end princeple）——由于某些功能必须基于端到端来实现，因而在底层实现这些功能是冗余而无意义的。</p>
<h2 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h2><p>在学习TCP协议前，先学习一些可靠数据传输原理。</p>
<blockquote>
<p>一般来说，传输层下面的协议都是不会实现可靠传输的，因为难度较大。所以这里讨论的可靠传输协议建立在底层不可靠的传输上。另外，便于分析，只讨论单向数据传输，双向数据传输实际上并不会增加过多的难度。</p>
</blockquote>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/3.png" alt="可靠数据传输模型"></p>
<h3 id="构造可靠数据传输协议"><a href="#构造可靠数据传输协议" class="headerlink" title="构造可靠数据传输协议"></a>构造可靠数据传输协议</h3><p>接下来将会循序渐进的开始学习：</p>
<p><strong>如果底层是可靠传输？</strong></p>
<p>rdt1.0：完全可靠信道上的可靠数据传输<br>最简单的情况，底层信道是可靠传输，传输层基本不需要做任何其余的处理。<br>用有穷状态机（FSM）表示请求端和接收端：<br>FSM中圆圈表示所处的状态，线段表示触发状态变化的动作。</p>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/4.png" alt="rdt1.0"></p>
<p><strong>如果底层信道不可靠，如何确保消息准确无误的被接受到？</strong></p>
<p>rdt2.0：接收方采取确认（ACK）和否认(NAK)的方式回复。</p>
<p>实现确认和否认的功能需要三个额外的协议：</p>
<ol>
<li>差错检查：检查是否出错（使用校验和）</li>
<li>接收方反馈：需要约定反馈信息（如0表示NAK，1表示ACK）。</li>
<li>重传：什么情况下进行重传(如出错后进行重传)</li>
</ol>
<p>rdt2.0的FSM如下：</p>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/5.png" alt="rdt2.0"></p>
<p>但是，问题来了，<strong>如果接收方回复的消息在回传的过程中损坏（仅仅是损坏，之后无法确认）了呢？</strong><br>有3中可能能够解决的方案：</p>
<ol>
<li>发送方收到损坏的回复，无法判断是ACK还是NAK，这时候定义一个新类型分组（相当于请重复一遍），当接收方收到这个特殊的分组，就会重发一次确认消息。但是这样下来，又需要确认这个特殊的分组会不会又损坏，子子孙孙麻烦不断。</li>
<li>增加足够的校验和比特，使得发送发不仅可以检查出错误，还可以恢复错误。</li>
<li>发送方把数据分组重新发送一次，但是这样问题是接收方需要判断这个数据分组是一个新的分组还是一个重复的分组（冗余分组）。                 了                                                                                                                                                                                                                                                                                                                                                                                                               </li>
</ol>
<p>一般是采用第3个方案，所以问题来到：<strong>如何判断这个数据分组是一个新的分组还是一个重复的分组（冗余分组）？</strong></p>
<p>新增一个flag——sequence number（序号）字段：前后两个消息seq一样，表示是重复消息，seq不一样表示是新的消息。<br>对于等停协议（确认一个后再发送下一个），1bit的seq足矣。</p>
<p>rdt2.1的FSM如下：</p>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/6.png" alt="rdt2.1sender"></p>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/7.png" alt="rdt2.1receiver"></p>
<p>另外，当消息损坏，接收方发送NAK来告诉发送方。这一步也可以通过发送之前成功的ACK来告诉发送方最近一次的成功记录，间接操作。这就需要在ACK中加入消息的序号。如此一来，便有了rdt2.2：</p>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/8.png" alt="rdt2.2sender"></p>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/9.png" alt="rdt2.2receiver"></p>
<p>接下来，<strong>如果消息不是损坏，而是在传输的过程中丢失了呢？（丢包现象）</strong></p>
<p>rdt3.0：采用发送端超时重传机制</p>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/10.png" alt="rdt3.0sender"></p>
<p>配合时间设定需要一个定时器：完成如下功能：</p>
<ol>
<li>发送消息时启用定时器</li>
<li>响应定时器中断</li>
<li>终止定时器</li>
</ol>
<p>另外，超时重传的时间长度是一个比较重要的设置因素，首先至少需要一个消息的往返时间+接收端处理消息的时间，而太长又会导致时延增加，之后的章节会进一步讨论。</p>
<h3 id="流水线可靠传输协议"><a href="#流水线可靠传输协议" class="headerlink" title="流水线可靠传输协议"></a>流水线可靠传输协议</h3><p>之前提到的rdt3.0协议，从可靠性来说已经足够了，但是rdt是一个等停协议，意思就是要等一个分组确认了之后才发送下一个分组，那么确认一个分组可能需要10ms，但是发送一个分组可能只需要1us，那么这是信道的利用率是非常低的，一个完整的文件在这种协议下可能耗时就会比较久。</p>
<p>改善的方式是采用流水线可靠传输协议</p>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/11.png" alt="流水线可靠传输协议"></p>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/12.png" alt="等停协议VS流水线协议"></p>
<p>实现流水线协议需要拓展3个方面的技术：</p>
<ol>
<li>要增加seq序号的范围（比如增加seq的位数）：管道中的分组都得有一个唯一的标识。</li>
<li>实现缓存：发送方需要缓存已发送但未确认的分组，接受方要缓存已经成功确认的分组。</li>
<li>丢包，损坏，延时的处理方式，序号的范围和缓存的内容也取决于这个方式，两种常用的方式是：GBN（Go-Back-N）和选择重传（selective repeat）</li>
</ol>
<h4 id="GBN协议"><a href="#GBN协议" class="headerlink" title="GBN协议"></a>GBN协议</h4><p><strong>GBN协议和RDT有什么不同？</strong></p>
<p>序号范围增加后，在序号范围内，发送方可以同时发送N个分组</p>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/13.png" alt="GBN发送方视角"></p>
<p>N是窗口的长度<br>base表示最早的未被确认的序号<br>nextseqnum表示最小的可以使用序号<br>window size是可以使用的序号范围,也叫做窗口</p>
<p>随着协议的运行，窗口在序号空间内移动，因此GBN协议也叫做滑动的窗口协议</p>
<p><strong>为什么N不能是无限呢？</strong></p>
<p>受流量控制和拥塞控制的限制，之后会具体学习。</p>
<p><strong>GBN协议的工作原理？</strong></p>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/14.png" alt="GBN协议发送方FSM"></p>
<p>sender FSM响应动作分析：</p>
<ol>
<li>响应上层调用：当窗口未满时，才创建新的分组并发送。</li>
<li>响应确认消息：接收方<em>累积确认</em>的作用——接受序号n的ACK后，确认n之前所有的分组，更新窗口。</li>
<li>响应超时：如果出现超时，发送base后所有的分组。计时器是窗口共享的，收到ACK，重启计时。如果没有未确认的分组，终止计时。</li>
<li>对于错误的分组不作任何处理，等待超时。</li>
</ol>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/15.png" alt="GBN协议接受方FSM"></p>
<p>recevier FSM响应动作分析：</p>
<ol>
<li>响应接受：累积确认——如果接受的分组序号是希望的序号n，则回复序号n的ACK。</li>
<li>其余情况：重传上一次(n-1)的ACK。</li>
</ol>
<p>GBN协议问题在于：</p>
<ol>
<li>出现超时，发送base后所有的分组。单个分组的差错会引起大量分组的重传，导致信道中出现大量重复的分组。</li>
<li>丢弃所有失序的正确分组很蠢和浪费。</li>
</ol>
<p>因此有SR协议。</p>
<h4 id="selective-repeat协议"><a href="#selective-repeat协议" class="headerlink" title="selective repeat协议"></a>selective repeat协议</h4><p><strong>SR协议和GBN有什么不同？</strong></p>
<p>发送方选择发送错误或者丢失的分组，接受方选择确认正确接受的分组。<br>对于发送方和接收方，都会维护各自的窗口。</p>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/16.png" alt="SR协议发送方和接收方序号视角"></p>
<p>base确认后移动到下一个未确认的分组处，窗口的移动看起来是跳跃的。</p>
<p><strong>SR协议的工作原理？</strong></p>
<p>sender响应动作分析：</p>
<ol>
<li>响应上层调用：和GBN一致。</li>
<li>响应ACK消息：接收方<em>选择确认</em>的作用——ACK分组如果在窗口内，标记为已确认。base确认后窗口移动到下一个未确认的分组处。</li>
<li>响应超时：<em>选择重发</em>——计时器是分组独享的。超时重传一个分组。</li>
<li>对于错误的分组，和GBN一致。</li>
</ol>
<p>recevier FSM响应动作分析：</p>
<ol>
<li>响应接受窗口内的分组：<em>选择确认</em>——正确接受的分组序号在窗口内，回复序号n的ACK，并且标记为已确认，并且缓存起来。等base分组被确认后，将base之后所有分组一并交付给上层。</li>
<li>响应接受窗口前的分组：如果序号在base分组的前N个，依然需要产生一个当前序号的ACK。</li>
<li>其余情况：忽略。</li>
</ol>
<p><strong>接收方第二步的意义何在？</strong></p>
<p>产生这一步的原因是<em>发送方的窗口和接收方的窗口不同步</em>。<br>比如发送方的窗口是3,4,5,6；接收方的窗口是7,8,9,10.这种情况是可能的。</p>
<p>除此，还有一种情况是，序号的范围只有0,1,2,3，因而发送方的窗口是0,1,2；接收方的窗口是3,0,1。这种情况下第二步就无法确认重发的序号为0的分组是重复的还是新发的了。</p>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/17.png" alt="窗口太大的问题：重发还是新发"></p>
<p>经计算，窗口的长度必须小于、等于序列号的一半</p>
<h2 id="TCP可靠传输协议"><a href="#TCP可靠传输协议" class="headerlink" title="TCP可靠传输协议"></a>TCP可靠传输协议</h2><h3 id="TCP的相关概念"><a href="#TCP的相关概念" class="headerlink" title="TCP的相关概念"></a>TCP的相关概念</h3><ol>
<li>TCP是面向连接的，<strong>如何理解“连接”是什么意思？</strong>：意味着在TCP数据传输前，先发送某些预备报文，以建立确保数据传输所需的参数。这个连接是抽象的，只存在传输层。</li>
<li>TCP从其它层接受到的报文并不会立即处理，而是先缓存起来，在合适的时间处理。</li>
<li>MTU（maximum transmission unit）:链路层最大帧长度。受MTU影响，TCP报文也有最大的传输报文长度(maximum segment size(MSS)，不包括头)</li>
</ol>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/18.png" alt="TCP缓存机制"></p>
<h3 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h3><p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/19.png" alt="TCP报文结构"></p>
<ul>
<li>源端口号和目的端口号：多路复用和多路分解。</li>
<li>检验和：检查错误</li>
<li>4字节的seq和4字节的ack：可靠传输</li>
<li>2字节接受窗口：流量控制</li>
<li>4位的头长度：指示头的长度（以2字节的字为单位）</li>
<li>选项字段：协商MSS和调节窗口</li>
<li>6Bit的标志字段：具体在后文根据功能讨论</li>
</ul>
<h3 id="可靠传输实现"><a href="#可靠传输实现" class="headerlink" title="可靠传输实现"></a>可靠传输实现</h3><p>和之前的传输协议一样，TCP也具有seq,ack,超时重传等原理。但是采取的方式又有不同：</p>
<p><strong>seq和ack的工作方式？</strong></p>
<ul>
<li>seq：seq是无结构还是有序的，选用报文中数据的第一个字节作为seq。</li>
<li>ack：接收端返回ack是<em>下一个期望从发送端接受到的下一个字节，即下一个报文的seq</em></li>
</ul>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/20.png" alt="TCP报文段字节"></p>
<p><strong>如何确定超时间隔？</strong></p>
<p>超时时间不能太长，也不能太短，至少要大于一个TCP消息的往返时间(RTT，报文段发出到确认的时间)</p>
<p><strong>如何估计往返时间？</strong></p>
<p>在某个任意时刻，记录一个报文发送到接受的样本RTT时间(SampleRTT),然后取指数加权移动平均：<br>EstimatedRTT = (1 – a) • EstimatedRTT + a • SampleRTT<br>a的参考值是0.125</p>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/21.png" alt="RTT往返时间"></p>
<p>除此，还会计算SampleRTT偏离EstimatedRTT的程度：<br>DevRTT = (1 –b) • DevRTT + b •| SampleRTT – EstimatedRTT |<br>b的参考值是0.25</p>
<p><strong>如何设置超时间隔？</strong></p>
<p>要求超时时间设置为EstimatedRTT加上一定余量：当SampleRTT波动较大，这个余量较大，当SampleRTT波动较小，这个余量较小。因此DevRTT起作用了：<br>TimeoutInterval = EstimatedRTT + 4 • DevRTT</p>
<p><strong>TCP响应事件？</strong></p>
<p>TCP传输协议和之前学到的几个协议有着大致相同的原理：</p>
<ol>
<li>从应用层接受数据：封装层报文，并发送，启动计时器。</li>
<li>超时：重发，重启计时器。</li>
<li>接受ACK：累积确认。</li>
</ol>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/22.png" alt="TCP协议简化的发送方"></p>
<p><strong>和之前的传输原理相比，TCP长期使用以来积累的微妙改动？</strong></p>
<ol>
<li>虽然是类似GBN的累积确认，但是TCP在超时后，只会重发未确认的最小序号的报文，而不会这之后的报文，大大减少了重发报文的数量。</li>
<li>当发生超时的时候，下一次的超时时间会被设置为两倍，而不是之前的结论。这种改动提供了一个简单的 拥塞控制，超时很有可能是因为网络拥塞，而该机制会减少重发的频率来缓解拥塞。</li>
<li>快速重传：之前的重传都是建立在超时的基础上的，但是有可能就是超时的间隔时间相对较长。TCP一个巧妙的解决方案是，当接受到三次重复确认的ACK时（冗余ACK），就立即重发，不再等待超时。</li>
</ol>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/39.png" alt="快速重传"></p>
<p><strong>TCP是一个GBN还是SR？</strong></p>
<p>从累积确认的方式来看，更像是一个GBN协议，但是像上面提到的一样，也是有区别的。<br>对TCP提议的一种修改是选择确认，这时候就更像是一个SR协议。</p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p><strong>流量控制的作用是什么？</strong></p>
<p>接受段的缓存是有限的，为了不让消息溢出，应该控制发送端发送数据的速度，这就是流量控制。</p>
<p><strong>如何进行流量</strong></p>
<p>TCP报文头中有一个RcvWindow变量来记录剩余缓存空间：</p>
<ul>
<li>LastByteRead：已读的最后一个字节</li>
<li>LastByteRcvd：接受到的最后一个字节<br>rwnd = RcvBuffer – [LastByteRcvd – LastByteRead]</li>
</ul>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/23.png" alt="RcvWindow"></p>
<p>当rwnd为0时，发送端依然会持续发送一个只有一个字节的报文来刷新缓存空间。</p>
<blockquote>
<p>UDP并不提供流量控制，因此很容易出现溢出的情况。</p>
</blockquote>
<h3 id="TCP连接建立"><a href="#TCP连接建立" class="headerlink" title="TCP连接建立"></a>TCP连接建立</h3><p>“握手”过程：</p>
<ol>
<li>发送一个特殊的报文（SYN报文）——不含数据，SYN标记位被置为1，随机初始化一个起始序号（client_isn）。</li>
<li>SYN报文到达接受方，开始分配缓存和变量，之后回复一个特殊的报文（SYNACK报文）——不含数据，SYN标记位被置为1，随机初始化一个起始序号（server_isn），ack为client_isn+1。</li>
<li>接收到SYNACK报文，分配缓存和变量。之后发送另外一个报文段——可以含数据，SYN被置为0，ack为server_isn+1。<br>握手的过程就是初始化变量的过程。</li>
</ol>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/24.png" alt="握手"></p>
<p>挥手过程：</p>
<ol>
<li>任意一方A发送特殊报文（FIN报文）——FIN标志位置为1 。</li>
<li>另一方B接收到FIN报文，回复ACK报文。A接收到ACK后清理缓存和变量。</li>
<li>B一段时间后发送FIN报文</li>
<li>A接受到FIN报文，回复ACK报文。B接收到ACK后清理缓存和变量。</li>
<li>A等待一段时间，确认ACK报文被接收到后关闭。</li>
</ol>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/25.png" alt="挥手"></p>
<p>客户端连接状态：</p>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/26.png" alt="客户端状态"></p>
<p>服务端连接状态：</p>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/27.png" alt="服务端状态"></p>
<p><strong>为什么挥手需要四次？</strong></p>
<p>因为可以同时开始，但是不能同时结束，因为要等一方的所有报文发送完。</p>
<p><strong>为什么是三次握手而不是两次握手？</strong></p>
<p>为了使初始seq达成一致，需要一方发送，一方确认并发送，一方确认。</p>
<p><strong>为什么需要初始化序列？</strong></p>
<p>为了尽量减少在网络中出现重复的序列号</p>
<h2 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h2><p>在实际中，分组的丢失往往是因为网络拥塞，重传只是一种丢失后的补救措施。但是无法从根本上解决网络拥塞的问题。<br>之前说到的TCP中减少重传的频率是一个简单的减缓网络拥塞的方法。</p>
<h3 id="拥塞原因和开销"><a href="#拥塞原因和开销" class="headerlink" title="拥塞原因和开销"></a>拥塞原因和开销</h3><p><strong>为什么会出现网络拥塞呢？</strong></p>
<p>往往是因为信道上的消息太多，就和高速公路上的车太多了一样，用专业术语描述就是：<br>当吞吐量达到链路容量（也就是带宽）的时候，就会发生网络拥塞。</p>
<p><strong>网络拥塞会有怎样的影响？</strong></p>
<p>场景1：路由器的缓存无限大</p>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/28.png" alt="场景1"></p>
<p>最直接的影响就是堵车，也就是所谓的<em>排队时延增加</em>。</p>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/29.png" alt="场景1结论"></p>
<p>场景2：路由器的缓存有限</p>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/30.png" alt="场景2"></p>
<ol>
<li>多余的车被丢弃，也就是所谓的<em>丢包</em>。</li>
<li>由于超时重传机制，导致传输的分组<em>部分是原始数据，部分是重传数据（传过去不会被丢弃）。</em></li>
<li>再进一步，由于时延过大，有些数据并不是丢弃了，而是往返时间大于超时间隔，这时候导致的<em>重传数据是无用重传数据，传过去也会被丢弃。</em></li>
</ol>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/31.png" alt="场景2结论"></p>
<p>场景3：路过多个路由器</p>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/32.png" alt="场景3"></p>
<p>路由器好比一个阀，同样的发车速率的情况下，已经路过阀的车流量相比没有路过阀的车流量占比肯定要小。<br>随着发车速率的增加，已经路过阀的车流量路过第二个阀后将会趋于0，同理，这一部分占比较大的车流量在路过下一个阀之后也会被压榨至0。<br>这样，所有被第一个路由器处理的占比较大的数据报文，在之后都会被丢弃，因而只是做无用功。</p>
<p>当一个分组沿一条路径被丢弃时，每个上游路由器由于转发改分组而后被丢弃的传输容量就被浪费了。<br>建议是：优先处理经过了一定数量上游路由器的分组</p>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/33.png" alt="场景3结论"></p>
<h2 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h2><p>根据网络层是否为运输层拥塞控制提供显示的帮助来区分控制方法：</p>
<ol>
<li>端到端拥塞控制：网络层不提供支持，端系统对网络行为的观察来推断。</li>
<li>网络辅助的拥塞控制：路由器会向端发送拥塞状态的反馈信息。</li>
</ol>
<p>网络辅助拥塞控制又有两种方式：</p>
<ol>
<li>反馈信息可以由路由器直接发给发送方，采用阻塞分组的形式。</li>
<li>路由器标记分组中的某字段来指示拥塞现象，一旦接收方收到这个有拥塞标记的分组，就通知发送方网络发生了拥塞。<br>后一种形式至少经过一个完整的往返时间。</li>
</ol>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/34.png" alt="网络辅助拥塞控制的两种方式"></p>
<h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p><strong>TCP如何进行发送速率的控制？</strong></p>
<p>和流量控制中的RcvWindow类似，拥塞控制也有一个控制窗口CongWin，发送方根据这个窗口控制发送的数据量。<br>所以理论上有：LastByteSent – LastByteAcked &lt; min{cwnd, rwnd}<br>所以发送方的发送速率大概是()：min{cwnd, rwnd}/RTT</p>
<p><strong>TCP如何感知网络拥塞？</strong></p>
<p>通过超时或者3次冗余ACK</p>
<p><strong>TCP改变速率的算法是什么？</strong></p>
<p>TCP拥塞控制算法：特性是</p>
<ul>
<li>馒启动阶段：当接受一个确认ACK时，就增加一个MSS，结果是一个RTT事件内CongWin增加一倍。该阶段的特性是指数增。</li>
</ul>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/35.png" alt="慢启动"></p>
<ul>
<li>避免拥塞阶段：当接受一个确认ACK时，CongWin增加一点，期望是在一个RTT时间内增加一个MSS。该阶段的特性是，线性增，乘性减。</li>
</ul>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/36.png" alt="避免拥塞阶段"></p>
<ul>
<li>快速恢复阶段：进入一个中间状态，重发第一个未确认报文，同时CongWin减半。重传后如果接受到新的ACK，就恢复到避免拥塞状态，否则进入慢启动阶段。</li>
</ul>
<p>三个状态之间的转换关系如下：<br>超时进入慢启动。<br>达到阀值进入避免拥塞阶段。<br>接受3次冗余ACK进入快速恢复。</p>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/38.png" alt="拥塞控制FSM "></p>
<p><strong>为什么区别对待超时和冗余ACK?</strong></p>
<p>快速恢复机制是新版TCP Reno协议中开始执行的，为了适应快速重发的机制，之前的老版本TCP Tahoe协议并不具有这个中间阶段，对待超时和3次冗余ACK都会进入慢启动状态。<br>原因是因为能受到冗余ACK，至少说明网络还是有一定的传输能力的，因此只减少一半。这种方式叫快速恢复，结果是增加了吞吐量。</p>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/37.png" alt="TCP Tahoe协议和TCP Reno协议"></p>
<h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>W是最高窗口长度，当达到W时就会减半，所以平均吞吐量平均是0.75W/RTT。</p>
<p>也可以通过计算得到：</p>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/40.png" alt="TCP吞吐量"></p>
<p>达到10G吞吐量需要满足5,000,000,00个组一个丢包，要求是极高的。</p>
<h4 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h4><ol>
<li>两个同样的TCP连接</li>
</ol>
<p>虽然是竞争，但是在TCP拥塞算法下，最终会处于一个平衡状态。</p>
<p><img src="/2019/03/08/cmpNet/计算机网络自顶向下：第三章-传输层/40.png" alt="TCP之间的公平性"></p>
<ol start="2">
<li>TCP和UDP</li>
</ol>
<p>由于UDP不具有拥塞控制，所以必然会压榨TCP的传输速率。</p>
<ol start="3">
<li>采用多连接TCP</li>
</ol>
<p>虽然TCP之间是公平的，但是采用一条TCP的数据传输和采用两条TCP连接的数据传输必然是不公平的。</p>
<h4 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h4><p>更多完美的TCP拥塞算法在被逐步研究使用。</p>
]]></content>
      <categories>
        <category>计算机网络自顶向下</category>
      </categories>
      <tags>
        <tag>计算机网络自顶向下</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络自顶向下：第四章-网络层</title>
    <url>/2019/04/25/cmpNet/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%EF%BC%9A%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="转发和选路"><a href="#转发和选路" class="headerlink" title="转发和选路"></a>转发和选路</h3><p><strong>网络层的主要功能是什么？</strong></p>
<ul>
<li>转发：当分组到达路由器时，如何将分组转发出去。</li>
<li>路由：计算分组从发送端到接口端最合适的路径。</li>
</ul>
<p><img src="/2019/04/25/cmpNet/计算机网络自顶向下：第四章-网络层/1.png" alt="选路/转发"></p>
<p>选路算法决定了转发表中的表项</p>
<p>转发分组的设备叫做分组交换机，分为两种：</p>
<ol>
<li>链路层分组交换机：从输入链路接口道输出链路接口</li>
<li>网络层分组交换机（路由）</li>
</ol>
<p>除了转发和路由，网络层也有建立连接的功能。</p>
<h3 id="网络服务模型"><a href="#网络服务模型" class="headerlink" title="网络服务模型"></a>网络服务模型</h3><p><strong>网络层可以提供的服务有哪些？</strong></p>
<ul>
<li>确保交付：确保分组到达目的地</li>
<li>具有时延上界的确保交付：确保分组的到达将在一定的时间内</li>
<li>有序：确保按发送的顺序到达目的地</li>
<li>最小带宽：确保分组的传输在一定的带宽内</li>
<li>最大时延抖动：确保发送两个连续分组的间隔和接受两个连续分组的间隔在一定的变化范围内</li>
<li>安全性：使用只有源和主机知道的密钥</li>
</ul>
<p><strong>不同的网络体系会提供不同的网络服务：</strong></p>
<p>Intelnet的网络提供最小服务（也叫做尽力而为的服务），也有其他网络：</p>
<p><img src="/2019/04/25/cmpNet/计算机网络自顶向下：第四章-网络层/2.png" alt="不同的网络体系"></p>
<h2 id="虚电路和数据报电路"><a href="#虚电路和数据报电路" class="headerlink" title="虚电路和数据报电路"></a>虚电路和数据报电路</h2><p>和传输层一样，网络层也提供有连接服务（虚电路）和无连接服务（数据报）<br>Intelnet是数据报网络</p>
<p><strong>和传输层的连接有什么区别？</strong></p>
<ol>
<li>传输层是向应用层提供进程到进程的服务，网络层是向传输层提供主机到主机的服务。</li>
<li>网络层除了在端系统中实现，也再网络核心的路由器中实现。</li>
</ol>
<h3 id="虚电路网络"><a href="#虚电路网络" class="headerlink" title="虚电路网络"></a>虚电路网络</h3><p><strong>虚电路的组成:</strong></p>
<ol>
<li>源和目的之间的路径</li>
<li>VC号：路径上的每段链路的一个标识，在每次虚电路建立连接的时候分配。</li>
<li>路由器中的转发表，在每次虚电路建立连接的时候生成。分组的首部会携带VC号，每次进过一个路由器，就会去查表并且更新为下一个链路的VC号。</li>
</ol>
<p><img src="/2019/04/25/cmpNet/计算机网络自顶向下：第四章-网络层/3.png" alt="虚电路转发表"></p>
<p><strong>为什么同一个连接路径上的每个链路维护不同的VC号？维护同一个不行么？</strong></p>
<p>如果是同一个VC号，必然要求所有路由之间的信息交换更频繁，以避免出现重复的VC号，这样加大的维护的成本，并且必然使得VC号的长度大大增加。</p>
<p><strong>虚电路工作过程：</strong></p>
<p><img src="/2019/04/25/cmpNet/计算机网络自顶向下：第四章-网络层/4.png" alt="虚电路建立"></p>
<ol>
<li>虚电路建立阶段：计算分组转发的路径，确定链路VC号，增加路由表项，预留虚电路上的资源。</li>
<li>数据传输阶段</li>
<li>虚电路拆除阶段</li>
</ol>
<blockquote>
<p>虚电路中传递的报文称为信令报文，用来交换这些报文的协议称为信令协议。</p>
</blockquote>
<h3 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a>数据报网络</h3><p><img src="/2019/04/25/cmpNet/计算机网络自顶向下：第四章-网络层/5.png" alt="数据报网络"></p>
<p>数据报网络在报文发出前给报文加上目的的IP地址，之后就再也不维护任何的状态信息。<br>每个路由器都有一个将分组输出的路由表，确定从哪一个链路发出。</p>
<p>在理想的情况下，所有的路由器都有一份所有精确IP地址的转发表，可能是万亿级别的，显然这是不可能的。</p>
<p><strong>如何缩小转发表存储IP的量？</strong></p>
<p>考虑到IP地址的位数是有限的（32,64,128），因此可以采用前缀风格（范围）的转发方式，逐层定位到精确IP。</p>
<p><img src="/2019/04/25/cmpNet/计算机网络自顶向下：第四章-网络层/6.png" alt="前缀风格"></p>
<p>当有一个IP匹配到转发表中的两个前缀时，采用最长前缀匹配规则。</p>
<p>虚电路的转发表在建立连接的时候（连接建立阶段会计算转发路径）生成，那对于无连接的数据报网络，<strong>转发表如何生成？</strong></p>
<p>根据网络层的选路协议和选路算法，后面会讲到。<br>数据报网络的转发表可以在任意时间变化，所有分组很难以有序到达。</p>
<h3 id="虚电路和数据报电路的由来"><a href="#虚电路和数据报电路的由来" class="headerlink" title="虚电路和数据报电路的由来"></a>虚电路和数据报电路的由来</h3><p>虚电路来源于电话<br>数据网来源于终端</p>
<h2 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h2><p>路由器实现了网络层的转发功能</p>
<p><img src="/2019/04/25/cmpNet/计算机网络自顶向下：第四章-网络层/7.png" alt="路由器的体系结构"></p>
<p>路由器的体系结构：</p>
<ul>
<li>输入端口：执行物理层功能，链路层功能，和查表转发到正确的输出端口的功能。</li>
<li>交换结构：路由器中的网络，将分组从输出端口转发到输出端口。</li>
<li>输出端口：执行输入端口相反的操作。</li>
<li>选路处理器：执行选路协议，维护选路信息和转发表。</li>
</ul>
<h3 id="输入端口"><a href="#输入端口" class="headerlink" title="输入端口"></a>输入端口</h3><p><img src="/2019/04/25/cmpNet/计算机网络自顶向下：第四章-网络层/8.png" alt="输入端口"></p>
<p><strong>在哪儿查表？</strong></p>
<ul>
<li>转发表由选路处理器计算出，但通常转发表都会拷贝一份存放到输出端口中，这样就无须每次都转发到选路处理器，避免了单点瓶颈。</li>
<li>在一些特殊的情况下（比如工作站/服务器作为路由器），这时候由于输入端口处理能力有限，无法保存路由表，这时候输入端口就会把分组转发给选路处理器</li>
</ul>
<p><strong>查表的效率？</strong></p>
<p><em>希望输入端口的处理性能达到线路速度，即执行一次查找的时间应少于从输入端口接口一个分组的时间</em></p>
<ul>
<li>线性查找是不可能的</li>
<li>二分查找可以在32步之内完成，可这依然不够快</li>
<li>内容可寻址内存和高速缓存等等更多的技术</li>
</ul>
<p>得到输出端口的分组将会进入交换结构。</p>
<h3 id="交换结构"><a href="#交换结构" class="headerlink" title="交换结构"></a>交换结构</h3><p>功能是把分组从输入端口转发到输出端口</p>
<p><img src="/2019/04/25/cmpNet/计算机网络自顶向下：第四章-网络层/9.png" alt="交换结构"></p>
<p>三种交换的技术是：经内存交换，经一根总线交换，经一个互联网交换（2n条总线）。</p>
<h3 id="输出端口"><a href="#输出端口" class="headerlink" title="输出端口"></a>输出端口</h3><p><img src="/2019/04/25/cmpNet/计算机网络自顶向下：第四章-网络层/10.png" alt="输出端口"></p>
<h3 id="何时出现排队"><a href="#何时出现排队" class="headerlink" title="何时出现排队"></a>何时出现排队</h3><p>排队的影响是可能会出现丢包</p>
<p><strong>何时会出现排队现象？</strong></p>
<p>考虑一般情况：假设N个输入端，N个输出端，交换结构的速率是输入线路速度的N倍。<br>这种情况下，输入端口是不会出现排队现象的，但是在输出端口，当N个分组都到达同一个输出端口，就会有排队现象：如下图：</p>
<p><img src="/2019/04/25/cmpNet/计算机网络自顶向下：第四章-网络层/11.png" alt="输出端口排队"></p>
<p><strong>合适的处理排队方式？</strong></p>
<ol>
<li>足够的缓存：经验表明，缓存长度B = RTT * C（链路容量）</li>
<li>适当的分组调度程序：先来先到、加权公平排队（WFQ）</li>
<li>适当丢包策略：主動隊列管理，随机早期检查</li>
</ol>
<blockquote>
<p>如果交换结构不是足够快，则在输入端口也会出现分组排队</p>
</blockquote>
<h2 id="网络协议：Inetrnet中的转发和编址"><a href="#网络协议：Inetrnet中的转发和编址" class="headerlink" title="网络协议：Inetrnet中的转发和编址"></a>网络协议：Inetrnet中的转发和编址</h2><p>Inetrnet分为三个部分：</p>
<ol>
<li>IP协议：约定了数据报格式，编址的规则，分组转发规则。</li>
<li>选路组件：选路算法，决定转发表</li>
<li>ICMP数据报错误和信息报告协议</li>
</ol>
<p><img src="/2019/04/25/cmpNet/计算机网络自顶向下：第四章-网络层/12.png" alt="Intelnet组成"></p>
<p>本节讨论IP协议：Inetrnet数据交流的格式net是如何进行数据交流、编址以及转发的。</p>
<p><strong>Inetrnet数据交流的格式？</strong></p>
<p>也成为数据报格式，如图：</p>
<p><img src="/2019/04/25/cmpNet/计算机网络自顶向下：第四章-网络层/13.png" alt="IP数据报格式"></p>
<ul>
<li>版本号：决定如何解析剩余部分</li>
<li>首部长度：决定实际的数据部分从哪里开始</li>
<li>服务类型TOS：好像没什么用</li>
<li>数据报长度：首部+数据长度</li>
<li>标识号，标志，偏移量：和IP分片相关（稍后会讨论）</li>
<li>寿命TTL(Time To Life)：每经过一个路由器-1,TTL=0就会被丢弃。</li>
<li>协议：指明封装了哪一种传输层协议，是和传输层进行交流的一个方式。</li>
<li>首部校验和：用于校验IP数据报中的比特错误。</li>
<li>源和目的IP地址：指明发送端和接收端</li>
<li>选项：扩展</li>
<li>有效数据</li>
</ul>
<p><strong>IP分片是什么东西?</strong></p>
<p>受<em>不同的链路层协议上链路的数据帧最大数据量不同</em>（最大传输单元）的影响，一个较大的IP数据报，必不可完整的经多个不同的链路进行传输，为了解决这个问题，就有了IP分片的技术。<br>IP分片可以理解为将一个较大的数据报，分成多个较小的数据报片进行传输。</p>
<p><strong>如何分片？又如何整合？</strong></p>
<p>网络层的每个路由都有分片功能<br>但是重组的功能被放到端系统中，因为重组是一个稍复杂的功能，这样做是为了保持网络内核内核简单的原则。</p>
<p>这就是IP报中标识号，标志和偏移量的作用<br>标识号：结合IP地址确定唯一的数据报<br>标志：最后一个片被置为0，其余置为1，作用是用来判断是否有片丢失<br>偏移量：指定片应放在IP数据报的哪个位置</p>
<p><img src="/2019/04/25/cmpNet/计算机网络自顶向下：第四章-网络层/14.png" alt="IP分片和重组"></p>
<p><img src="/2019/04/25/cmpNet/计算机网络自顶向下：第四章-网络层/15.png" alt="IP分片表"></p>
<h3 id="IPV4编址"><a href="#IPV4编址" class="headerlink" title="IPV4编址"></a>IPV4编址</h3><p><strong>一个IP的映射是主机或者路由吗？</strong></p>
<p>不是，一个IP对应的是一个接口。<br>所谓接口就是主机/路由器和物理链路的一个接入点<br>因此，一个路由器可以拥有多个接口，也就是说可以拥有多个IP地址。<br>而主机往往一般只有一个接口接入到网络中</p>
<p><strong>什么是子网和子网掩码？</strong></p>
<p>子网是描述接口的集合：处于同一个网中，不经过任何路由器或主机而相连的接口集合，叫做子网<br>子网所具有的共通的前缀，称为子网掩码</p>
<p><strong>子网掩码的意义是什么？</strong></p>
<p>之前说过，为了减少路由器转发表的负担，转发表中都会使用前缀风格的形式。<br>越靠近网络核心部分的路由器，前缀所表示的范围就越大。<br>而相同子网掩码往往意味着同一个组织<br>当组织之外的路由器转发到组织内的数据报，仅需要考虑子网掩码即可<br>这样处理的意义也是为了减少转发表的负担</p>
<p><strong>这些IP地址是如何被网络分配的？</strong></p>
<ol>
<li>获取子网网段：向IP管理单位申请获得IP子网网段，入组织可以向ISP（电信，联通）申请获取子网网段，而ISP则是向全球性的权威机构ICANN申请获取IP地网段。</li>
<li>在子网中获取主机IP地址——动态主机配置协议（DHCP）：自动的给接入分配IP</li>
</ol>
<p><strong>DHCP如何实现自动分配？</strong></p>
<p>DHCP是一个客户端/服务器协议<br>一般情况下，每个子网都拥有一个DHCP服务器，如果没有，则需要一个DHCP中继代理（通常是一台路由器）</p>
<p><img src="/2019/04/25/cmpNet/计算机网络自顶向下：第四章-网络层/16.png" alt="DHCP"></p>
<p>DHCP使用UDP报文<br>DCHP的4步：</p>
<ol>
<li>DHCP服务发现：发送DHCP发现报文，使用广播的方式试图请求到附近的DHCP服务器，</li>
<li>DHCP服务提供：DHCP接受到发现报文，回复提供报文，同样使用广播的方式向客户机提供IP地址。</li>
<li>DHCP请求：客户端从来自多个DCHP服务器的提供报文中选择一个IP地址，并使用DHCP请求报文对选中的服务器进行相应。</li>
<li>DHCP ACK：服务器使用DHCP ACK报文进行回应</li>
</ol>
<p>DHCP的问题是：每到一个新的子网，就会获得一个新的IP，因此也就无法维持连接。</p>
<blockquote>
<p>移动IP是一种解决方案</p>
</blockquote>
<p><strong>子网拓展的问题？</strong></p>
<p>如果组织已向ISP申请了一个子网网段，随着组织规模的增大，很有可能子网网段不够用，怎么办？<br>继续向ISP申请总有一天会迎来IPV4地址的枯竭<br>这时候就使用网络地址转换（Nerwork Address Translation, NAT）</p>
<p><strong>NAT具体的工作原理？</strong></p>
<p>本质上就是组织内多个主机共享同一个IP，而主机之间采用独立的IP来区分。<br>这些IP可以使用私有地址:<br>如192.168.0.0 到192.168.255.255;<br>172.16.0.0到172.31.255.255;<br>10.0.0.0到10.255.255.255</p>
<p>NAT路由器作为连接内网和外网的一个节点，一端接口连接外网，一端接口连接内网。<br>数据分组在NAT中会被替换IP和端口，也就是说，NAT路由器会处理传输层的数据。<br>NAT路由器从ISP的DHCP服务器获取地址，然后它本身再运行一个DHCP服务，为NAT-DHCP路由器控制的组织网络分配地址</p>
<p><img src="/2019/04/25/cmpNet/计算机网络自顶向下：第四章-网络层/17.png" alt="DHCP"></p>
<p><strong>外网数据报文如何定位内网主机？</strong></p>
<p>NAT维护一张转发表：<br>NAT路由器的端口号—映射—内网主机IP+端口号</p>
<blockquote>
<p>传统的NAT映射只包括内网IP，不包括内网端口，这样会导致连接是单向的，也就是说<em>只能从内网向外网发起连接，无法从外网向内网发起连接</em></p>
</blockquote>
<p>NAT技术招到各界反对，原因是：</p>
<ol>
<li>端口号应该面对进程，而不是面对主机</li>
<li>路由器应当只处理第三层的分组（比如不应该修改端口号）</li>
<li>应该使用IPV6来解决IP地址短缺的问题</li>
</ol>
<p>NAT根据外网访问内网的权限又分成几种类型，可自行百度</p>
<h3 id="ICMP-互联网控制报文协议"><a href="#ICMP-互联网控制报文协议" class="headerlink" title="ICMP:互联网控制报文协议"></a>ICMP:互联网控制报文协议</h3><p>本节的主题是Internet的第二个主要组件</p>
<p><strong>ICMP是什么？有什么用？</strong></p>
<p>之前说过，IP数据报是网络层中主机和路由器、路由器和路由器之间交流的一种方式。<br>但是，IP数据报携带的有效数据一定是UDP、TCP段吗？显然不是<br>网络层中还有一种特殊的交流数据报，不携带来自传输层的数据，称为ICMP报文。<br>ICMP协议作为网络层协议，具有传输层无关的交流方式。<br>常用的ICMP功能是错误反馈，除此之外也具有很多其他的功能。比如ping，Traceroute（路由跟踪）。</p>
<p><strong>ICMP交流的语言定义是什么？</strong></p>
<p>ICMP中有类型和编码两个字段，可以表明这个ICMP报文说的是什么东西：</p>
<p><img src="/2019/04/25/cmpNet/计算机网络自顶向下：第四章-网络层/18.png" alt="ICMP协议类型"></p>
<p>案例：</p>
<ul>
<li>ping程序：发送一个类型8编码0的ICMP报文到指定主机，主机接受到该<em>回显请求</em>报文，回复类型0编码0的<em>回显回答</em>ICMP报文</li>
<li>traceroute程序：源主机不断发送的IP数据报，每个数据报都携带了不可达的UDP数据段，这些IP数据报配置的TTL依次递增，比如第一个数据报TTL为1，第二个数据报TTL为2…当路由器接受到一个TTL为0的数据报，会丢弃该数据报兵发送一个ICMP报警报文给源主机（类型11编码0）。当目的主机接收到不可达的UDP报文，会返回一个端口不可达的ICMP报文。源主机接收到这个报文就会停止发送数据报。</li>
</ul>
<h3 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h3><p>IPV4地址面临枯竭<br>IP设计者设计IPV6，对IPV4进行空间和功能的扩展。</p>
<p><strong>数据报格式：</strong></p>
<p><img src="/2019/04/25/cmpNet/计算机网络自顶向下：第四章-网络层/19.png" alt="IPV6报文格式"></p>
<ul>
<li>版本号： 同IPV4一样，表示如何解析数据报</li>
<li>流量类型（traffic class）：和IPV4中的TOS一样</li>
<li>流标签：给需要特殊服务的报文进行标签</li>
<li>有效负载长度：有效数据的长度</li>
<li>下一个首部：作用和IPV4中的协议字段相同。标识数据中的内容采用哪种协议。</li>
<li>跳限制：类型TTL</li>
<li>源和目的地址</li>
<li>有效数据</li>
</ul>
<p><strong>和V4相比，有哪些变化？</strong></p>
<ol>
<li>更大的地址容量：由32位变为128位</li>
<li>简单高效的40字节首部：去掉了IPV4中可变的选项字段，实现40字节定长。选项采取更灵活的方式实现</li>
<li>流标签和优先级（flow label）：给需要特殊服务的报文进行标签</li>
</ol>
<p><strong>V4中不存在的字段在V6中如何实现？</strong></p>
<ol>
<li>标识号，标志，偏移量：不在进行分片操作，若“分组太大”，通过ICMP错误报文来让发送方重发长度更小的IP数据报。</li>
<li>首部校验和：校验在链路层和传输层都有，因此去掉进一步精简网络层服务</li>
<li>选项：“选项”可以也可以由下一个首部字段指出。<blockquote>
<p>ICMPV6针对IPV6增加了新的类型和编码：如“分组太大”和“未识别的IPV6选项”</p>
</blockquote>
</li>
</ol>
<p>有一个问题：配置IPV6的系统既可以处理IPV6，也可以处理IPV4。但是只配置了IPV4的系统，如何处理IPV6呢？</p>
<p><strong>如何从IPV4迁移到IPV6？</strong></p>
<ol>
<li><p>宣布一个标志日，将所有机器都关机，从IPV4升级到IPV6，显然，这不现实。</p>
</li>
<li><p>双栈：配置了IPV6的系统在与IPV4交流的时候只发送IPV4，通过DNS来判断另一个节点是否支持IPV6。双栈的方式会把IPV6中的有效数据放到IPV4中进行发送，但是这样会丢失IPV6中的额外信息，如流标签和优先级，并且再无法找回。</p>
</li>
</ol>
<p><img src="/2019/04/25/cmpNet/计算机网络自顶向下：第四章-网络层/20.png" alt="双栈"></p>
<ol start="3">
<li>另一种双栈——建隧道：建隧道的方式会把整个IPV6中的数据放到IPV4中进行发送，这样信息就不会丢失了。</li>
</ol>
<p><img src="/2019/04/25/cmpNet/计算机网络自顶向下：第四章-网络层/21.png" alt="建隧道"></p>
<h3 id="IP安全性概述"><a href="#IP安全性概述" class="headerlink" title="IP安全性概述"></a>IP安全性概述</h3><p>IPsec协议防止IP报文被截取、修改或者被伪装，提供了如下的服务：</p>
<ol>
<li>密码技术协约：让两台主机加密算法和密钥一致</li>
<li>对IP数据报有效数据进行加密</li>
<li>保证数据是完整的，没有被修改</li>
<li>确保IP数据报的发送源未被伪装</li>
</ol>
<blockquote>
<p>关于实现的原理，在之后的学习中，有需要再去了解。</p>
</blockquote>
<h2 id="选路算法"><a href="#选路算法" class="headerlink" title="选路算法"></a>选路算法</h2><p>前面已学Internet的两个主要部分：IP协议和ICMP协议<br>接下来学习第三个主要部分：选路协议<br>先学习一些选路算法</p>
<p>于主机相连的第一个路由器称为默认路由器或者第一跳路由器<br>选路算法解决的问题是：数据报从源路由器到目的路由器之间的最“好”的一条路径</p>
<p>理想情况：网络可以抽象成图</p>
<p><img src="/2019/04/25/cmpNet/计算机网络自顶向下：第四章-网络层/22.png" alt="网络抽象图"></p>
<p><strong>算法的分类：</strong></p>
<p>按全局性还是分布式来分类:</p>
<ol>
<li>全局选路算法：需要每个节点了解所有的节点连通性和链路的费用</li>
<li>分布式选路算发：只需要每个节点了解相邻的节点连通性和链路费用</li>
</ol>
<p>按静态还是动态来分类：</p>
<ol>
<li>静态：变化缓慢，通常需要人为的干预</li>
<li>动态：在网络流量负载或者拓扑发生变化是改变选路路径</li>
</ol>
<p>按链路负载敏感度来分类：</p>
<ol>
<li>负载敏感：链路的费用反映链路当前的拥塞水平</li>
<li>负载迟钝：链路的费用不反映链路当前的拥塞水平</li>
</ol>
<h3 id="链路状态选路算法（Link-State-LS）"><a href="#链路状态选路算法（Link-State-LS）" class="headerlink" title="链路状态选路算法（Link-State,LS）"></a>链路状态选路算法（Link-State,LS）</h3><p>属于全局选路算法，通过每个节点向网络中的所有其它路由器广播链路状态来实现。<br>下面讲的链路状态选路算法使用dijkstra算法实现</p>
<p>计算从源节点u到网络中其它每个节点的最短路径：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Initialization:</span><br><span class="line">  N’ = &#123;u&#125;    </span><br><span class="line">  for all nodes v      </span><br><span class="line">    if v is a neighbor of u         </span><br><span class="line">      then D(v) = c(u,v)     </span><br><span class="line">    else D(v) = ∞</span><br><span class="line">Loop    </span><br><span class="line">  find w not in N’ such that D(w) is a minimum   </span><br><span class="line">  add w to N’  </span><br><span class="line">  update D(v) for each neighbor v of w and not in N’:</span><br><span class="line">      D(v) = min( D(v), D(w) + c(w,v) )</span><br><span class="line">   /* new cost to v is either old cost to v or known    </span><br><span class="line">   least path cost to w plus cost from w to v */</span><br><span class="line">until N’= N</span><br></pre></td></tr></table></figure></p>
<ul>
<li>N’：路径已确定的节点集合</li>
<li>D(v)：每次迭代，从源节点到目标节点v的最低费用</li>
<li>p(v)：最好路径的前一个节点<blockquote>
<p>算法时间复杂度O（n^2）</p>
</blockquote>
</li>
</ul>
<p>从p(v)我们可以确认转发表中的下一条链路</p>
<p>选路算法会周期性的执行<br>当有一条链路的费用发生变化，会通告给其他的路由器</p>
<p>考虑到这样一个现象：有两个排队通道，如果同一时间所有人从较长的队列移动到较短的队列，那么这并不会带来任何实质性的改善。<br>选路算法也存在这样的问题，叫做选路震荡</p>
<p><img src="/2019/04/25/cmpNet/计算机网络自顶向下：第四章-网络层/23.png" alt="选路震荡"></p>
<p><strong>符合防止选路震荡？</strong></p>
<ol>
<li>强制链路费用不依赖于负载。这是一种不可接受的方案，因为选路的目标之一就是要避开高拥塞。</li>
<li>防止同时执行。即便是不同时开始，周期执行，由于网络的“自同步”性质，最终也会成一起执行的结果。因此最好的避免方式是随机执行。</li>
</ol>
<h3 id="距离向量选路算法（Distance-Vector-DV）"><a href="#距离向量选路算法（Distance-Vector-DV）" class="headerlink" title="距离向量选路算法（Distance-Vector,DV）"></a>距离向量选路算法（Distance-Vector,DV）</h3><p>DV算法是异步的，分布式的算法。</p>
<p>DV算法的核心是一个方程式：dx(y)=minv{c(x,v)+ dv(y)}<br>v是一个变量，表示节点x所有的邻居<br>dx(y)表示x到y的最短距离</p>
<p>DV算法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Initialization:</span><br><span class="line"></span><br><span class="line">  for all destinations y in N:</span><br><span class="line">    Dx(y) = c(x,y)   /* if y is not a neighbor then c(x,y) = ∞*/</span><br><span class="line">  for each neighbor w</span><br><span class="line">    Dw(y) = ? for all destinations y in N</span><br><span class="line">  for each neighbor w</span><br><span class="line">    send distance vector Dx= [Dx(y): y inN] to w</span><br><span class="line"></span><br><span class="line">loop</span><br><span class="line">  wait(until I see a link cost change to some neighbor w or</span><br><span class="line">        until I receive a distance vector from some neighbor w)</span><br><span class="line"></span><br><span class="line">  for each y in N:</span><br><span class="line">    Dx(y) = minv&#123;c(x,v) + Dv(y)&#125;</span><br><span class="line"></span><br><span class="line">  if Dx(y) changed for any destination y</span><br><span class="line">  send distance vector Dx= [Dx(y): y in N] to all neighbors</span><br><span class="line">forever</span><br></pre></td></tr></table></figure></p>
<p>每次会把有更新的行发给邻居，邻居再根据接受到的数据来更新自己<br><img src="/2019/04/25/cmpNet/计算机网络自顶向下：第四章-网络层/24.png" alt="DV算法"></p>
<p>从算法中可以看到，两个循环触发的因素：</p>
<ol>
<li>有链路费用发生变化</li>
<li>从邻居接收到距离向量变化的消息</li>
</ol>
<p>接下来分析两种链路费用变化的案例：</p>
<p><img src="/2019/04/25/cmpNet/计算机网络自顶向下：第四章-网络层/25.png" alt="链路费用变化"></p>
<p>如图：</p>
<ol>
<li>a图中链路(x,y)费用减少，y检测到费用变化，触发更新，一系列迭代后，新的转发表生成</li>
<li>b图中链路(x,y)费用减少，并通知x，x更新距离向量，同时通知y，y又更新后通知x…..出现选路环路，更新会在两个节点之间来回反复</li>
</ol>
<p><strong>如何处理选路环路？</strong></p>
<p>增加毒性逆转：如果z 通过y 到x，那么z通告y，它（z）到x的距离是无穷大。<br>这样的操作显然可以防止环路的产生</p>
<p><strong>LV算法和DV算法孰好孰坏？</strong></p>
<ol>
<li>DV算法复杂度较小，获取费用的消耗较小，但是收敛速度受影响较多。</li>
<li>LS算法的健壮性较好，所有节点都独立计算自己的转发表，而DV算法的一个错误会导致整个网络的错误。</li>
</ol>
<h2 id="层次选路"><a href="#层次选路" class="headerlink" title="层次选路"></a>层次选路</h2><p>已经了解了相关的基础算法，但只是理论上可行的。<br>很显然，运用于实践中就会有诸多问题：</p>
<ol>
<li>规模：现实中有上亿的计算机，LS算法要求存储惊人的链路信息，DV算法可能永不收敛。</li>
<li>企业化：总有组织不愿意加入这种公开性的全球性的算法计算中，而是愿意隐藏内部网络，控制自己的路由信息。</li>
</ol>
<p>这些问题由Autonomous System（自治系统）来解决，每个AS系统由一组相同管理控制下的路由器（ISP或者公司），运行同一种选路算发（DV或者LS，但是为了区别，我们叫做自治系统内部选路算法）。<br>负责AS系统之间的路由器叫做网关。</p>
<p><strong>如何处理AS系统之间的选路问题呢？</strong></p>
<p>也就是说，某个要出去的分组应该经哪个网关路由器，发送到哪个外部AS系统呢？</p>
<p>较简单的方案是：通过AS间选路算法，计算所有外部AS系统的可达信息，把这些可达信息放到AS内所有路由器的转发表中<br>使用前缀风格的转发表，可大大减小转发表的量。</p>
<p>如果有多条可达路径，还可以根据约定的“策略”来选择。<br>常见的策略如热土豆选路（选择最低费用）</p>
<p><img src="/2019/04/25/cmpNet/计算机网络自顶向下：第四章-网络层/26.png" alt="AS系统之间的选路"></p>
<h2 id="Internet网中的选路"><a href="#Internet网中的选路" class="headerlink" title="Internet网中的选路"></a>Internet网中的选路</h2><p>上一节中我们学习了相关的原理，这一节就来了解这些理论在当今因特网中发挥了怎样的作用。</p>
<h3 id="Internet网AS内部选路：RIP"><a href="#Internet网AS内部选路：RIP" class="headerlink" title="Internet网AS内部选路：RIP"></a>Internet网AS内部选路：RIP</h3><p>数据距离向量协议，类似DV算法<br>使用跳数作为链路费用，每条链路的费用为1，如图：</p>
<p><img src="/2019/04/25/cmpNet/计算机网络自顶向下：第四章-网络层/27.png" alt="跳数的定义"></p>
<p>路径的最大费用为15，这也意味着，RIP协议适用的AS系统规模不会很大。<br>RIP每30秒发送一个RIP更新通告，通知邻居它到每个子网的最短距离。<br>180秒若没有收到邻居的通告，则可认为与该邻居的链路已中断。<br>邻居接受到转发表，更新转发表，通告给邻居，邻居再重新计算最短路径，更新转发表再通知，直至收敛。</p>
<p><img src="/2019/04/25/cmpNet/计算机网络自顶向下：第四章-网络层/28.png" alt="RIP转发表"></p>
<h3 id="Internet网AS内部选路：OSPF"><a href="#Internet网AS内部选路：OSPF" class="headerlink" title="Internet网AS内部选路：OSPF"></a>Internet网AS内部选路：OSPF</h3><p>类似LS算法<br>链路费用可由管理员配置<br>每30分钟广播一次链路状态（无论是否有更新，这种设计增加了健壮性）<br>OSPF通告使用OSPF报文，和ICMP一样承载在IP分组中，协议值为89。<br>OSPF协议自身实现了可靠报文传输，链路状态广播等功能<br>更多优点：</p>
<ol>
<li>安全：仅信任的路由器能参与一个AS内的OSPF协议。报文加入了鉴别的功能。</li>
<li>多条相同费用的路径：OSPF允许多条相同费用的路径同时传输</li>
<li>支持多路选路算法</li>
<li>支持在单个选路域内的层次结构</li>
</ol>
<h3 id="Internet网AS间选路：BGP"><a href="#Internet网AS间选路：BGP" class="headerlink" title="Internet网AS间选路：BGP"></a>Internet网AS间选路：BGP</h3><ul>
<li><p>BGP处理的问题：</p>
<ol>
<li>从相邻AS处获得子网可达性信息</li>
<li>向AS内部传达这些可达性信息</li>
<li>根据可达信息和AS策略决定路径</li>
</ol>
</li>
<li><p>BGP如何传达消息？</p>
<ol>
<li>建立半永久TCP连接，称为<em>BGP会话</em>，之间交流使用<em>BGP报文</em></li>
<li>连接的两端路由器叫<em>BGP对等方</em></li>
<li><em>AS间的BGP会话称为</em>eBGP（external BGP session）*</li>
<li><em>AS内的BGP会话称为</em>iBGP（internal BGP session）*</li>
<li>在BGP中，可达信息都是以前缀风格的IP来传达的，在BGP中也叫做<em>路由</em></li>
</ol>
</li>
</ul>
<p><img src="/2019/04/25/cmpNet/计算机网络自顶向下：第四章-网络层/29.png" alt="BGP会话"></p>
<ul>
<li><p>在BGP会话中，增加额外的属性以控制可达信息的传输：</p>
<ol>
<li>AS自治号：每一个AS都有一个AS自治号（除了边缘AS，也就是只作为源AS或者目标AS，称为桩（stub）AS）</li>
<li>AS-PATH：记录一个路由都经过了哪些AS，可防止环路，也可以作为选路策略。</li>
<li>NEXT-HOP：记录路由从哪一个接口进入AS内部，用于在向AS内部传达这些可达性信息时，通过内部选路协议确定到NEXT-HOP的路径，从而确定到目的前缀的路径。</li>
</ol>
</li>
<li><p>路由选择：<strong>多条路由的情况下，选择那一条？</strong></p>
<ol>
<li>增加<em>本地偏好值</em>的属性，较高的本地偏好值会被选择</li>
<li>最短的AS-PATH被选择</li>
<li>NEXT-HOP中指定的接口，最近的会被选择</li>
<li>等等</li>
</ol>
</li>
<li><p>通告策略：<strong>路由是否如何通告？</strong></p>
<ol>
<li>桩AS不应该通告给其他AS</li>
<li>不同的ISP之间往往由于利益问题具有不同的通告策略</li>
</ol>
</li>
</ul>
<h2 id="广播和多播选路"><a href="#广播和多播选路" class="headerlink" title="广播和多播选路"></a>广播和多播选路</h2><ul>
<li>广播：一个源节点向网络中的其它所有节点发送分组</li>
<li>多播：一个源节点有选择的向网络中的其它节点发送分组</li>
</ul>
<p>之前都只有研究过单播的选路算法，这一节主要是学习广播和多选的选路算法</p>
<h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>广播分组的IP地址分为两种</p>
<ol>
<li>受限广播：只在子网内传输，IP为255.255.255.255</li>
<li>直接广播：发送到专门网络上的每台主机了，主机字段（子网掩码意外的部分）通常全为1，如 192.168.10.255</li>
</ol>
<p>假设需要广播到N个目的主机</p>
<h4 id="最简单的广播选路算法"><a href="#最简单的广播选路算法" class="headerlink" title="最简单的广播选路算法"></a>最简单的广播选路算法</h4><p>使用N次单播<br>缺陷：</p>
<ol>
<li>相同的分组会在相同的路径上传播多次</li>
<li>单播方式要求知道知道每一个广播成员IP，需要额外的协议来维护广播成员</li>
</ol>
<h4 id="无控制洪泛"><a href="#无控制洪泛" class="headerlink" title="无控制洪泛"></a>无控制洪泛</h4><p>所有的节点都复制该分组并转发给所有的邻居（除来源）<br>缺陷：</p>
<ol>
<li>会出现环，导致广播风暴</li>
</ol>
<p><img src="/2019/04/25/cmpNet/计算机网络自顶向下：第四章-网络层/30.png" alt="N次单播"></p>
<p><strong>如何防止广播风暴？</strong></p>
<h4 id="受控洪泛"><a href="#受控洪泛" class="headerlink" title="受控洪泛"></a>受控洪泛</h4><ol>
<li>序列控制洪泛：每个节点都维护已接收的分组源地址（或其他唯一标识）和广播序号的列表，防止重复接受。</li>
<li>反向路径转发（RPF）：只有当分组到达的链路正好是在到源的最短路径上（转发表中有记录），才转发给所有的邻居（除来源）。<blockquote>
<p>之所叫反转，是因为由源到目的的路径和由目的到源的路径可能是不一样的，这里使用的是后面一种。<br><img src="/2019/04/25/cmpNet/计算机网络自顶向下：第四章-网络层/31.png" alt="反向路径转发"></p>
</blockquote>
</li>
</ol>
<p>上面的两种方案虽然都处理了重复的分组被丢弃，但是没有从根本上无法避免冗余分组的传输。</p>
<ol start="3">
<li>生成树广播：最小树能使路径不重复的到达所有节点，在所有广播成员内计算出最小生成树，然后把分组沿着这棵树的邻居广播（方向无所谓）。<br>生成树算法的主要复杂点在于树的生成和节点维护：<br>最简单的是基于中心方法，选择合适的中心节点，其他路由器向中心路由器发送加入树（tree-join）报文，加入树报文路过的路径也会加入到生成树中，做生成树。<blockquote>
<p>最小生成树虽然理论上很棒，但是在网络中实现起来却不简单</p>
</blockquote>
</li>
</ol>
<p><img src="/2019/04/25/cmpNet/计算机网络自顶向下：第四章-网络层/32.png" alt="生成树广播"></p>
<ol start="4">
<li>实践中的而广播算法：<ul>
<li>Gnutella：使用序列控制洪泛，并使用TTL来控制洪泛的跳数，也称为范围受限洪泛</li>
<li>OSPF：也使用序列控制洪泛</li>
</ul>
</li>
</ol>
<h3 id="多播"><a href="#多播" class="headerlink" title="多播"></a>多播</h3><p>和广播最大的不同在于，多播需要维护多播成员信息</p>
<p><strong>如何给多播分组编址？</strong></p>
<p>多播地址也叫做组地址，采用D类IP地址（224.0.0.0~239.255.255.255）<br>首4位总是2进制1110开头</p>
<p>组如何形成？如何终结？<br>新主机如何加入组？如何退出组？<br>任何主机都可以自由加入吗？<br>多播分组如何交付给组成员？<br>以上这些问题终归于<em>因特网组管理协议（IGMP3）</em></p>
<h4 id="IGMP3"><a href="#IGMP3" class="headerlink" title="IGMP3"></a>IGMP3</h4><p>和ICMP协议类似，承载在IP数据报上，IP协议号为2<br>作用在第一跳路由器和主机之间<br>具有3种类型的报文：</p>
<ol>
<li>membership_query报文：路由器向主机发出，确认哪些主机加入了多播组</li>
<li>membership_reprot报文：主机向路由器报告组信息</li>
<li>level_group报文：主机向路由器报告离组，可选，可以通过不响应membership_reprot报文来实现。</li>
</ol>
<p><strong>如何确定多播分组的目的路由器？</strong></p>
<p>由IGMP确认的组信息分离在不同的路由上，我们可以把这些多播路由器连接起来，使得重播分组只在这些路由上进行传播。</p>
<h4 id="多播选路算法"><a href="#多播选路算法" class="headerlink" title="多播选路算法"></a>多播选路算法</h4><p>多播选路算法的主要功能是让多播地址注册到路由器的转发表中。</p>
<ol>
<li>基于共享树：在相同组的路由器中形成最小生成树（可能包含少数非组内路由器），生成的方法和之前说的一样，关键在于中心节点的选择。分组沿着树进行传播。</li>
<li>基于源的树：使用RPF对每一个源构建一棵多播选路树。RFP是广播算法，因此需要配合剪枝算法进：若第一跳路由器无加入组的主机，就向上游路由器发送剪枝报文。若一个路由器从它的所有下游路由器收到剪枝报文，就向上游路由器发送剪枝报文。</li>
<li>实践中的多播选路算法是<em>距离向量多播选路协议（DVMRP）</em>，采用基于源的树算法那。</li>
</ol>
]]></content>
      <categories>
        <category>计算机网络自顶向下</category>
      </categories>
      <tags>
        <tag>计算机网络自顶向下</tag>
      </tags>
  </entry>
  <entry>
    <title>21 并发</title>
    <url>/2018/12/12/THING%20IN%20JAVA/21%20%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p><strong>并发的优势是?</strong></p>
<ol>
<li>执行速度极大提高</li>
<li>为设计类型的程序提供更加易用的模型</li>
</ol>
<p><strong>并发的问题</strong></p>
<p>当并发执行的任务开始产生交互的时候，一些不可预料的问题就会发生。因此，伴随着并发好处的同时会有一大堆的问题产生。</p>
<h2 id="并发的多面性"><a href="#并发的多面性" class="headerlink" title="并发的多面性"></a>并发的多面性</h2><p><strong>什么叫做多面性？</strong></p>
<p>需要并发处理的情况有很多，实现并发的方式也有很多，但是他们并不是一一对应的关系，也就是说，没有一个确切的解决方案，需要随机应变。<br>并发解决的问题大致可以分为两类：“速度”和“设计可管理性”</p>
<h3 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h3><p><strong>如何解决了速度的问题？</strong></p>
<p>对于多处理器，把任务分段在多个处理器上同时执行，很明显是变快了，这很好理解。<br>但是，并发更多的是处理单处理器上的速度问题，这似乎有点违背常理：在单处理器上，并发处理需要上下文切换，似乎开销比顺序执行的还要大。<br>让并发存在单处理上变得不可缺少的一个原因是“阻塞”。</p>
<p><strong>什么是阻塞？</strong></p>
<p>当程序因为某个控制范围之外（通常是I/O）的条件而停止了，整个程序都要暂停，也就是阻塞。<br>如果有并发，我们可以说只是一个任务暂停了，其它的任务还可以执行。</p>
<p><strong>如何处理阻塞问题？</strong></p>
<ul>
<li><p>无并发的处理方案：在代码中利用循环周期性的检查阻塞的状态。问题是：</p>
<ol>
<li>代码会非常丑陋</li>
<li>无法确保程序员不忘记这种检查</li>
</ol>
</li>
<li><p>使用进程实现并发：进程之间的任务互不干涉，若某个进程被阻塞了，执行下一个任务，这样的并发程序是没有风险的。</p>
</li>
</ul>
<p><strong>进程实现并发的问题？</strong></p>
<p>进程有数量和开销的限制。</p>
<p><strong>其它的并发实现？</strong></p>
<ul>
<li>使用并发任务彼此隔离的语言（譬如Erlang）：这类语言和进程并发类似，而且减少了进程的限制。</li>
<li>在顺序性语言（JAVA）上提供了对线程的支持</li>
</ul>
<h3 id="改进代码设计"><a href="#改进代码设计" class="headerlink" title="改进代码设计"></a>改进代码设计</h3><p><strong>如何解决了代码设计管理的问题？</strong></p>
<p>比如仿真设计，在游戏中，每一个角色看起来都是独立的，互相执行的不同的任务，这就需要多线程的设计方式了，使用单线程很难处理这个问题。</p>
<h2 id="JAVA-线程基本使用"><a href="#JAVA-线程基本使用" class="headerlink" title="JAVA 线程基本使用"></a>JAVA 线程基本使用</h2><ol>
<li>先定义任务，再把任务赋予到一个线程上驱动，案例：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LiftOff</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> countDown = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> taskCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id = taskCount++;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LiftOff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LiftOff</span><span class="params">(<span class="keyword">int</span> countDown)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.countDown = countDown;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">status</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#"</span> + id + <span class="string">"("</span> + (countDown &gt; <span class="number">0</span> ? countDown : <span class="string">"Liftoff!"</span>) + <span class="string">"), "</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (countDown-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.print(status());</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> LiftOff()).start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Waiting for LiftOff"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>每一次执行的结果都不一样。<br>Thread.yield()是让线程调度器重新分配任务。</p>
<ol start="2">
<li>继承Thread，定义一个具有特定任务的线程。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount = <span class="number">0</span>; <span class="number">814</span></span><br><span class="line">    Thinking in</span><br><span class="line">    JavaBruce Eckel</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleThread</span><span class="params">()</span> </span>&#123;     <span class="comment">// Store the thread name</span></span><br><span class="line">        <span class="keyword">super</span>(Integer.toString(++threadCount));</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#"</span> + getName() + <span class="string">"("</span> + countDown + <span class="string">"), "</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.print(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (--countDown == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在构造器中启动线程并不是一个很好的选择。</p>
<p><strong>需要理解的一个思想是：</strong></p>
<p>Runnable存在的意义更多的是一个“任务拥有者”的抽象，里面的run()表示一个“可执行的任务”<br>Thread存在的意义才贴近系统上的线程，可以看做是一个“任务执行者”，具有开始执行任务的方法start()。<br>Thread实现Runnable表示Thread也是“任务拥有者”，Thread(Runnable)的含义是用一个新的任务去覆盖Thread本身的默认任务。<br>Thread中持有target来保存任务拥有者，如果任务拥有者不为空，会调用任务拥有者的方法。<br>把任务和线程的概念抽离出来，可以更好的处理任务的创建，和对线程运行的理解。</p>
<p><strong>上面的实现方法有什么问题？</strong></p>
<ol>
<li>每一个任务都需要创建一个线程，在物理上创建线程的代价是比较大的，因此我们必须管理好线程。</li>
<li>没有返回</li>
</ol>
<p><strong>如何管理线程？</strong></p>
<p>使用JAVA5的Executor<br>Executor的实现使用了命令模式，把所有的Runable作为一个任务，采用不同的策略来分配线程执行。<br>也使用了享元模式，用来操作线程的缓存。</p>
<p>通过查看Thread中的类，可以发现，Thread并没有修改target的方法，那么，<strong>线程如何重复利用？</strong></p>
<p>实际上，虽然任务拥有者无法被改变，但是任务拥有者拥有的任务是可以被改变的。Executor中的Worker类就是一类可以把其它Runnable中的任务，接手过来，以此实现线程的重复利用的。</p>
<p><strong>什么是命令模式？</strong></p>
<ul>
<li>Command：定义命令的接口，声明执行的方法。</li>
<li>ConcreteCommand：命令接口实现对象，是“虚”的实现；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。</li>
<li>Receiver：接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。</li>
<li>Invoker：要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。</li>
<li>Client：创建具体的命令对象，并且设置命令对象的接收者。注意这个不是我们常规意义上的客户端，而是在组装命令对象和接收者，或许，把这个Client称为装配者会更好理解，因为真正使用命令的客户端是从Invoker来触发执行。</li>
</ul>
<p>下面的链接有详细的介绍：<br>[命令模式]<a href="https://my.oschina.net/xianggao/blog/618809" target="_blank" rel="noopener">https://my.oschina.net/xianggao/blog/618809</a></p>
<p>我的理解是，把请求抽象成命令，然后可以管理这些命令：</p>
<ol>
<li>可以把各种请求抽象成命令对象来处理。</li>
<li>可撤销，让所有的命令都支持可撤销的方法。</li>
<li>宏命令，一个命令的集合，批量执行。</li>
<li>命令队列，采取多线程的方式来执行命令。</li>
</ol>
<p><strong>Executor的命令模式？</strong></p>
<p>Runable类就是命令的抽象<br>Executor是Invoker，执行对命令的管理和执行。</p>
<p>常见的3种Executor子类有：</p>
<ol>
<li>CachedThreadPool：这个实例会根据需要，在线程可用时，重用之前构造好的池中线程。如果不存在可用线程，那么会重新创建一个新的线程并将其加入到线程池中。如果线程超过60s(可设置)还未被使用，就会被中止并从缓存中移除。因此，线程池在长时间空闲后不会消耗任何资源。</li>
<li>FixedThreadPool：这个实例会复用固定数量的线程处理一个共享的无边界队列。有多的任务被提交过来，那么它会一致在队列中等待直到有线程可用。如果任何线程在执行过程中因为错误而中止，新的线程会替代它的位置来执行后续的任务。所有线程都会一致存于线程池中，直到显式的执行ExecutorService.shutdown() 关闭。</li>
<li>这个实例只会使用单个工作线程来执行一个无边界的队列。它可以保证认为是按顺序执行的，任何时候都不会有多于一个的任务处于活动状态。</li>
</ol>
<p><strong>如何解决返回值的问题?</strong></p>
<p>实现带有泛型的Callable接口而不是Runnable接口，实现call()方法。<br>配合Exceutor使用的话，必须使用ExecutorService.submit()方法调用。</p>
<p>案例:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskWithResult</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaskWithResult</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"result of TaskWithResult "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        ArrayList&lt;Future&lt;String&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;Future&lt;String&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) results.add(exec.submit(<span class="keyword">new</span> TaskWithResult(i)));</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;String&gt; fs : results)</span><br><span class="line">            <span class="keyword">try</span> &#123;         <span class="comment">// get() blocks until completion:         </span></span><br><span class="line">                System.out.println(fs.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                exec.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为我们不知道线程在什么时候调用完成，所以返回值被Future封装了，使用isDone()查询Future是否已经完成，完成后可以使用get()方法获取返回值。</p>
<p>之前我们可以看到，线程的执行完全是随机的，和底层的实现机制有关，如何控制这一执行的顺序？</p>
<p><strong>如何控制线程执行的顺序？</strong></p>
<p>设置线程优先级，Thread.currentThread().setPriority(priority);<br>使用案例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePriorities</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">double</span> d; <span class="comment">// No optimization   private int priority;   </span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimplePriorities</span><span class="params">(<span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.priority = priority;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread() + <span class="string">": "</span> + countDown;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.currentThread().setPriority(priority);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;       <span class="comment">// An expensive, interruptable operation:       </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">                d += (Math.PI + Math.E) / (<span class="keyword">double</span>) i;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span>) Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (--countDown == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        exec.execute(<span class="keyword">new</span> SimplePriorities(Thread.MIN_PRIORITY));</span><br><span class="line">        exec.execute(<span class="keyword">new</span> SimplePriorities(Thread.MAX_PRIORITY));</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，优先级的设置最好放到run()方法中，因此可以保证当前任务已经开始执行。</p>
<p>优先级的作用：中断开销比较大的<em>低优先级</em>线程，让高优先级线程先执行。<em>并不是说高优先级的线程就一定先执行。</em></p>
<h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><p><strong>什么是后台线程？</strong></p>
<p>指在程序运行的时候再后台提供一种通用的服务，并且这种线程并不属于程序中不可或缺的部分，一旦非后台线程结束了，所有的后台程序也就结束了。</p>
<p>使用方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread daemon = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SimpleDaemons());       </span><br><span class="line">daemon.setDaemon(<span class="keyword">true</span>); <span class="comment">// Must call before start()       </span></span><br><span class="line">daemon.start();</span><br></pre></td></tr></table></figure></p>
<p>线程启动前设置<br>后台线程中创建的线程都是后台线程。<br>后台线程中的finally{}语句有可能不会被执行。</p>
<p><strong>对于Executor管理的线程，如何设置？</strong></p>
<p>每一个静态的ExecutorService都可以接受一个ThreadFactory的工厂<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;     </span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(r);     </span><br><span class="line">    t.setDaemon(<span class="keyword">true</span>);     </span><br><span class="line">    <span class="keyword">return</span> t;  </span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>对于线程的基本介绍到这，现在来解决第一个问题：<strong>如何解决阻塞问题？</strong></p>
<p>先看一个阻塞问题：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnresponsiveUI</span> </span>&#123;   </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">double</span> d = <span class="number">1</span>;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UnresponsiveUI</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;     </span><br><span class="line">    <span class="keyword">while</span>(d &gt; <span class="number">0</span>)       </span><br><span class="line">    d = d + (Math.PI + Math.E) / d;     </span><br><span class="line">    System.in.read(); <span class="comment">// Never gets here   </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用多线程解决方案：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponsiveUI</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Long d = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResponsiveUI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            d++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;     </span><br><span class="line">      <span class="comment">//! new UnresponsiveUI(); // Must kill this process</span></span><br><span class="line">        <span class="keyword">new</span> ResponsiveUI();</span><br><span class="line">        System.in.read();</span><br><span class="line">        <span class="comment">// Shows progress</span></span><br><span class="line">        System.out.println(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="线程的异常"><a href="#线程的异常" class="headerlink" title="线程的异常"></a>线程的异常</h3><p>每一个线程的异常都需要在run()方法中处理，一旦异常被抛出到线程外，都会打印到控制台。<br>案例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();   </span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     </span><br><span class="line">    ExecutorService exec = Executors.newCachedThreadPool();     </span><br><span class="line">    exec.execute(<span class="keyword">new</span> ExceptionThread());   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果是控制台打印出异常，即便是runtime异常，即便在main()中加上try-catch语句也没用。<br>可是有时候如果不希望某个线程的异常影响到其它线程的执行，我也不想在run()做一些没必要的异常处理，<strong>怎么办？</strong></p>
<p>JAVA5增加了Thread.UncaughtExceptionHandler接口，可以使用Thread.setUncaughtExceptionHandler()的来设置对特定线程死亡时未处理的异常的处理。<br>也可以使用setDefaultUncaughtExceptionHandler()来设置默认的处理器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span></span></span><br><span class="line"><span class="function">  </span>&#123;     </span><br><span class="line">    System.out.println(<span class="string">"caught "</span> + e);   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配合Exceutor使用的话就是在ThreadFactory的实现中调用Thread.setUncaughtExceptionHandler()方法。</p>
<h2 id="共享受限的资源"><a href="#共享受限的资源" class="headerlink" title="共享受限的资源"></a>共享受限的资源</h2><p><strong>线程共享资源的问题？</strong></p>
<p>一个线程访问到了另一个线程中尚未处理完成的中间变量结果，导致逻辑上出现错误。<br>主导原因是由于 两个线程的代码发生交叉执行。<br>访问到中间状态值才会出现错误，访问到结果状态值不算错误。</p>
<p><strong>如何解决</strong></p>
<p>思路是防止访问到<em>其它线程中</em>的<em>共享资源</em>的<em>中间状态值</em>。<br>使用同步机制：</p>
<ol>
<li>互斥机制：synchronized，lock</li>
<li>原子操作</li>
</ol>
<p><strong>字段设为private的好处是？</strong></p>
<p>只允许在方法中去访问字段，然后给方法加锁来控制对资源的访问。</p>
<p><strong>方法前加synchronized是给什么加锁？</strong></p>
<p>是给当前的对象或者是类，这点也就意味着一个对象中有多个synchronized方法被调用，即便不是同一个方法，只一个方法调用结束了，另一个方法才能被调用。<br>被锁上的“对象”都会有一个对应的计数器，只有当锁的计数器为0的时候，某资源才会被访问。譬如上述中一个对象中有3个synchronized方法被调用，当前的计数器就是3。</p>
<p>上面的锁机制称为互斥机制：一段时间只有一个任务可以运行这段代码。</p>
<p><strong>使用synchronized和使用lock的区别？</strong></p>
<ol>
<li>lock具有更细粒度，可以处理关键处的代码，没有必要锁上整个代码。</li>
<li>lock可以处理异常，synchronized报错了只能返回错误</li>
<li>lock具有更多的锁控制方法，比如tryLock()可以设置获取锁和等待锁的时间。</li>
</ol>
<p><strong>什么时候需要进行同步处理？</strong></p>
<p>当一个线程需要读取其它线程中修改的变量的时候。所有读取改变量的方法都要加同步处理。</p>
<blockquote>
<p>这里必须强调所有，一些加一些不加，也无法产生正常的结果。</p>
</blockquote>
<p><strong>什么是原子操作和原子性？</strong></p>
<p>一个不可被线程调度中断的操作被称为原子操作。这种不可分割的特性叫做原子性。<br>理论上说，如果一个线程只执行一个原子操作，就不会有不稳定的中间态，<strong>是不是就没有资源共享的问题了？</strong></p>
<p>理解上是正确的，但是使用起来非常危险，会有以下的几个问题：</p>
<ol>
<li>如何确实是一个原子操作？</li>
<li>多核处理器的情况下还会有可见性的问题。</li>
<li>使用synchronized保证的原子性只对synchronized方法有效<blockquote>
<p>使用synchronized可以保证原子性</p>
</blockquote>
</li>
</ol>
<p><strong>什么属于原子操作？</strong></p>
<p>基本类型都具有原子性（除long和double之外），对其的读取和赋值操作，返回操作是原子操作。<br>对于long和double（64字节），jvm可能会分为两个32字节的指令来处理，这时候也就不是原子操作了。<br>队员这种基本数据类型的简单操作，可以使用volatile来保证原子性。</p>
<p><strong>什么是可见性问题？</strong></p>
<p>在多核处理器中，每一个处理器刻都会有一个本地缓存，导致数据没有写入到内存中，也就无法被其它线程读取，这就是可见性的问题。<br>可以使用volatile来保证字段的可见性。</p>
<blockquote>
<p>使用synchronized可以保证可见性</p>
</blockquote>
<p><strong>如何理解使用synchronized保证的原子性只对synchronized方法有效？</strong></p>
<p>案例:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicityTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> i;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">evenIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          i++;</span><br><span class="line">          i++;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>) evenIncrement();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">          AtomicityTest at = <span class="keyword">new</span> AtomicityTest();</span><br><span class="line">          exec.execute(at);</span><br><span class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">              <span class="keyword">int</span> val = at.getValue();</span><br><span class="line">              <span class="keyword">if</span> (val % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                  System.out.println(val);</span><br><span class="line">                  System.exit(<span class="number">0</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的结果是会出现奇数值，原因是因为<em>synchronized只保证和synchronized操作之间的原子性</em>。</p>
<p>理论上说，使用原子操作确实可以代替锁来实现同步，但是由于各种各样的原因，使用原子操作是一个非常危险的尝试，如果不是专家，请不要轻易尝试。<br>如果情非得已需要使用原子操作，JAVA5提供了原子类来帮助大家避免危险。</p>
<h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><p>AtomicInteger,AtomicLong,AtomicReference等atomic包下的类来提供原子操作。</p>
<p>比如Random中就使用到了原子类来保证线程安全性：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> bits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> oldseed, nextseed;</span><br><span class="line">    AtomicLong seed = <span class="keyword">this</span>.seed;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        oldseed = seed.get();</span><br><span class="line">        nextseed = (oldseed * multiplier + addend) &amp; mask;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!seed.compareAndSet(oldseed, nextseed));</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(nextseed &gt;&gt;&gt; (<span class="number">48</span> - bits));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也由此可知，Random并不是真正的随机，而是根据初始参数为种子（如果未传以当前的时间为种子）来逐个生成数值：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RanomTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String arg[])</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(random.nextInt(<span class="number">100</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>无论运行多少次，结果都是一样的。因此，Random在多线程中最好作为static方法来使用，因此它是线程安全的。</p>
<h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>synchronized(互斥量){}，相比synchronized方法在性能上快很多，但还是没有lock功能强大。</p>
<h3 id="线程本地存储"><a href="#线程本地存储" class="headerlink" title="线程本地存储"></a>线程本地存储</h3><p>除了使用同步机制以外，还有第二种方法可以解决共享资源产生冲突的问题，那就是根除对变量的共享。</p>
<p><strong>如何使用线程本地存储？</strong></p>
<p>使用ThreadLocal类</p>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>单线程的阻塞可以用多线程来解决，但是多线程的情况下也会出现阻塞，比如等待另一个线程的资源的释放。</p>
<p><strong>线程都有哪些状态？</strong></p>
<ol>
<li>新建：新建的线程所处的短暂的一个状态，等待调度器把状态转变成就绪或者阻塞。</li>
<li>就绪：有时间片就可以执行</li>
<li>阻塞：某个条件阻止线程执行</li>
<li>死亡：线程停止执行，不会被调度器调度。</li>
</ol>
<p><strong>导致线程进入阻塞状态的原因？</strong></p>
<ol>
<li>sleep()</li>
<li>wait()</li>
<li>等待I/O</li>
<li>无法获取锁</li>
</ol>
<p>有时间不希望线程无休止的阻塞下去，<strong>怎么中断？</strong></p>
<p>使用interrupt()<br>应该注意的是，线程是否中断应该由自己来决定，interrupt()只是“给一个建议”，某些情况下，强制中断会带来很严重的后果。<br>因此并不是所有的阻塞状态都能被中断的，比如IO阻塞（这里指传统的IO）和锁阻塞（Lock类具有可中断的锁ReentrantLock）就属于不可中断的阻塞状态。</p>
<p><strong>线程如何响应中断？</strong></p>
<p>interrupt()是设置线程的一个中断信号，有两种响应的结果。</p>
<ol>
<li>处于可中断的阻塞状态的线程接收到中断信号后会抛出InterruptedException异常，随后重置中断信号。</li>
<li>对于没有阻塞状态的线程不会响应这个中断信号，但是可以使用interrupted()来检查中断信号，这个方法会返回当前的中断信号，并且随后重置中断信号，因此也可以通过判断interrupted来。</li>
</ol>
<p><strong>中断发生在阻塞前会是什么结果？</strong></p>
<h2 id="线程协作"><a href="#线程协作" class="headerlink" title="线程协作"></a>线程协作</h2><p><strong>为什么wait()的持有者是Object而不是Thread？</strong></p>
<p>我的理解是：并不是由线程来决定是否能拥有锁，而应该是由锁来决定哪一个线程可以获取到它，因此，是锁决定挂起或者唤醒一个线程，而不是由线程决定自己是否被挂起或者挂起，所以持有wait()和notify()的对象应该是锁，而所有的对象都可以是锁，因而ait()的持有者是Object，而不是Thread。<br>需要注意的是wait()，notify()等的使用需要在同步代码中，否则会抛出异常。</p>
<p><strong>如何控制wait()发生在notify()之前？</strong></p>
<p>把wait()放在某条件语句（线程A中）中，让wait()发生， 在notify()前后（线程B）中控制wait()方法被唤醒的条件。</p>
<p><strong>为什么wait()要放在while中？</strong></p>
<p>因为被唤醒不等于立刻就获得了锁开始执行，有可能另一被唤醒的线程获得了锁，并且再次改变（达到本线程中）了被挂起的条件，这时候如果本线程还要继续执行，就会出现问题。</p>
<p><strong>Lock的线程协作方式使用</strong></p>
<p>每一个Lock实例都可以使用newCondition()来获取Condition对象，这个Condition对象具有await(),signal()和signalAll方法来控制线程协作。</p>
<h3 id="生产者和消费者"><a href="#生产者和消费者" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h3><p>生产者和消费者问题是一个典型的线程协作和案例：<br>生产者是生产资源的任务拥有者。<br>消费者是消费资源的任务拥有者。</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>当消费和生产的资源上限只有一个的时候，性能上会受到很大的局限。<br>concurrent包下面的BlockingQuene帮我们创建了一个强大而使用简单的资源队列的使用：</p>
<ol>
<li>BlockingQuene中的入队和出对操作都会加锁，所以线程的其它的地方不加锁也不会出现资源共享的问题。</li>
<li>当BlockingQuene为空的时候，会挂起消费者。当BlockingQuene满的时候会挂起生产者。</li>
</ol>
<h3 id="线程间的输入和输出"><a href="#线程间的输入和输出" class="headerlink" title="线程间的输入和输出"></a>线程间的输入和输出</h3><p>可以使用管道流实现，一个进程写入，另一个进程读出，没有涉及到资源共享的问题。<br>实际上，管道流是BlockingQuene出现之前的一种线程间安全交流的代替方法。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>所有的线程都在等待某个条件并且一直等待下去，就是死锁，死锁往往是出乎意料的发生的。</p>
<p>经典的死锁案例——哲学家就餐问题：<br>基本描述指定了五位哲学家.这些哲学家把他们的一部分时间花在思考上，把一部分时间花在吃饭上。当他们思考的时候，他们不需要任何共享的资源，但是他们使用有限数量的器皿吃饭。在最初的问题描述中，餐具是叉子，需要两把叉子才能从桌子中间的碗中取出意大利面，但说餐具是筷子似乎更有意义。显然，每个哲学家都需要两把筷子才能吃饭。<br>作为哲学家，他们的钱很少，所以他们只能买得起五只筷子(更普遍地说，筷子的数量与哲学家的数量相同)。它们之间隔着桌子。当一个哲学家想吃东西时，那个哲学家必须拿起左手的筷子和右边的筷子。如果两边的哲学家都在用想要的筷子，我们的哲学家必须等到必要的筷子可用为止。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chopstick</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> taken = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (taken) wait();</span><br><span class="line">        taken = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">drop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        taken = <span class="keyword">false</span>;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Chopstick left;</span><br><span class="line">    <span class="keyword">private</span> Chopstick right;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> ponderFactor;</span><br><span class="line">    <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ponderFactor == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(rand.nextInt(ponderFactor * <span class="number">250</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Philosopher</span><span class="params">(Chopstick left, Chopstick right, <span class="keyword">int</span> ident, <span class="keyword">int</span> ponder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">        id = ident;</span><br><span class="line">        ponderFactor = ponder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                print(<span class="keyword">this</span> + <span class="string">" "</span> + <span class="string">"thinking"</span>);</span><br><span class="line">                pause();         <span class="comment">// Philosopher becomes hungry         </span></span><br><span class="line">                print(<span class="keyword">this</span> + <span class="string">" "</span> + <span class="string">"grabbing right"</span>);</span><br><span class="line">                right.take();</span><br><span class="line">                print(<span class="keyword">this</span> + <span class="string">" "</span> + <span class="string">"grabbing left"</span>);</span><br><span class="line">                left.take();</span><br><span class="line">                print(<span class="keyword">this</span> + <span class="string">" "</span> + <span class="string">"eating"</span>);</span><br><span class="line">                pause();</span><br><span class="line">                right.drop();</span><br><span class="line">                left.drop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            print(<span class="keyword">this</span> + <span class="string">" "</span> + <span class="string">"exiting via interrupt"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Philosopher "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadlockingDiningPhilosophers</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ponder = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) ponder = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">1</span>) size = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        Chopstick[] sticks = <span class="keyword">new</span> Chopstick[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) sticks[i] = <span class="keyword">new</span> Chopstick();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) exec.execute(<span class="keyword">new</span> Philosopher(sticks[i], sticks[(i + <span class="number">1</span>) % size], i, ponder));</span><br><span class="line">        <span class="keyword">if</span> (args.length == <span class="number">3</span> &amp;&amp; args[<span class="number">2</span>].equals(<span class="string">"timeout"</span>)) TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Press ‘Enter’ to quit"</span>);</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>死锁的情况是：每一个哲学家都持有一双筷子，等待获取另一双筷子。</p>
<p><strong>死锁发生的条件是什么？</strong></p>
<ol>
<li>有互斥的条件，就是存在只能被一个线程使用的资源。如一个筷子只能被一个哲学家使用。</li>
<li>至少有一个任务持有一个资源且等待一个被别的任务持有的资源。如哲学家持有一根筷子，等待另一个哲学家手中的筷子。</li>
<li>线程不能抢占资源。</li>
<li>必须有循环等待。如哲学家永远都是试图先去获取右手的筷子，之后再获取左手的筷子。</li>
</ol>
<p><strong>如何防止死锁？</strong></p>
<p>破坏上面的任何一个条件即可。最容易的方法是破坏第四个，比如让其中一个哲学家颠倒一下获取筷子的顺序。</p>
<blockquote>
<p>破坏其它条件的解决方案请参考更高级的讨论线程的书籍</p>
</blockquote>
<h2 id="concurrent库下的新功能"><a href="#concurrent库下的新功能" class="headerlink" title="concurrent库下的新功能"></a>concurrent库下的新功能</h2><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>用来同步一个或者多个任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CountDownLatch(<span class="keyword">int</span> count)</span><br><span class="line">构造一个用给定计数初始化的 CountDownLatch。</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断或超出了指定的等待时间。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 递减锁存器的计数，如果计数到达零，则释放所有等待的线程。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回当前计数。</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回标识此锁存器及其状态的字符串。</span></span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>让多个线程在同一起跑线等待，然后分回合的并行执行。<br>下面是一个赛马的比赛，每一回合马前进1到3步。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Horse</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id = counter++;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> strides = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier barrier;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Horse</span><span class="params">(CyclicBarrier b)</span> </span>&#123;</span><br><span class="line">        barrier = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getStrides</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strides;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="comment">// Produces 0, 1 or 2</span></span><br><span class="line">                    strides +=  rand.nextInt(<span class="number">3</span>);;</span><br><span class="line">                &#125;</span><br><span class="line">                barrier.await();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// A legitimate way to exit</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            <span class="comment">// This one we want to know about</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Horse "</span> + id + <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">tracks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getStrides(); i++) &#123;</span><br><span class="line">            s.append(<span class="string">"*"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        s.append(id);</span><br><span class="line">        <span class="keyword">return</span> s.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HorseRace</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FINISH_LINE = <span class="number">75</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Horse&gt; horses = <span class="keyword">new</span> ArrayList&lt;Horse&gt;();</span><br><span class="line">    <span class="keyword">private</span> ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier barrier;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HorseRace</span><span class="params">(<span class="keyword">int</span> nHorses, <span class="keyword">final</span> <span class="keyword">int</span> pause)</span> </span>&#123;</span><br><span class="line">        barrier = <span class="keyword">new</span> CyclicBarrier(nHorses, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; FINISH_LINE; i++) &#123;</span><br><span class="line">                    s.append(<span class="string">"="</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// The fence on the racetrack</span></span><br><span class="line">                System.out.println(s);</span><br><span class="line">                <span class="keyword">for</span> (Horse horse : horses) &#123;</span><br><span class="line">                    System.out.println(horse.tracks());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (Horse horse : horses) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (horse.getStrides() &gt;= FINISH_LINE) &#123;</span><br><span class="line">                        System.out.println(horse + <span class="string">"won!"</span>);</span><br><span class="line">                        exec.shutdownNow();</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(pause);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"barrier-action sleep interrupted"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nHorses; i++) &#123;</span><br><span class="line">            Horse horse = <span class="keyword">new</span> Horse(barrier);</span><br><span class="line">            horses.add(horse);</span><br><span class="line">            exec.execute(horse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nHorses = <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">int</span> pause = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">new</span> HorseRace(nHorses, pause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>CyclicBarrier的构造器接受两个变量，第一个指定计数器，第二个指定一个栅栏任务。<br>当await()的线程到达指定的数量的时候，执行栅栏任务。</p>
<h3 id="DelayQuene"><a href="#DelayQuene" class="headerlink" title="DelayQuene"></a>DelayQuene</h3><p>BlockingQueue的一个变种，任务以“延迟”来排序，优先执行即将到期的任务。<br>队列中的资源对象需要实现Delayed接口，实现getDelay()方法。<br>Delayed又继承了Complarable接口，因此又需要实现compareTo()方法。<br>案例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelayedTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Delayed</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id = counter++;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> delta;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> trigger;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> List&lt;DelayedTask&gt; sequence = <span class="keyword">new</span> ArrayList&lt;DelayedTask&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayedTask</span><span class="params">(<span class="keyword">int</span> delayInMilliseconds)</span> </span>&#123;</span><br><span class="line">        delta = delayInMilliseconds;</span><br><span class="line">        trigger = System.nanoTime() + NANOSECONDS.convert(delta, MILLISECONDS);</span><br><span class="line">        sequence.add(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unit.convert(trigger - System.nanoTime(), NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed arg)</span> </span>&#123;</span><br><span class="line">        DelayedTask that = (DelayedTask) arg;</span><br><span class="line">        <span class="keyword">if</span> (trigger &lt; that.trigger) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (trigger &gt; that.trigger) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="keyword">this</span> + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"[%1$-4d]"</span>, delta) + <span class="string">" Task "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">summary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"("</span> + id + <span class="string">":"</span> + delta + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EndSentinel</span> <span class="keyword">extends</span> <span class="title">DelayedTask</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> ExecutorService exec;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">EndSentinel</span><span class="params">(<span class="keyword">int</span> delay, ExecutorService e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(delay);</span><br><span class="line">            exec = e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (DelayedTask pt : sequence) &#123;</span><br><span class="line">                System.out.println(pt.summary() + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(<span class="keyword">this</span> + <span class="string">" Calling shutdownNow()"</span>);</span><br><span class="line">            exec.shutdownNow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelayedTaskConsumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DelayQueue&lt;DelayedTask&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayedTaskConsumer</span><span class="params">(DelayQueue&lt;DelayedTask&gt; q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.q = q;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                q.take().run();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Run task with the current thread</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// Acceptable way to exit</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Finished DelayedTaskConsumer"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelayQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        DelayQueue&lt;DelayedTask&gt; queue = <span class="keyword">new</span> DelayQueue&lt;DelayedTask&gt;();</span><br><span class="line">        <span class="comment">// Fill with tasks that have random delays:</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1L</span>);</span><br><span class="line">            queue.put(<span class="keyword">new</span> DelayedTask(rand.nextInt(<span class="number">5000</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Set the stopping point</span></span><br><span class="line">        queue.add(<span class="keyword">new</span> DelayedTask.EndSentinel(<span class="number">5000</span>, exec));</span><br><span class="line">        exec.execute(<span class="keyword">new</span> DelayedTaskConsumer(queue));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面EndSentinel是一个终结任务，作清理工作。<br>TimeUtil下面的枚举类有一个convert()方法，可以很方便的做时间单位上的转换。<br>如果队列为空了，那么将会返回null。</p>
<h3 id="PriaorityBlockingQuene"><a href="#PriaorityBlockingQuene" class="headerlink" title="PriaorityBlockingQuene"></a>PriaorityBlockingQuene</h3><p>自定义优先级的BlockingQuene，需要队列中的资源实现Comparable接口。</p>
<h3 id="ScheduledExecutor"><a href="#ScheduledExecutor" class="headerlink" title="ScheduledExecutor"></a>ScheduledExecutor</h3><p>定时和周期性的执行线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用给定核心池大小创建一个新 ScheduledThreadPoolExecutor。</span></span><br><span class="line">ScheduledThreadPoolExecutor(<span class="keyword">int</span> corePoolSize)  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并执行在给定延迟后启用的一次性操作。  </span></span><br><span class="line">ScheduledFuture&lt;?&gt;	schedule(Runnable command, <span class="keyword">long</span> delay, TimeUnit unit)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。</span></span><br><span class="line">ScheduledFuture&lt;?&gt;	scheduleAtFixedRate(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period, TimeUnit unit)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。       </span></span><br><span class="line">ScheduledFuture&lt;?&gt;	scheduleWithFixedDelay(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> delay, TimeUnit unit)</span><br></pre></td></tr></table></figure>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>锁在任何时刻只允许一个任务访问一个资源，而信号量允许N个任务同时访问这个资源。比如“线程池”的实例。<br>使用方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定信号量，默认非公平</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span></span></span><br><span class="line"><span class="function"><span class="comment">//指定信号量和是否公平</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span></span></span><br><span class="line"><span class="function"><span class="comment">//获取信号量，获取不到则阻塞</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//释放信号量</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h3><p>交换两个线程的对象数据。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Exchanger&lt;String&gt; exchanger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(Exchanger&lt;String&gt; exchanger)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.exchanger = exchanger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="number">1</span> + <span class="string">": "</span> + exchanger.exchange(<span class="string">"Car"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bike</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Exchanger&lt;String&gt; exchanger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bike</span><span class="params">(Exchanger&lt;String&gt; exchanger)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.exchanger = exchanger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="number">2</span> + <span class="string">": "</span> + exchanger.exchange(<span class="string">"Bike"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line">        Car car = <span class="keyword">new</span> Car(exchanger);</span><br><span class="line">        Bike bike = <span class="keyword">new</span> Bike(exchanger);</span><br><span class="line">        car.start();</span><br><span class="line">        bike.start();</span><br><span class="line">        System.out.println(<span class="string">"Main end!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="仿真"><a href="#仿真" class="headerlink" title="仿真"></a>仿真</h2><ol>
<li>类似：生活中适当调整工作人员数量来服务随机到来的人群。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> serviceTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(<span class="keyword">int</span> tm)</span> </span>&#123;</span><br><span class="line">        serviceTime = tm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getServiceTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serviceTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"["</span> + serviceTime + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerLine</span> <span class="keyword">extends</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">Customer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomerLine</span><span class="params">(<span class="keyword">int</span> maxLineSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(maxLineSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"[Empty]"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (Customer customer : <span class="keyword">this</span>) &#123;</span><br><span class="line">            result.append(customer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者生成器， 随机的生成到来的人，放在CustomerLine中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerGenerator</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CustomerLine customers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomerGenerator</span><span class="params">(CustomerLine cq)</span> </span>&#123;</span><br><span class="line">        customers = cq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(rand.nextInt(<span class="number">300</span>));</span><br><span class="line">                customers.put(<span class="keyword">new</span> Customer(rand.nextInt(<span class="number">1000</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"CustomerGenerator interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"CustomerGenerator terminating"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teller</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Comparable</span>&lt;<span class="title">Teller</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CustomerLine customers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id = counter++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> customersServed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> servingCustomerLine = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teller</span><span class="params">(CustomerLine cq)</span> </span>&#123;</span><br><span class="line">        customers = cq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始服务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                Customer customer = customers.take();</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(customer.getServiceTime());</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    customersServed++;</span><br><span class="line">                    <span class="keyword">while</span> (!servingCustomerLine) &#123;</span><br><span class="line">                        wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span> + <span class="string">"interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span> + <span class="string">"terminating"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 让柜台人员去做其他事，停止服务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomethingElse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        customersServed = <span class="number">0</span>;</span><br><span class="line">        servingCustomerLine = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 让柜台人员开始服务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">serveCustomerLine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> !servingCustomerLine : <span class="string">"already serving: "</span> + <span class="keyword">this</span>;</span><br><span class="line">        servingCustomerLine = <span class="keyword">true</span>;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Teller "</span> + id + <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">shortString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"T"</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Teller other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> customersServed &lt; other.customersServed ? -<span class="number">1</span> : (customersServed == other.customersServed ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TellerManager</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ExecutorService exec;</span><br><span class="line">    <span class="keyword">private</span> CustomerLine customers;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Teller&gt; workingTellers = <span class="keyword">new</span> PriorityQueue&lt;Teller&gt;();</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Teller&gt; tellersDoingOtherThings = <span class="keyword">new</span> LinkedList&lt;Teller&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> adjustmentPeriod;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TellerManager</span><span class="params">(ExecutorService e, CustomerLine customers, <span class="keyword">int</span> adjustmentPeriod)</span> </span>&#123;</span><br><span class="line">        exec = e;</span><br><span class="line">        <span class="keyword">this</span>.customers = customers;</span><br><span class="line">        <span class="keyword">this</span>.adjustmentPeriod = adjustmentPeriod;</span><br><span class="line">        <span class="comment">// Start with a single teller:</span></span><br><span class="line">        Teller teller = <span class="keyword">new</span> Teller(customers);</span><br><span class="line">        exec.execute(teller);</span><br><span class="line">        workingTellers.add(teller);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整柜台人员的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjustTellerNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// This is actually a control system. By adjusting</span></span><br><span class="line">        <span class="comment">// the numbers, you can reveal stability issues in</span></span><br><span class="line">        <span class="comment">// the control mechanism.</span></span><br><span class="line">        <span class="comment">// If line is too long, add another teller:</span></span><br><span class="line">        <span class="keyword">if</span> (customers.size() / workingTellers.size() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// another job, bring one back:</span></span><br><span class="line">            <span class="keyword">if</span> (tellersDoingOtherThings.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Teller teller = tellersDoingOtherThings.remove();</span><br><span class="line">                teller.serveCustomerLine();</span><br><span class="line">                workingTellers.offer(teller);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Teller teller = <span class="keyword">new</span> Teller(customers);</span><br><span class="line">            exec.execute(teller);</span><br><span class="line">            workingTellers.add(teller);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (workingTellers.size() &gt; <span class="number">1</span> &amp;&amp; customers.size() / workingTellers.size() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            reassignOneTeller();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If there is no line, we only need one teller:</span></span><br><span class="line">        <span class="keyword">if</span> (customers.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (workingTellers.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                reassignOneTeller();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 让已服务人数最少的柜台人员休息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reassignOneTeller</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Teller teller = workingTellers.poll();</span><br><span class="line">        teller.doSomethingElse();</span><br><span class="line">        tellersDoingOtherThings.offer(teller);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 周期性的打印当前服务信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(adjustmentPeriod);</span><br><span class="line">                adjustTellerNumber();</span><br><span class="line">                System.out.print(customers + <span class="string">" &#123; "</span>);</span><br><span class="line">                <span class="keyword">for</span> (Teller teller : workingTellers) &#123;</span><br><span class="line">                    System.out.print(teller.shortString() + <span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"&#125;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span> + <span class="string">"interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span> + <span class="string">"terminating"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"TellerManager "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BankTellerSimulation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_LINE_SIZE = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ADJUSTMENT_PERIOD = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// If line is too long, customers will leave:</span></span><br><span class="line">        CustomerLine customers = <span class="keyword">new</span> CustomerLine(MAX_LINE_SIZE);</span><br><span class="line">        exec.execute(<span class="keyword">new</span> CustomerGenerator(customers));</span><br><span class="line">        <span class="comment">// Manager will add and remove tellers as necessary:</span></span><br><span class="line">        exec.execute(<span class="keyword">new</span> TellerManager(exec, customers, ADJUSTMENT_PERIOD));</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// Optional argument</span></span><br><span class="line">        &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Integer(args[<span class="number">0</span>]));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Press ‘Enter’ to quit"</span>);</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h2><ul>
<li>性能：原子操作&gt;lock&gt;synchronized</li>
<li>风险：原子操作&gt;lock&gt;synchronized</li>
<li>可读性：synchronized&gt;lock&gt;原子操作</li>
</ul>
<p><strong>如何确定同步块包含的范围？</strong></p>
<p>需要包含共享资源被修改的整个过程</p>
<h3 id="容器的性能进化"><a href="#容器的性能进化" class="headerlink" title="容器的性能进化"></a>容器的性能进化</h3><ul>
<li>java1：类似Vector和Hashtable之类的类,具有许多synchronized的方法，当他们用于非多线程的应用程序中，会导致不可接受的开销。</li>
<li>java2：新容器都是不同步的，而且Collections中提供了各种同步的内部容器类，这时候的问题是在多线程的情况下，锁实现的开销依然不小。</li>
<li>java5：添加的专门用于处理同步的免锁容器，采用了更加灵巧的技术实现。</li>
</ul>
<p><strong>免锁容器采用了什么技术？</strong></p>
<p>只对修改操作加锁操作，为了防止读取操作读到不同的线程的中间状态值，修改是在容器数据结构的某个部分的一个单独的副本上执行的，这个副本在修改的过程中是不可视的，当修改完成的时候，一个原子性的操作将把新的数组换入。</p>
<p><strong>为什么要采用这种处理方法？</strong></p>
<ol>
<li>解决了并发时的安全和性能问题，当修改操作较少的时候很明显。</li>
<li>解决了多个迭代器同时修改和遍历的问题</li>
</ol>
<p><strong>什么是多个迭代器同时修改和遍历的问题？</strong></p>
<p>无论是传统线程安全的Vector，还是新容器Collection，又或者安全的新容器synchronizedCollection都没有解决 迭代器同时修改和遍历 的问题。<br>这个问题似乎是设计师在设计的时候 就不希望通过原来的容器类中的方法去修改容器的结构，而是通过iterator里面的方法操作。<br>在代码中的体现就是下面这一段：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>modCount表示容器实际被修改（add,remove,set）的次数。<br>expectedModCount是在迭代器中记录的被修改的次数。<br>因此，通过容器类中的方法修改后会改变modCount的值，而不会影响expectedModCount的值。<br>最终导致异常的产生。</p>
<p><strong>如何防止ConcurrentModificationException异常的发生？</strong></p>
<p>单线程下使用iterator里面的方法操作，remove里有以下的一段代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">expectedModCount = modCount;</span><br></pre></td></tr></table></figure></p>
<p>多线程下使用iterator也无效，<strong>为什么？</strong></p>
<ol>
<li>expectedModCount是成员变量，线程独享的。</li>
<li>多线程下非安全的容器会有额外的问题，如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationExcept();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>多线程下如何解决？</strong></p>
<ol>
<li>迭代器加锁进行同步,使得两个迭代器的遍历不会同时发生。</li>
<li>回到最初的介绍——使用免锁容器：CopyOnWriteArrayList，CopyOnWriteArraySet，synchronizedHashMap ，ConcurrentHashMap。这就理解了为什么免锁容器要采用这样的技术了。</li>
</ol>
<p>注意了，问题依然是存在的！我们继续分析：</p>
<ol>
<li>使用迭代器：要注意System.Out.println(list)这个语句也会隐含的调用迭代器。</li>
<li>使用免锁容器：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">COWIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** Snapshot of the array */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line">    <span class="comment">/** Index of element to be returned by subsequent call to next.  */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">COWIterator</span><span class="params">(Object[] elements, <span class="keyword">int</span> initialCursor)</span> </span>&#123;</span><br><span class="line">        cursor = initialCursor;</span><br><span class="line">        snapshot = elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上面是免锁后期的迭代器类，可以看到使用的是snapshot快照，并且没有加锁的操作，因此当真正的elements改变的使用，迭代的依然是数组的快照。</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁并不是加锁。而是使用原子操作compareAndSet(oldValue,newValue)实现的一个很有效的一个技巧。<br>思想：在使用最初获取数据和最后获取的数据进行对比，一致则操作成功，不一致则操作失败。</p>
<h3 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock rLock = <span class="keyword">new</span> ReadWriteLock(ture).readLock();</span><br><span class="line">Lock wLock = <span class="keyword">new</span> ReadWriteLock(ture).writeLock();</span><br></pre></td></tr></table></figure>
<p>可以同时获取多个读锁，但是写锁只有一个，一旦有线程获取到写锁，所有的读锁都会被挂起，直到写锁被释放。<br>性能上是不可确认的。</p>
<p>此章节只是冰山一角，更多的并发编程参考书籍：《JAVA Concurrency in Practice》《Concurrent Programming in Java》</p>
]]></content>
      <categories>
        <category>Thinking in Java 读书笔记</category>
      </categories>
      <tags>
        <tag>清理和初始化</tag>
        <tag>JAVA编程思想</tag>
        <tag>Thinking in JAVA</tag>
      </tags>
  </entry>
</search>
