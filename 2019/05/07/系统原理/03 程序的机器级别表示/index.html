<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  

  
    

    
  

  
    

    
  

  
    

    
  

  

  
    
    
    <link href="https://fonts.google.com//css?family=ZCOOL KuaiLe:300,300italic,400,400italic,700,700italicNoto Serif SC:300,300italic,400,400italic,700,700italicMoul:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="计算机系统原理,信息的表示和处理,">










<meta name="description" content="03 机器级别的表示1 程序编码 第一步：C预处理器扩展源代码，插入所有用#include引入的文件，并扩展所有用#define声明的宏。 第二步：编译器 产生源文件的汇编代码，以.s结尾。 第三步：汇编器 将汇编代码转成二进制目标代码文件，以.o结尾，此时还没填入全局值的地址。 第四步：链接器 将目标代码文件与库文件函数的代码合并，最终产生可执行文件，以.p结尾。  1.1 机器级代码对于机器级">
<meta name="keywords" content="计算机系统原理,信息的表示和处理">
<meta property="og:type" content="article">
<meta property="og:title" content="03 机器级别的表示">
<meta property="og:url" content="https://sunyi720.github.io/2019/05/07/系统原理/03 程序的机器级别表示/index.html">
<meta property="og:site_name" content="Sun">
<meta property="og:description" content="03 机器级别的表示1 程序编码 第一步：C预处理器扩展源代码，插入所有用#include引入的文件，并扩展所有用#define声明的宏。 第二步：编译器 产生源文件的汇编代码，以.s结尾。 第三步：汇编器 将汇编代码转成二进制目标代码文件，以.o结尾，此时还没填入全局值的地址。 第四步：链接器 将目标代码文件与库文件函数的代码合并，最终产生可执行文件，以.p结尾。  1.1 机器级代码对于机器级">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/C语言数据类型在intel中的大小.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/整数寄存器.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/操作数格式.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/简单的数据传送指令.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/零扩展数据传送指令.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/符号扩展数据传送指令.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/1.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/数据传送示例.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/3.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/2.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/4.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/5.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/6.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/7.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/10.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/11.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/12.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/13.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/14.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/15.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/16.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/17.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/18.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/19.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/20.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/21.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/22.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/23.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/24.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/25.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/26.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/27.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/28.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/29.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/30.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/31.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/32.png">
<meta property="og:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/33.png">
<meta property="og:updated_time" content="2019-05-07T12:02:22.506Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="03 机器级别的表示">
<meta name="twitter:description" content="03 机器级别的表示1 程序编码 第一步：C预处理器扩展源代码，插入所有用#include引入的文件，并扩展所有用#define声明的宏。 第二步：编译器 产生源文件的汇编代码，以.s结尾。 第三步：汇编器 将汇编代码转成二进制目标代码文件，以.o结尾，此时还没填入全局值的地址。 第四步：链接器 将目标代码文件与库文件函数的代码合并，最终产生可执行文件，以.p结尾。  1.1 机器级代码对于机器级">
<meta name="twitter:image" content="https://sunyi720.github.io/2019/05/07/系统原理/03%20程序的机器级别表示/C语言数据类型在intel中的大小.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":20},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://sunyi720.github.io/2019/05/07/系统原理/03 程序的机器级别表示/">





  <title>03 机器级别的表示 | Sun</title>
  








  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/src/love.js"></script>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Sun</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">数字人生</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sunyi720.github.io/2019/05/07/系统原理/03 程序的机器级别表示/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">03 机器级别的表示</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-07T19:54:00+08:00">
                2019-05-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机系统原理/" itemprop="url" rel="index">
                    <span itemprop="name">计算机系统原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/05/07/系统原理/03 程序的机器级别表示/" class="leancloud_visitors" data-flag-title="03 机器级别的表示">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="03-机器级别的表示"><a href="#03-机器级别的表示" class="headerlink" title="03 机器级别的表示"></a>03 机器级别的表示</h1><h2 id="1-程序编码"><a href="#1-程序编码" class="headerlink" title="1 程序编码"></a>1 程序编码</h2><ul>
<li>第一步：C<strong>预处理器</strong>扩展源代码，插入所有用#include引入的文件，并扩展所有用#define声明的宏。</li>
<li>第二步：<strong>编译器</strong> 产生源文件的汇编代码，以.s结尾。</li>
<li>第三步：<strong>汇编器</strong> 将汇编代码转成二进制目标代码文件，以.o结尾，此时还没填入全局值的地址。</li>
<li>第四步：<strong>链接器</strong> 将目标代码文件与库文件函数的代码合并，最终产生可执行文件，以.p结尾。</li>
</ul>
<h3 id="1-1-机器级代码"><a href="#1-1-机器级代码" class="headerlink" title="1.1 机器级代码"></a>1.1 机器级代码</h3><p>对于机器级编程，有两种抽象：</p>
<ol>
<li><strong>指令集体系结构或指令集架构(ISA)</strong>：定义了处理器状态，指令的格式，以及每条指令对状态的影响。指令宏观上按顺序执行，微观上并发的执行。</li>
<li>内存地址使用虚拟地址</li>
</ol>
<p>指令集体系结构的一些概念：</p>
<ul>
<li><strong>程序计算器</strong>：给出将要执行的下一条指令的内存地址。</li>
<li><strong>整数寄存器文件</strong>：可以存储地址或者整数数据。有的用来记录程序状态，其它的用来保存临时数据，譬如过程的参数和局部变量，以及函数的返回值。</li>
<li><strong>条件码寄存器</strong>：保存最近执行的算术或者逻辑指令的状态信息。</li>
<li><strong>向量寄存器</strong>：存放一个或者多个整数或者浮点数。</li>
</ul>
<p>程序的执行都离不开这些寄存器的使用，后面会了解其作用。</p>
<h3 id="1-2-代码示例"><a href="#1-2-代码示例" class="headerlink" title="1.2 代码示例"></a>1.2 代码示例</h3><p>C语言代码文件mstore.c如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">long mult2(long,long);</span><br><span class="line">void multstore(long x,long y,long *dest)&#123;</span><br><span class="line">  long t = mult2(x,y);</span><br><span class="line">  * dest = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>命令行运行：linux&gt; gcc -Og -S mstore.c 生成.s文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">multstore:</span><br><span class="line">pushq %rbx</span><br><span class="line">movq %rdx,%rbx</span><br><span class="line">call mult2</span><br><span class="line">movq %rax,(%rbx)</span><br><span class="line">popq %rbx</span><br><span class="line">ret</span><br></pre></td></tr></table></figure></p>
<p>命令行运行：linux&gt; gcc -Og -c mstore.c 生成.o文件。他是二进制的，无法阅读。1368字节的文件mstore.o中有一段14字节的文件，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3</span><br></pre></td></tr></table></figure></p>
<p>机器对产生指令的源代码一无所知。</p>
<blockquote>
<p>-Og 是一种符合C代码整体结构的代码优化级别，采用更高的代码优化级别会使机器代码和源码之间的关系非常难以理解，因此我们采用-Og来进行学习。</p>
</blockquote>
<p>反编译时，命令行运行linux&gt; objdumo -d mstore.o即可生成对应的汇编文件。</p>
<h3 id="1-3-关于格式的注解"><a href="#1-3-关于格式的注解" class="headerlink" title="1.3 关于格式的注解"></a>1.3 关于格式的注解</h3><p>执行该 linux&gt; gcc -Og -S mstore.c 命令行时，会包含很多其他的无关信息，我们省略掉这些信息，并给我们需要的信息加上固定格式的注解。</p>
<h2 id="2-数据格式"><a href="#2-数据格式" class="headerlink" title="2 数据格式"></a>2 数据格式</h2><p>8位是一个字节，16位称为 <strong>字</strong> .因此，32位数称为“双字”，64位数称为“四字”，下入给出了C语言对应的x86-64表示。</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/C语言数据类型在intel中的大小.png" alt="计算机系统原理：第三章-程序的机器级别表示"></p>
<h2 id="3-访问信息"><a href="#3-访问信息" class="headerlink" title="3 访问信息"></a>3 访问信息</h2><p>CPU中包含16个存储64位值的通用目的寄存器。</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/整数寄存器.png" alt="计算机系统原理：第三章-程序的机器级别表示"></p>
<blockquote>
<p>指令可以对每个寄存器的低位部分中存放的不同大小的数据进行操作。对于生成小于8字节的指令，寄存器中剩下的字节会有两条处理规则：</p>
<ol>
<li>生成1字节或者2字节时，剩下的字节保持不变。</li>
<li>生成4字节时，高位的4个字节被设置为0。</li>
</ol>
</blockquote>
<h3 id="3-1-操作数指示符"><a href="#3-1-操作数指示符" class="headerlink" title="3.1 操作数指示符"></a>3.1 操作数指示符</h3><p>大多数指令有一个或者多个<strong>操作数</strong>，指示出一个操作中要用到的源数据值，以及放置结果的目的位置。有如下三种类型。</p>
<ol>
<li><strong>立即数（inmediate）</strong>：表示常数值。书写方式是”$”后面跟一个值，只作为源操作数。</li>
<li><strong>寄存器(register)</strong>：表示某个寄存器的内容。书写方式是r_a表示任意寄存器a。用R[r_a]表示寄存器里的值。</li>
<li><strong>内存引用(memmery)</strong>：根据计算出来的地址访问某个内存位置。</li>
</ol>
<p>内存地址的计算方式是imm(r_a,r_i,s)</p>
<ul>
<li>imm：地址偏移量</li>
<li>r_a：基址寄存器</li>
<li>r_i：变址寄存器</li>
<li>s：比例<br>计算公式：imm+R[r_a]+R[r_i]*s</li>
</ul>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/操作数格式.png" alt="计算机系统原理：第三章-程序的机器级别表示"></p>
<blockquote>
<p>上述操作数值M后都省略了下标b，表示对开始地址后的b个字节值的引用。还要注意地址是64位的。</p>
</blockquote>
<p>M表示数据必然是在内存中</p>
<h3 id="3-2-数据传送指令"><a href="#3-2-数据传送指令" class="headerlink" title="3.2 数据传送指令"></a>3.2 数据传送指令</h3><p>指令是将源操作数的值，存放到目的操作数中。<br>这里的值可以是数据，也可以是地址。<br>具体是什么根据指令来判断。<br>一般都是地址对应数据，也有些奇葩存在，比如leap，由此也导致leap和指针有着密切的联系。</p>
<p>最简单形式的数据传送指令——MOV类，这些指令把源数据复制到目标位置，不做任何变化。</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/简单的数据传送指令.png" alt="计算机系统原理：第三章-程序的机器级别表示"></p>
<p>x86-64中规定，源操作数和目的操作数不能同时为一个内存地址。因此内存到内存需要两个指令。</p>
<blockquote>
<p>movq和movabsq的区别是：movq的源数据是32位补码，然后扩展得到的64位值。movabsq的数据是任意的64位立即数。</p>
</blockquote>
<p>根据之前提过的寄存器剩下字节处理规则，对于movl指令，会把高4位字节设置为0:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movabsq $0011223344556677 %rax %rax=0011223344556677</span><br><span class="line">movb -1,%rax %rax=00112233445566FF</span><br><span class="line">movw -1,%rax %rax=001122334455FFFF</span><br><span class="line">movl -1,%rax %rax=00000000FFFFFFFF</span><br><span class="line">movq -1,%rax %rax=FFFFFFFFFFFFFFFF</span><br></pre></td></tr></table></figure></p>
<p>当把较小的数值复制到较大的目的时，使用MOVZ和MOVS指令：</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/零扩展数据传送指令.png" alt="计算机系统原理：第三章-程序的机器级别表示"><br><img src="/2019/05/07/系统原理/03 程序的机器级别表示/符号扩展数据传送指令.png" alt="计算机系统原理：第三章-程序的机器级别表示"></p>
<p>不一样的是，MOVZ在高位作零扩展，MOVS作符号扩展，案例如下：</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/1.png" alt="计算机系统原理：第三章-程序的机器级别表示"></p>
<h3 id="3-3-数据传送示例"><a href="#3-3-数据传送示例" class="headerlink" title="3.3 数据传送示例"></a>3.3 数据传送示例</h3><p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/数据传送示例.png" alt="计算机系统原理：第三章-程序的机器级别表示"></p>
<p>我们可以看到：</p>
<ol>
<li>所谓指针，其实就是地址。</li>
<li>局部变量通常保存在寄存器中，而不是内存中。访问寄存器比访问内存要快很多。</li>
</ol>
<h3 id="3-4-圧入和弹出栈数据"><a href="#3-4-圧入和弹出栈数据" class="headerlink" title="3.4 圧入和弹出栈数据"></a>3.4 圧入和弹出栈数据</h3><p><strong>什么是内存栈？</strong></p>
<p>内存栈是一种存储结构<br>栈指针是一个寄存器(%rsp)，保存着指向栈顶的地址。</p>
<p>入栈和出栈的指令如下：</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/3.png" alt="计算机系统原理：第三章-程序的机器级别表示"></p>
<p>在内存的操作对应如下：</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/2.png" alt="计算机系统原理：第三章-程序的机器级别表示"></p>
<p>pushq的指令也可以使用subq+movq来代替，区别是前者只需要1个字节，后者需要8个字节。</p>
<h2 id="4-算术和逻辑指令"><a href="#4-算术和逻辑指令" class="headerlink" title="4.算术和逻辑指令"></a>4.算术和逻辑指令</h2><p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/4.png" alt="计算机系统原理：第三章-程序的机器级别表示"></p>
<p>除了leaq之外，每个指令类都有4种不同大小的指令（1,2,4,8位）</p>
<h3 id="4-1-加载有效地址指令leaq"><a href="#4-1-加载有效地址指令leaq" class="headerlink" title="4.1 加载有效地址指令leaq"></a>4.1 加载有效地址指令leaq</h3><p>leaq是movq的变种，与movq不同的是，leaq不是存储源操作数的值，而是存储它的地址。</p>
<ul>
<li>movq (%rdi),%rax 值将%rdi寄存器中的地址的值存放到%rax寄存器中</li>
<li>leaq (%rdi),%rax 是将%rdi寄存器中的地址存放到%rax寄存器中</li>
</ul>
<p>leaq指令就类似c中的指针</p>
<h3 id="4-4-讨论"><a href="#4-4-讨论" class="headerlink" title="4.4 讨论"></a>4.4 讨论</h3><p>从图中可以看到，除了位移指令，大部分的指令既可用于无符号运算，也可用于补码运算。这个特性也导致使用补码作为有符号整数参与运算.<br>区分有符号无符号是通过指令来判断的，指令值针对有符号的操作就表示数据有符号，指令值针对无符号的操作就表示数据有无符号。</p>
<h3 id="4-5-特殊的算术操作"><a href="#4-5-特殊的算术操作" class="headerlink" title="4.5 特殊的算术操作"></a>4.5 特殊的算术操作</h3><p>下面的这些指令支持两个64位的指令相乘得到128位的结果</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/5.png" alt="计算机系统原理：第三章-程序的机器级别表示"></p>
<p>要求%rax寄存器（这其实就是一个累加器）中存在一个值<br>imulq这个指令可以用于两个不同的操作，汇编器能够通过计算操作数的数目来分辨。</p>
<p>案例：</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/6.png" alt="特殊算术操作案例"><br><img src="/2019/05/07/系统原理/03 程序的机器级别表示/7.png" alt="特殊算术操作案例"></p>
<p>高位字节存储在大地址</p>
<p><strong>如果我们不想按照指令顺序一步一步执行？</strong></p>
<h2 id="5-控制"><a href="#5-控制" class="headerlink" title="5 控制"></a>5 控制</h2><p>使用jump指令可以改变指令的执行顺序<br>条件，循环，分支。</p>
<h3 id="5-1-条件码"><a href="#5-1-条件码" class="headerlink" title="5.1 条件码"></a>5.1 条件码</h3><p>除了整数寄存器，CPU还维护着一组<strong>单个位</strong>条件码寄存器，描述了最近的算术或逻辑操作属性。<br>常用的条件码有：</p>
<ul>
<li>CF：进位标志，最近的操作是否使最高位产生进位，可用来检查无符号操作的溢出。</li>
<li>ZF：零标志，最近的操作计算的结果为零</li>
<li>SF：符号标志，最近的操作结果为负</li>
<li>OF：溢出标志，最近的操作导致补码溢出</li>
</ul>
<p>如有一个表达式t=a+b，条件码会根据这个表达式设置值如下：</p>
<ul>
<li>CF：（unsigned）t &lt; (unsignded) a</li>
<li>ZF：（t==0）</li>
<li>SF：（t&lt;0）</li>
<li>OF:(a&lt;0 == b&lt;0)&amp;&amp;(t&lt;0 != a&lt;0)<blockquote>
<p>leap指令不会改变条件码</p>
</blockquote>
</li>
</ul>
<p>有些指令不会改变寄存器的值，而是简单的改变条件码寄存器。<br>cmp类似sub，test类似and</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/10.png" alt="只改变条件码寄存器的指令"></p>
<h3 id="5-2-访问条件码"><a href="#5-2-访问条件码" class="headerlink" title="5.2 访问条件码"></a>5.2 访问条件码</h3><p><strong>条件码有什么用呢？</strong></p>
<p>用作<em>条件</em></p>
<p><strong>条件码如何使用呢？</strong></p>
<p>一般并不直接访问单个条件码寄存器</p>
<ol>
<li>可以通过条件码寄存器的组合结果来将一个字节设置为0或者1。</li>
<li>可以通过条件码寄存器的组合结果来跳转到其它地方</li>
<li>可以通过条件码寄存器的组合结果来传输数据</li>
</ol>
<p>常用的指令组合（大于小于等于）有：</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/11.png" alt="常用的SET指令"></p>
<h3 id="5-3-跳转"><a href="#5-3-跳转" class="headerlink" title="5.3 跳转"></a>5.3 跳转</h3><p>jump是直接跳转，其它的是结合条件码的组合来跳转。</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/12.png" alt="跳转指令"></p>
<p>jump也有分为两种：</p>
<ul>
<li>直接跳转：目的地是指令编码中指定的地点，如jmp .L1</li>
<li>间接跳转：目的地是寄存器或内存地址，如jmp *%rax，*(%rax)</li>
</ul>
<h3 id="5-4-跳转指令的编码"><a href="#5-4-跳转指令的编码" class="headerlink" title="5.4 跳转指令的编码"></a>5.4 跳转指令的编码</h3><p><strong>对于“目的地”如何机器编码？</strong></p>
<ol>
<li>PV相对寻址：以下一地址的偏移量（负表示到之前）所得作为目的地</li>
<li>绝对寻址：直接给出跳转的目的地址</li>
</ol>
<p>案例：<br><img src="/2019/05/07/系统原理/03 程序的机器级别表示/13.png" alt="跳转目标的机器表示"></p>
<h3 id="5-5-实现条件分支"><a href="#5-5-实现条件分支" class="headerlink" title="5.5 实现条件分支"></a>5.5 实现条件分支</h3><p><strong>如何实现条件分支？</strong></p>
<ol>
<li>条件跳转</li>
</ol>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/14.png" alt="条件跳转实现条件分支"></p>
<ol start="2">
<li>条件传送（条件赋值）</li>
</ol>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/15.png" alt="条件赋值实现条件分支"></p>
<p><strong>两种方式有何区别？</strong></p>
<ul>
<li><p>在分支比较简单时，使用条件赋值较好：<br>一条指令的处理要经过一系列阶段（从内存取指令、确定指令类型、从内存取数据、执行算术运算、从内存写数据、更新程序计数器）<br>处理器通过使用 <em>流水线（pipelining）</em> 来提高性能<br>大概就是通过同时执行指令的不同阶段<br>这要求指令是顺序的，因此当遇到分支（条件跳转）时，要么选择等待，要么采用非常精密的分支预测逻辑来预测执行<br>这就意味着要承担错误预测的风险（消耗）</p>
<p>x84_64可用的条件赋值指令有：</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/16.png" alt="条件赋值指令"></p>
</li>
<li><p>在分支比较复杂时，使用条件跳转较好：<br>在条件赋值的处理下，无论最后走哪一条分支，两条分支的逻辑都会被执行<br>这就会出现：</p>
<ol>
<li>如果有一条分支需要大量的计算，当条件不满足时，那就相当于做了无用功。</li>
<li>可能在一条分支上出现了错误（技师在条件永不满足），也会被执行报错</li>
</ol>
</li>
</ul>
<h3 id="实现循环"><a href="#实现循环" class="headerlink" title="实现循环"></a>实现循环</h3><p><strong>如何实现循环分支？</strong></p>
<p>使用条件码（比较、测试）和条件跳转可以实现循环，如下：</p>
<ol>
<li><p>do-while</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/17.png" alt="do-while"></p>
</li>
<li><p>while<br>有两种</p>
<ol>
<li>jump to middle</li>
</ol>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/18.png" alt="jump to middle"></p>
<ol start="2">
<li>jguarded-do</li>
</ol>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/19.png" alt="guarded-do"></p>
</li>
<li><p>for<br>for语句可以转换为while语句来实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(init-expr;test-expr;update-expr)</span><br><span class="line">  body-statement</span><br><span class="line">===========================</span><br><span class="line">init-expr;</span><br><span class="line">while(test-expr)&#123;</span><br><span class="line">    body-statement</span><br><span class="line">    update-expr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p><strong>如何实现switch分支？</strong></p>
<p>同样是使用条件（无条件）跳转来实现的<br>跳转的地址用一个数组保存（&amp;表示指向数据值的地址，&amp;&amp;表示指向标记代码位置的地址）<br>数组索引是分支的开关，通过计算得到</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/20.png" alt="switch"></p>
<p>对应的汇编代码如下：</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/21.png" alt="switch汇编"></p>
<p>jmp *.L4(,%rsi,8)<br>表示一个间接跳转，地址为 8 * R[%rsi] + .L4</p>
<p>跳转表数组对应的内存：</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/22.png" alt="跳转表"></p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p><strong>什么是过程？</strong></p>
<p>指令集合<br>可被调用<br>函数、方法、子例程、处理函数等等</p>
<p><strong>一个过程涉及到哪些步骤？</strong></p>
<p>假设过程P调用过程Q，过程Q执行后返回到P。<br>这个动作包括下面的一个或多个机制：</p>
<ol>
<li>传递控制：程序计数器必须设置为Q代码的起始地址，然后在返回时，要把程序计数器指向调用Q的下一行指令地址。</li>
<li>传递数据：P可以向Q提供参数，Q可以向P返回结果值</li>
<li>分配和释放额内存：Q需要为局部变量分配空间，返回后又需要释放这些空间</li>
</ol>
<p>接来下一一说明这些机制如何实现;</p>
<h3 id="运行时栈"><a href="#运行时栈" class="headerlink" title="运行时栈"></a>运行时栈</h3><p>大多数语言都使用一种内存结构——栈帧——来控制过程</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/23.png" alt="栈帧"></p>
<h3 id="传递控制"><a href="#传递控制" class="headerlink" title="传递控制"></a>传递控制</h3><p><strong>传递控制如何实现？</strong></p>
<p>使用call和ret指令实现传递控制<br>call Q调用过程Q，同时把返回地址A压入栈</p>
<blockquote>
<p>callq和retq表明是x86-64版本</p>
</blockquote>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/24.png" alt="call和ret"></p>
<p><strong>具体是如何退出？</strong></p>
<p>当过程需要退出时，会释放当前的内存<br>这时候栈帧会指向返回地址A<br>ret会取出该地址，并将程序计数器（%rpi）修改为该地址</p>
<p>案例：</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/25.png" alt="过程案例"></p>
<p>下图是这个案例中call和ret对栈的操作栈过程：</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/26.png" alt="call和ret的操作栈过程"></p>
<p>%rip：程序计数器（寄存器）<br>%rsp：栈顶指针（寄存器）</p>
<h3 id="传递数据"><a href="#传递数据" class="headerlink" title="传递数据"></a>传递数据</h3><p><strong>传递数据如何实现？</strong></p>
<p>大部分过程间数据传递都是通过寄存器实现的<br>有6个寄存器被用来参数传递，寄存器使用的按照参数的顺序，寄存器的名字取决于要传递的数据类型的大小<br>用%rax来返回结果值</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/27.png" alt="用来传参的寄存器"></p>
<p><strong>多于6个参数怎么办？</strong></p>
<p>多于6个的参数会被放到栈帧中，通过帧指针（存放在%rbp中）调用来使用<br>每个参数都占用8个字节</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/28.png" alt="用来传参的栈帧"></p>
<p><strong>这些参数在被调用的过程中如何使用？</strong></p>
<ol>
<li>寄存器中的参数：直接使用寄存器</li>
<li>存放在栈帧中的参数：通过上一过程最后一帧的地址（帧指针）来访问</li>
</ol>
<h3 id="分配和释放栈帧内存"><a href="#分配和释放栈帧内存" class="headerlink" title="分配和释放栈帧内存"></a>分配和释放栈帧内存</h3><p>之前说过，寄存器是可以用来存放过程中的局部数据<br>那么，<strong>在什么时候需要用栈帧来存储参数和局部数据？</strong></p>
<p>寄存器不够用，常见的情况有：</p>
<ol>
<li>本地数据太多</li>
<li>对局部变量使用了地址运算符‘&amp;’（意味着必须存放到内存地址中）</li>
<li>使用了数组或者结构体（这些连续的空间必须在内存上才能实现）</li>
</ol>
<p><strong>多的局部数据如何保存在栈帧中？</strong></p>
<p>这也可以通过分配栈帧和释放栈帧空间来实现：</p>
<ol>
<li>进入一个新的过程，分配内存空间</li>
<li>局部意味着只在当前过程中有效，因此离开的时候需要释放这部分空间</li>
</ol>
<p>案例：</p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/29.png" alt="分配和释放栈帧内存"></p>
<h3 id="寄存器中的局部数据"><a href="#寄存器中的局部数据" class="headerlink" title="寄存器中的局部数据"></a>寄存器中的局部数据</h3><p>存放在过程栈帧中的局部数据是当前过程一直有效的</p>
<p>但是寄存器是所有过程共享的，这意味着在过程调用中，寄存器中的值可能会被改变，那么，<strong>如何确保存当前过程寄存器中的局部数据是一致的？</strong></p>
<ol>
<li>分析有哪些寄存器数据是在调用其他过程后会被修改的</li>
<li>把这些寄存器数据存起来</li>
<li>调用其他过程返回后恢复数据</li>
</ol>
<p><strong>如何保存这些寄存器？</strong></p>
<p>x86-64采用了一组统一的寄存器使用惯例（%rbx、%rbp、%r12~%r15）：<br><em>被调用者保存寄存器</em>：被调用者在开始前必须保存这些寄存器（会发生变化的）中的数据，以返回时恢复这些数据<br>把之前谈到的变化数据存放到<em>被调用者保存寄存器</em>中即可<br>保存的方式是在分配栈空间就先把这些数据压入栈中，释放空间后再弹出。</p>
<p>案例：<br><img src="/2019/05/07/系统原理/03 程序的机器级别表示/30.png" alt="被调用者保存寄存器"></p>
<p><strong>当被调用者保存寄存器不够用了怎么办？</strong></p>
<h3 id="递归过程"><a href="#递归过程" class="headerlink" title="递归过程"></a>递归过程</h3><p>栈规则提供了一种机制，每次函数调用都有它自己私有的状态信息。<br>调用本身和调用其他函数是一样的</p>
<p>案例：<br><img src="/2019/05/07/系统原理/03 程序的机器级别表示/31.png" alt="递归过程"></p>
<h2 id="数组分配和访问"><a href="#数组分配和访问" class="headerlink" title="数组分配和访问"></a>数组分配和访问</h2><p><strong>数组是如何存储的？</strong></p>
<p>C语言：<br>数组是内存上的连续空间<br>标志符作为指向数组的开头指针</p>
<p><strong>如何使用指令来访问数组？</strong></p>
<p>假设是int型数组(4字节)<br>将开头指针存放在寄存器%rdx中<br>索引存放在寄存器%rcx中<br>可以使用<movl (%rdx,%rcx,4),%eax="">来访问</movl></p>
<h3 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h3><p>C语言允许指针运算：<br>p+i = p的地址 + i * p的数据类型大小</p>
<h3 id="数组嵌套"><a href="#数组嵌套" class="headerlink" title="数组嵌套"></a>数组嵌套</h3><p><strong>二维数组、三维数组如何表示？</strong></p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/32.png" alt="数组嵌套"></p>
<p>T D[R][C];<br>计算公式：&amp;D[i][j] = D + L(C * i + j);</p>
<p>L是数据类型的大小(字节)</p>
<h3 id="定长数组和变长数组"><a href="#定长数组和变长数组" class="headerlink" title="定长数组和变长数组"></a>定长数组和变长数组</h3><p><strong>什么是定长和变长？</strong></p>
<p>定和变是相对编译前后而言的</p>
<p>定长：数组的长度编译之后是固定的<br>变长：数组的长度编译之后   可能会不同</p>
<p>变长数组性能上会大打折扣，<strong>为什么？</strong></p>
<ol>
<li>需要额外的寄存器来存放数组长度参数</li>
<li>在计算C*i的时候必须使用乘法指令，而不能使用leaq指令来实现，乘法指令会有性能处罚。</li>
</ol>
<h2 id="异质的数据结构"><a href="#异质的数据结构" class="headerlink" title="异质的数据结构"></a>异质的数据结构</h2><p>C语言提供给了两种把不同的数据类型组合到一起创建新的数据类型的机制：结构和联合</p>
<blockquote>
<p>机器代码不包含关于字段声明和字段名字的信息，这些都在编译时期被处理。</p>
</blockquote>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>和数组一样，结构体是内存上一段连续的空间。</p>
<p>案例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct rec&#123;</span><br><span class="line">  int i;</span><br><span class="line">  int j;</span><br><span class="line">  int a[2];</span><br><span class="line">  int *p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/05/07/系统原理/03 程序的机器级别表示/33.png" alt="结构体"></p>
<h3 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h3><p><strong>为什么需要数据对齐？</strong></p>
<p>CPU为了提高读写效率，一般都是一次读写多个字节，如8字节<br>如果能确保一个数据能在一次内存读写中获取，是提高性能的一个方式</p>
<p><strong>如何保证？</strong></p>
<p>确保K字节的数据类型地址（偏移）是K的倍数<br>如：<br>1字节的char地址（偏移）是1的倍数<br>2字节的short地址（偏移）是2的倍数<br>4字节的int地址（偏移）是4的倍数<br>8字节的double地址（偏移）是8的倍数</p>
<p>因此在一个结构体中，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct S1&#123;</span><br><span class="line">  char c;</span><br><span class="line">  int i;</span><br><span class="line">  char f;</span><br><span class="line">  double j;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>sizeof(S1) = 4 + 4 + 8 + 8 = 24  </p>
<blockquote>
<p>一般编译器会替我们选择适合目标平台的对齐策略</p>
</blockquote>
<p>.align 8 可以指定全部数据的对齐</p>
<h2 id="机器级程序中控制和数据的互动"><a href="#机器级程序中控制和数据的互动" class="headerlink" title="机器级程序中控制和数据的互动"></a>机器级程序中控制和数据的互动</h2><p>越底层的操作，越能看清数据和控制的互动<br>譬如C中<em>指针</em></p>
<h3 id="理解指针"><a href="#理解指针" class="headerlink" title="理解指针"></a>理解指针</h3><ol>
<li>每个指针都对应一个类型：<int \*ip=""><char \*\*cpp=""></char></int></li>
<li>每一个指针都有一个值：数据的地址</li>
<li>使用‘&amp;’获取数据的指针</li>
<li>使用‘*’使用指针</li>
<li>数组和指针关系密切：数组标志符就是指针</li>
<li>指针的强转只改变类型，不改变值</li>
<li>指针也可以指向函数<int (\*fp)(int,int\*)=""></int></li>
</ol>
<h3 id="内存越界和缓存区溢出"><a href="#内存越界和缓存区溢出" class="headerlink" title="内存越界和缓存区溢出"></a>内存越界和缓存区溢出</h3><p>对指针的操作不会有任何的边界检查，因此会操作一些溢出问题</p>
<p><strong>溢出会有什么影响？</strong></p>
<p>譬如数组，C中的gets(char[])就会有溢出问题<br>首先，数组是存储在栈上的<br>那么数组越界操作会直接导致修改了栈上的其他数据<br>更严重的影响是：修改栈中返回地址，指向一段被越界操作篡改了的攻击代码，也就是所谓的“病毒”和“蠕虫”</p>
<p><strong>如何预防？</strong></p>
<p>修改返回地址需要知道当前字符串存放的栈地址<br>这在以往的机器上都是固定的，因此可以模拟出攻击代码</p>
<p>由此一个预防的方法是<em>栈随机化</em><br>每次运行程序都有一个随机的栈地址<br>32位计算机栈随机范围是2^23<br>64位计算机栈随机范围是2^32</p>
<p>但是，与此同时，又有一个更暴力的攻击方式，对返回地址进个遍历修改<br>在实际的攻击代码之前插入一段‘nop指令’<br>这个指令的作用是：对程序计数器加一，没有其他的效果<br>这样，运用暴力方法，最终能执行到攻击代码</p>
<p>第二种预防方式解决了这个问题：<br>C中是无法防止对数组越界写的，但是可以检查出是否越界<br>在缓冲区之前存储一个特殊值（金丝雀值）<br>在离开过程前检查这个值，如果发现该值被修改<br>则程序异常终止</p>
<p>现在的C大部分都默认采用后者进行保护</p>
<p>第三种方案是区别对待内存上的区域：读、写和可执行<br>JAVA等语言采用的就是这种方式</p>
<h3 id="支持变长的帧栈"><a href="#支持变长的帧栈" class="headerlink" title="支持变长的帧栈"></a>支持变长的帧栈</h3><p><strong>如何理解变长的栈帧？</strong></p>
<p>大部分代码是在编译之后就能确定需要分配多少栈帧空间<br>但是也有特殊的情况<br>譬如alloca函数，可以在栈上分配任意字节的数量<br>又譬如变长数组</p>
<p><strong>如何实现变长数组的内存分配？</strong></p>
<p>使用subq分配栈帧空间时 无法使用立即数 ，而是需要通过参数计算出来。</p>
<h2 id="浮点代码"><a href="#浮点代码" class="headerlink" title="浮点代码"></a>浮点代码</h2><p>如何存储和访问浮点数？<br>浮点数作为参数和返回的规则？<br>对浮点数据操作的指令？<br>浮点数和整数之间的转换？<br>浮点数之间的转换？</p>

      
    </div>
    
    
    

	
	<div>
      
        
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>
  
  <!-- JS库 sweetalert 可修改路径 -->
  <script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script>
  <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
  <p><span>本文标题:</span><a href="/2019/05/07/系统原理/03 程序的机器级别表示/">03 机器级别的表示</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 Sun 的个人博客">Sun</a></p>
  <p><span>发布时间:</span>2019年05月07日 - 19:05</p>
  <p><span>最后更新:</span>2019年05月07日 - 20:05</p>
  <p><span>原始链接:</span><a href="/2019/05/07/系统原理/03 程序的机器级别表示/" title="03 机器级别的表示">https://sunyi720.github.io/2019/05/07/系统原理/03 程序的机器级别表示/</a>
    <span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://sunyi720.github.io/2019/05/07/系统原理/03 程序的机器级别表示/" aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>  
</div>
<script> 
    var clipboard = new Clipboard('.fa-clipboard');
    $(".fa-clipboard").click(function(){
      clipboard.on('success', function(){
        swal({   
          title: "",   
          text: '复制成功',
          icon: "success", 
          showConfirmButton: true
          });
    });
    });  
</script>

      
    </div>

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div></div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="Sun 微信支付">
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="Sun 支付宝">
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/计算机系统原理/" rel="tag"><i class="fa fa-tag"></i> 计算机系统原理</a>
          
            <a href="/tags/信息的表示和处理/" rel="tag"><i class="fa fa-tag"></i> 信息的表示和处理</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/25/cmpNet/计算机网络自顶向下：第四章-网络层/" rel="next" title="计算机网络自顶向下：第四章-网络层">
                <i class="fa fa-chevron-left"></i> 计算机网络自顶向下：第四章-网络层
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zNjMzMS8xMjg2Ng=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/head.png" alt="Sun">
            
              <p class="site-author-name" itemprop="name">Sun</p>
              <p class="site-description motion-element" itemprop="description">Lv.0</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/sunyi720" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#03-机器级别的表示"><span class="nav-number">1.</span> <span class="nav-text">03 机器级别的表示</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-程序编码"><span class="nav-number">1.1.</span> <span class="nav-text">1 程序编码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-机器级代码"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 机器级代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-代码示例"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2 代码示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-关于格式的注解"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.3 关于格式的注解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-数据格式"><span class="nav-number">1.2.</span> <span class="nav-text">2 数据格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-访问信息"><span class="nav-number">1.3.</span> <span class="nav-text">3 访问信息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-操作数指示符"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1 操作数指示符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-数据传送指令"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2 数据传送指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-数据传送示例"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.3 数据传送示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-圧入和弹出栈数据"><span class="nav-number">1.3.4.</span> <span class="nav-text">3.4 圧入和弹出栈数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-算术和逻辑指令"><span class="nav-number">1.4.</span> <span class="nav-text">4.算术和逻辑指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-加载有效地址指令leaq"><span class="nav-number">1.4.1.</span> <span class="nav-text">4.1 加载有效地址指令leaq</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-讨论"><span class="nav-number">1.4.2.</span> <span class="nav-text">4.4 讨论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-特殊的算术操作"><span class="nav-number">1.4.3.</span> <span class="nav-text">4.5 特殊的算术操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-控制"><span class="nav-number">1.5.</span> <span class="nav-text">5 控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-条件码"><span class="nav-number">1.5.1.</span> <span class="nav-text">5.1 条件码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-访问条件码"><span class="nav-number">1.5.2.</span> <span class="nav-text">5.2 访问条件码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-跳转"><span class="nav-number">1.5.3.</span> <span class="nav-text">5.3 跳转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-跳转指令的编码"><span class="nav-number">1.5.4.</span> <span class="nav-text">5.4 跳转指令的编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-实现条件分支"><span class="nav-number">1.5.5.</span> <span class="nav-text">5.5 实现条件分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现循环"><span class="nav-number">1.5.6.</span> <span class="nav-text">实现循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#switch语句"><span class="nav-number">1.5.7.</span> <span class="nav-text">switch语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#过程"><span class="nav-number">1.6.</span> <span class="nav-text">过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#运行时栈"><span class="nav-number">1.6.1.</span> <span class="nav-text">运行时栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#传递控制"><span class="nav-number">1.6.2.</span> <span class="nav-text">传递控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#传递数据"><span class="nav-number">1.6.3.</span> <span class="nav-text">传递数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分配和释放栈帧内存"><span class="nav-number">1.6.4.</span> <span class="nav-text">分配和释放栈帧内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#寄存器中的局部数据"><span class="nav-number">1.6.5.</span> <span class="nav-text">寄存器中的局部数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#递归过程"><span class="nav-number">1.6.6.</span> <span class="nav-text">递归过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组分配和访问"><span class="nav-number">1.7.</span> <span class="nav-text">数组分配和访问</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#指针运算"><span class="nav-number">1.7.1.</span> <span class="nav-text">指针运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组嵌套"><span class="nav-number">1.7.2.</span> <span class="nav-text">数组嵌套</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定长数组和变长数组"><span class="nav-number">1.7.3.</span> <span class="nav-text">定长数组和变长数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异质的数据结构"><span class="nav-number">1.8.</span> <span class="nav-text">异质的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#结构体"><span class="nav-number">1.8.1.</span> <span class="nav-text">结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据对齐"><span class="nav-number">1.8.2.</span> <span class="nav-text">数据对齐</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#机器级程序中控制和数据的互动"><span class="nav-number">1.9.</span> <span class="nav-text">机器级程序中控制和数据的互动</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#理解指针"><span class="nav-number">1.9.1.</span> <span class="nav-text">理解指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存越界和缓存区溢出"><span class="nav-number">1.9.2.</span> <span class="nav-text">内存越界和缓存区溢出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#支持变长的帧栈"><span class="nav-number">1.9.3.</span> <span class="nav-text">支持变长的帧栈</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#浮点代码"><span class="nav-number">1.10.</span> <span class="nav-text">浮点代码</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sun</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("iTVMQ8rz1NpV1RJ716VOA2rG-gzGzoHsz", "j0zy5JQ2bmQXtJ8PeP5gAiKM");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.4"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.4"></script>


  

</body>
</html>
